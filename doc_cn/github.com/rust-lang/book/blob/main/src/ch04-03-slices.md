{"payload":{"allShortcutsEnabled":false,"fileTree":{"src":{"items":[{"name":"img","path":"src/img","contentType":"directory"},{"name":"SUMMARY.md","path":"src/SUMMARY.md","contentType":"file"},{"name":"appendix-00.md","path":"src/appendix-00.md","contentType":"file"},{"name":"appendix-01-keywords.md","path":"src/appendix-01-keywords.md","contentType":"file"},{"name":"appendix-02-operators.md","path":"src/appendix-02-operators.md","contentType":"file"},{"name":"appendix-03-derivable-traits.md","path":"src/appendix-03-derivable-traits.md","contentType":"file"},{"name":"appendix-04-useful-development-tools.md","path":"src/appendix-04-useful-development-tools.md","contentType":"file"},{"name":"appendix-05-editions.md","path":"src/appendix-05-editions.md","contentType":"file"},{"name":"appendix-06-translation.md","path":"src/appendix-06-translation.md","contentType":"file"},{"name":"appendix-07-nightly-rust.md","path":"src/appendix-07-nightly-rust.md","contentType":"file"},{"name":"ch00-00-introduction.md","path":"src/ch00-00-introduction.md","contentType":"file"},{"name":"ch01-00-getting-started.md","path":"src/ch01-00-getting-started.md","contentType":"file"},{"name":"ch01-01-installation.md","path":"src/ch01-01-installation.md","contentType":"file"},{"name":"ch01-02-hello-world.md","path":"src/ch01-02-hello-world.md","contentType":"file"},{"name":"ch01-03-hello-cargo.md","path":"src/ch01-03-hello-cargo.md","contentType":"file"},{"name":"ch02-00-guessing-game-tutorial.md","path":"src/ch02-00-guessing-game-tutorial.md","contentType":"file"},{"name":"ch03-00-common-programming-concepts.md","path":"src/ch03-00-common-programming-concepts.md","contentType":"file"},{"name":"ch03-01-variables-and-mutability.md","path":"src/ch03-01-variables-and-mutability.md","contentType":"file"},{"name":"ch03-02-data-types.md","path":"src/ch03-02-data-types.md","contentType":"file"},{"name":"ch03-03-how-functions-work.md","path":"src/ch03-03-how-functions-work.md","contentType":"file"},{"name":"ch03-04-comments.md","path":"src/ch03-04-comments.md","contentType":"file"},{"name":"ch03-05-control-flow.md","path":"src/ch03-05-control-flow.md","contentType":"file"},{"name":"ch04-00-understanding-ownership.md","path":"src/ch04-00-understanding-ownership.md","contentType":"file"},{"name":"ch04-01-what-is-ownership.md","path":"src/ch04-01-what-is-ownership.md","contentType":"file"},{"name":"ch04-02-references-and-borrowing.md","path":"src/ch04-02-references-and-borrowing.md","contentType":"file"},{"name":"ch04-03-slices.md","path":"src/ch04-03-slices.md","contentType":"file"},{"name":"ch05-00-structs.md","path":"src/ch05-00-structs.md","contentType":"file"},{"name":"ch05-01-defining-structs.md","path":"src/ch05-01-defining-structs.md","contentType":"file"},{"name":"ch05-02-example-structs.md","path":"src/ch05-02-example-structs.md","contentType":"file"},{"name":"ch05-03-method-syntax.md","path":"src/ch05-03-method-syntax.md","contentType":"file"},{"name":"ch06-00-enums.md","path":"src/ch06-00-enums.md","contentType":"file"},{"name":"ch06-01-defining-an-enum.md","path":"src/ch06-01-defining-an-enum.md","contentType":"file"},{"name":"ch06-02-match.md","path":"src/ch06-02-match.md","contentType":"file"},{"name":"ch06-03-if-let.md","path":"src/ch06-03-if-let.md","contentType":"file"},{"name":"ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","path":"src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","contentType":"file"},{"name":"ch07-01-packages-and-crates.md","path":"src/ch07-01-packages-and-crates.md","contentType":"file"},{"name":"ch07-02-defining-modules-to-control-scope-and-privacy.md","path":"src/ch07-02-defining-modules-to-control-scope-and-privacy.md","contentType":"file"},{"name":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","path":"src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","contentType":"file"},{"name":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","path":"src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","contentType":"file"},{"name":"ch07-05-separating-modules-into-different-files.md","path":"src/ch07-05-separating-modules-into-different-files.md","contentType":"file"},{"name":"ch08-00-common-collections.md","path":"src/ch08-00-common-collections.md","contentType":"file"},{"name":"ch08-01-vectors.md","path":"src/ch08-01-vectors.md","contentType":"file"},{"name":"ch08-02-strings.md","path":"src/ch08-02-strings.md","contentType":"file"},{"name":"ch08-03-hash-maps.md","path":"src/ch08-03-hash-maps.md","contentType":"file"},{"name":"ch09-00-error-handling.md","path":"src/ch09-00-error-handling.md","contentType":"file"},{"name":"ch09-01-unrecoverable-errors-with-panic.md","path":"src/ch09-01-unrecoverable-errors-with-panic.md","contentType":"file"},{"name":"ch09-02-recoverable-errors-with-result.md","path":"src/ch09-02-recoverable-errors-with-result.md","contentType":"file"},{"name":"ch09-03-to-panic-or-not-to-panic.md","path":"src/ch09-03-to-panic-or-not-to-panic.md","contentType":"file"},{"name":"ch10-00-generics.md","path":"src/ch10-00-generics.md","contentType":"file"},{"name":"ch10-01-syntax.md","path":"src/ch10-01-syntax.md","contentType":"file"},{"name":"ch10-02-traits.md","path":"src/ch10-02-traits.md","contentType":"file"},{"name":"ch10-03-lifetime-syntax.md","path":"src/ch10-03-lifetime-syntax.md","contentType":"file"},{"name":"ch11-00-testing.md","path":"src/ch11-00-testing.md","contentType":"file"},{"name":"ch11-01-writing-tests.md","path":"src/ch11-01-writing-tests.md","contentType":"file"},{"name":"ch11-02-running-tests.md","path":"src/ch11-02-running-tests.md","contentType":"file"},{"name":"ch11-03-test-organization.md","path":"src/ch11-03-test-organization.md","contentType":"file"},{"name":"ch12-00-an-io-project.md","path":"src/ch12-00-an-io-project.md","contentType":"file"},{"name":"ch12-01-accepting-command-line-arguments.md","path":"src/ch12-01-accepting-command-line-arguments.md","contentType":"file"},{"name":"ch12-02-reading-a-file.md","path":"src/ch12-02-reading-a-file.md","contentType":"file"},{"name":"ch12-03-improving-error-handling-and-modularity.md","path":"src/ch12-03-improving-error-handling-and-modularity.md","contentType":"file"},{"name":"ch12-04-testing-the-librarys-functionality.md","path":"src/ch12-04-testing-the-librarys-functionality.md","contentType":"file"},{"name":"ch12-05-working-with-environment-variables.md","path":"src/ch12-05-working-with-environment-variables.md","contentType":"file"},{"name":"ch12-06-writing-to-stderr-instead-of-stdout.md","path":"src/ch12-06-writing-to-stderr-instead-of-stdout.md","contentType":"file"},{"name":"ch13-00-functional-features.md","path":"src/ch13-00-functional-features.md","contentType":"file"},{"name":"ch13-01-closures.md","path":"src/ch13-01-closures.md","contentType":"file"},{"name":"ch13-02-iterators.md","path":"src/ch13-02-iterators.md","contentType":"file"},{"name":"ch13-03-improving-our-io-project.md","path":"src/ch13-03-improving-our-io-project.md","contentType":"file"},{"name":"ch13-04-performance.md","path":"src/ch13-04-performance.md","contentType":"file"},{"name":"ch14-00-more-about-cargo.md","path":"src/ch14-00-more-about-cargo.md","contentType":"file"},{"name":"ch14-01-release-profiles.md","path":"src/ch14-01-release-profiles.md","contentType":"file"},{"name":"ch14-02-publishing-to-crates-io.md","path":"src/ch14-02-publishing-to-crates-io.md","contentType":"file"},{"name":"ch14-03-cargo-workspaces.md","path":"src/ch14-03-cargo-workspaces.md","contentType":"file"},{"name":"ch14-04-installing-binaries.md","path":"src/ch14-04-installing-binaries.md","contentType":"file"},{"name":"ch14-05-extending-cargo.md","path":"src/ch14-05-extending-cargo.md","contentType":"file"},{"name":"ch15-00-smart-pointers.md","path":"src/ch15-00-smart-pointers.md","contentType":"file"},{"name":"ch15-01-box.md","path":"src/ch15-01-box.md","contentType":"file"},{"name":"ch15-02-deref.md","path":"src/ch15-02-deref.md","contentType":"file"},{"name":"ch15-03-drop.md","path":"src/ch15-03-drop.md","contentType":"file"},{"name":"ch15-04-rc.md","path":"src/ch15-04-rc.md","contentType":"file"},{"name":"ch15-05-interior-mutability.md","path":"src/ch15-05-interior-mutability.md","contentType":"file"},{"name":"ch15-06-reference-cycles.md","path":"src/ch15-06-reference-cycles.md","contentType":"file"},{"name":"ch16-00-concurrency.md","path":"src/ch16-00-concurrency.md","contentType":"file"},{"name":"ch16-01-threads.md","path":"src/ch16-01-threads.md","contentType":"file"},{"name":"ch16-02-message-passing.md","path":"src/ch16-02-message-passing.md","contentType":"file"},{"name":"ch16-03-shared-state.md","path":"src/ch16-03-shared-state.md","contentType":"file"},{"name":"ch16-04-extensible-concurrency-sync-and-send.md","path":"src/ch16-04-extensible-concurrency-sync-and-send.md","contentType":"file"},{"name":"ch17-00-oop.md","path":"src/ch17-00-oop.md","contentType":"file"},{"name":"ch17-01-what-is-oo.md","path":"src/ch17-01-what-is-oo.md","contentType":"file"},{"name":"ch17-02-trait-objects.md","path":"src/ch17-02-trait-objects.md","contentType":"file"},{"name":"ch17-03-oo-design-patterns.md","path":"src/ch17-03-oo-design-patterns.md","contentType":"file"},{"name":"ch18-00-patterns.md","path":"src/ch18-00-patterns.md","contentType":"file"},{"name":"ch18-01-all-the-places-for-patterns.md","path":"src/ch18-01-all-the-places-for-patterns.md","contentType":"file"},{"name":"ch18-02-refutability.md","path":"src/ch18-02-refutability.md","contentType":"file"},{"name":"ch18-03-pattern-syntax.md","path":"src/ch18-03-pattern-syntax.md","contentType":"file"},{"name":"ch19-00-advanced-features.md","path":"src/ch19-00-advanced-features.md","contentType":"file"},{"name":"ch19-01-unsafe-rust.md","path":"src/ch19-01-unsafe-rust.md","contentType":"file"},{"name":"ch19-03-advanced-traits.md","path":"src/ch19-03-advanced-traits.md","contentType":"file"},{"name":"ch19-04-advanced-types.md","path":"src/ch19-04-advanced-types.md","contentType":"file"},{"name":"ch19-05-advanced-functions-and-closures.md","path":"src/ch19-05-advanced-functions-and-closures.md","contentType":"file"},{"name":"ch19-06-macros.md","path":"src/ch19-06-macros.md","contentType":"file"},{"name":"ch20-00-final-project-a-web-server.md","path":"src/ch20-00-final-project-a-web-server.md","contentType":"file"},{"name":"ch20-01-single-threaded.md","path":"src/ch20-01-single-threaded.md","contentType":"file"},{"name":"ch20-02-multithreaded.md","path":"src/ch20-02-multithreaded.md","contentType":"file"},{"name":"ch20-03-graceful-shutdown-and-cleanup.md","path":"src/ch20-03-graceful-shutdown-and-cleanup.md","contentType":"file"},{"name":"foreword.md","path":"src/foreword.md","contentType":"file"},{"name":"title-page.md","path":"src/title-page.md","contentType":"file"}],"totalCount":106},"":{"items":[{"name":".cargo","path":".cargo","contentType":"directory"},{"name":".github","path":".github","contentType":"directory"},{"name":"2018-edition","path":"2018-edition","contentType":"directory"},{"name":"ci","path":"ci","contentType":"directory"},{"name":"dot","path":"dot","contentType":"directory"},{"name":"first-edition","path":"first-edition","contentType":"directory"},{"name":"listings","path":"listings","contentType":"directory"},{"name":"nostarch","path":"nostarch","contentType":"directory"},{"name":"redirects","path":"redirects","contentType":"directory"},{"name":"second-edition","path":"second-edition","contentType":"directory"},{"name":"src","path":"src","contentType":"directory"},{"name":"theme","path":"theme","contentType":"directory"},{"name":"tools","path":"tools","contentType":"directory"},{"name":".gitattributes","path":".gitattributes","contentType":"file"},{"name":".gitignore","path":".gitignore","contentType":"file"},{"name":"ADMIN_TASKS.md","path":"ADMIN_TASKS.md","contentType":"file"},{"name":"CONTRIBUTING.md","path":"CONTRIBUTING.md","contentType":"file"},{"name":"COPYRIGHT","path":"COPYRIGHT","contentType":"file"},{"name":"Cargo.lock","path":"Cargo.lock","contentType":"file"},{"name":"Cargo.toml","path":"Cargo.toml","contentType":"file"},{"name":"LICENSE-APACHE","path":"LICENSE-APACHE","contentType":"file"},{"name":"LICENSE-MIT","path":"LICENSE-MIT","contentType":"file"},{"name":"README.md","path":"README.md","contentType":"file"},{"name":"TODO.md","path":"TODO.md","contentType":"file"},{"name":"book.toml","path":"book.toml","contentType":"file"},{"name":"ferris.css","path":"ferris.css","contentType":"file"},{"name":"ferris.js","path":"ferris.js","contentType":"file"},{"name":"rust-toolchain","path":"rust-toolchain","contentType":"file"},{"name":"rustfmt.toml","path":"rustfmt.toml","contentType":"file"},{"name":"style-guide.md","path":"style-guide.md","contentType":"file"}],"totalCount":30}},"fileTreeProcessingTime":13.471468999999999,"foldersToFetch":[],"reducedMotionEnabled":null,"repo":{"id":47854924,"defaultBranch":"main","name":"book","ownerLogin":"rust-lang","currentUserCanPush":false,"isFork":false,"isEmpty":false,"createdAt":"2015-12-11T22:49:49.000Z","ownerAvatar":"https://avatars.githubusercontent.com/u/5430905?v=4","public":true,"private":false,"isOrgOwned":true},"symbolsExpanded":false,"treeExpanded":true,"refInfo":{"name":"main","listCacheKey":"v0:1688046669.0","canEdit":false,"refType":"branch","currentOid":"72187f5cd0beaaa9c6f584156bcd88f921871e83"},"path":"src/ch04-03-slices.md","currentUser":null,"blob":{"rawLines":null,"stylingDirectives":null,"csv":null,"csvError":null,"dependabotInfo":{"showConfigurationBanner":false,"configFilePath":null,"networkDependabotPath":"/rust-lang/book/network/updates","dismissConfigurationNoticePath":"/settings/dismiss-notice/dependabot_configuration_notice","configurationNoticeDismissed":null,"repoAlertsPath":"/rust-lang/book/security/dependabot","repoSecurityAndAnalysisPath":"/rust-lang/book/settings/security_analysis","repoOwnerIsOrg":true,"currentUserCanAdminRepo":false},"displayName":"ch04-03-slices.md","displayUrl":"https://github.com/rust-lang/book/blob/main/src/ch04-03-slices.md?raw=true","headerInfo":{"blobSize":"12.8 KB","deleteInfo":{"deleteTooltip":"You must be signed in to make or propose changes"},"editInfo":{"editTooltip":"You must be signed in to make or propose changes"},"ghDesktopPath":"https://desktop.github.com","gitLfsPath":null,"onBranch":true,"shortPath":"6ffb1dc","siteNavLoginPath":"/login?return_to=https%3A%2F%2Fgithub.com%2Frust-lang%2Fbook%2Fblob%2Fmain%2Fsrc%2Fch04-03-slices.md","isCSV":false,"isRichtext":true,"toc":[{"level":2,"text":"The Slice Type","anchor":"the-slice-type","htmlText":"The Slice Type"},{"level":3,"text":"String Slices","anchor":"string-slices","htmlText":"String Slices"},{"level":4,"text":"String Literals as Slices","anchor":"string-literals-as-slices","htmlText":"String Literals as Slices"},{"level":4,"text":"String Slices as Parameters","anchor":"string-slices-as-parameters","htmlText":"String Slices as Parameters"},{"level":3,"text":"Other Slices","anchor":"other-slices","htmlText":"Other Slices"},{"level":2,"text":"Summary","anchor":"summary","htmlText":"Summary"}],"lineInfo":{"truncatedLoc":"322","truncatedSloc":"238"},"mode":"file"},"image":false,"isCodeownersFile":null,"isPlain":false,"isValidLegacyIssueTemplate":false,"issueTemplateHelpUrl":"https://docs.github.com/articles/about-issue-and-pull-request-templates","issueTemplate":null,"discussionTemplate":null,"language":"Markdown","languageID":222,"large":false,"loggedIn":false,"newDiscussionPath":"/rust-lang/book/discussions/new","newIssuePath":"/rust-lang/book/issues/new","planSupportInfo":{"repoIsFork":null,"repoOwnedByCurrentUser":null,"requestFullPath":"/rust-lang/book/blob/main/src/ch04-03-slices.md","showFreeOrgGatedFeatureMessage":null,"showPlanSupportBanner":null,"upgradeDataAttributes":null,"upgradePath":null},"publishBannersInfo":{"dismissActionNoticePath":"/settings/dismiss-notice/publish_action_from_dockerfile","dismissStackNoticePath":"/settings/dismiss-notice/publish_stack_from_file","releasePath":"/rust-lang/book/releases/new?marketplace=true","showPublishActionBanner":false,"showPublishStackBanner":false},"renderImageOrRaw":false,"richText":"<article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><h2 tabindex=\"-1\" id=\"user-content-the-slice-type\" dir=\"auto\"><a class=\"heading-link\" href=\"#the-slice-type\">The Slice Type<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\"><em>Slices</em> let you reference a contiguous sequence of elements in a collection\nrather than the whole collection. A slice is a kind of reference, so it does\nnot have ownership.</p>\n<p dir=\"auto\">Here’s a small programming problem: write a function that takes a string of\nwords separated by spaces and returns the first word it finds in that string.\nIf the function doesn’t find a space in the string, the whole string must be\none word, so the entire string should be returned.</p>\n<p dir=\"auto\">Let’s work through how we’d write the signature of this function without using\nslices, to understand the problem that slices will solve:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"fn first_word(s: &amp;String) -&gt; ?\"><pre><span class=\"pl-k\">fn</span> first_word<span class=\"pl-kos\">(</span><span class=\"pl-s1\">s</span><span class=\"pl-kos\">:</span> <span class=\"pl-c1\">&amp;</span><span class=\"pl-smi\">String</span><span class=\"pl-kos\">)</span> -&gt; ?</pre></div>\n<p dir=\"auto\">The <code>first_word</code> function has a <code>&amp;String</code> as a parameter. We don’t want\nownership, so this is fine. But what should we return? We don’t really have a\nway to talk about <em>part</em> of a string. However, we could return the index of the\nend of the word, indicated by a space. Let’s try that, as shown in Listing 4-7.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch04-understanding-ownership/listing-<span class=\"pl-c1\">04</span>-<span class=\"pl-c1\">07</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 4-7: The <code>first_word</code> function that returns a\nbyte index value into the <code>String</code> parameter</span></p>\n<p dir=\"auto\">Because we need to go through the <code>String</code> element by element and check whether\na value is a space, we’ll convert our <code>String</code> to an array of bytes using the\n<code>as_bytes</code> method.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:as_bytes}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch04-understanding-ownership/listing-<span class=\"pl-c1\">04</span>-<span class=\"pl-c1\">07</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>as_bytes<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">Next, we create an iterator over the array of bytes using the <code>iter</code> method:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:iter}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch04-understanding-ownership/listing-<span class=\"pl-c1\">04</span>-<span class=\"pl-c1\">07</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>iter<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">We’ll discuss iterators in more detail in <a href=\"/rust-lang/book/blob/main/src/ch13-02-iterators.html\">Chapter 13</a>.\nFor now, know that <code>iter</code> is a method that returns each element in a collection\nand that <code>enumerate</code> wraps the result of <code>iter</code> and returns each element as\npart of a tuple instead. The first element of the tuple returned from\n<code>enumerate</code> is the index, and the second element is a reference to the element.\nThis is a bit more convenient than calculating the index ourselves.</p>\n<p dir=\"auto\">Because the <code>enumerate</code> method returns a tuple, we can use patterns to\ndestructure that tuple. We’ll be discussing patterns more in <a href=\"/rust-lang/book/blob/main/src/ch06-02-match.html#patterns-that-bind-to-values\">Chapter\n6</a>. In the <code>for</code> loop, we specify a pattern that has <code>i</code>\nfor the index in the tuple and <code>&amp;item</code> for the single byte in the tuple.\nBecause we get a reference to the element from <code>.iter().enumerate()</code>, we use\n<code>&amp;</code> in the pattern.</p>\n<p dir=\"auto\">Inside the <code>for</code> loop, we search for the byte that represents the space by\nusing the byte literal syntax. If we find a space, we return the position.\nOtherwise, we return the length of the string by using <code>s.len()</code>.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:inside_for}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch04-understanding-ownership/listing-<span class=\"pl-c1\">04</span>-<span class=\"pl-c1\">07</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>inside_for<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">We now have a way to find out the index of the end of the first word in the\nstring, but there’s a problem. We’re returning a <code>usize</code> on its own, but it’s\nonly a meaningful number in the context of the <code>&amp;String</code>. In other words,\nbecause it’s a separate value from the <code>String</code>, there’s no guarantee that it\nwill still be valid in the future. Consider the program in Listing 4-8 that\nuses the <code>first_word</code> function from Listing 4-7.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-08/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch04-understanding-ownership/listing-<span class=\"pl-c1\">04</span>-<span class=\"pl-c1\">08</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 4-8: Storing the result from calling the\n<code>first_word</code> function and then changing the <code>String</code> contents</span></p>\n<p dir=\"auto\">This program compiles without any errors and would also do so if we used <code>word</code>\nafter calling <code>s.clear()</code>. Because <code>word</code> isn’t connected to the state of <code>s</code>\nat all, <code>word</code> still contains the value <code>5</code>. We could use that value <code>5</code> with\nthe variable <code>s</code> to try to extract the first word out, but this would be a bug\nbecause the contents of <code>s</code> have changed since we saved <code>5</code> in <code>word</code>.</p>\n<p dir=\"auto\">Having to worry about the index in <code>word</code> getting out of sync with the data in\n<code>s</code> is tedious and error prone! Managing these indices is even more brittle if\nwe write a <code>second_word</code> function. Its signature would have to look like this:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"fn second_word(s: &amp;String) -&gt; (usize, usize) {\"><pre><span class=\"pl-k\">fn</span> second_word<span class=\"pl-kos\">(</span><span class=\"pl-s1\">s</span><span class=\"pl-kos\">:</span> <span class=\"pl-c1\">&amp;</span><span class=\"pl-smi\">String</span><span class=\"pl-kos\">)</span> -&gt; <span class=\"pl-kos\">(</span><span class=\"pl-smi\">usize</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">usize</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span></pre></div>\n<p dir=\"auto\">Now we’re tracking a starting <em>and</em> an ending index, and we have even more\nvalues that were calculated from data in a particular state but aren’t tied to\nthat state at all. We have three unrelated variables floating around that need\nto be kept in sync.</p>\n<p dir=\"auto\">Luckily, Rust has a solution to this problem: string slices.</p>\n<h3 tabindex=\"-1\" id=\"user-content-string-slices\" dir=\"auto\"><a class=\"heading-link\" href=\"#string-slices\">String Slices<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">A <em>string slice</em> is a reference to part of a <code>String</code>, and it looks like this:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-17-slice/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-<span class=\"pl-c1\">17</span>-slice/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">Rather than a reference to the entire <code>String</code>, <code>hello</code> is a reference to a\nportion of the <code>String</code>, specified in the extra <code>[0..5]</code> bit. We create slices\nusing a range within brackets by specifying <code>[starting_index..ending_index]</code>,\nwhere <code>starting_index</code> is the first position in the slice and <code>ending_index</code> is\none more than the last position in the slice. Internally, the slice data\nstructure stores the starting position and the length of the slice, which\ncorresponds to <code>ending_index</code> minus <code>starting_index</code>. So, in the case of <code>let world = &amp;s[6..11];</code>, <code>world</code> would be a slice that contains a pointer to the\nbyte at index 6 of <code>s</code> with a length value of <code>5</code>.</p>\n<p dir=\"auto\">Figure 4-6 shows this in a diagram.</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/rust-lang/book/blob/main/src/img/trpl04-06.svg\"><img alt=\"Three tables: a table representing the stack data of s, which points\nto the byte at index 0 in a table of the string data &quot;hello world&quot; on\nthe heap. The third table rep-resents the stack data of the slice world, which\nhas a length value of 5 and points to byte 6 of the heap data table.\" src=\"/rust-lang/book/raw/main/src/img/trpl04-06.svg\" style=\"width: 50%; max-width: 100%;\"></a></p>\n<p dir=\"auto\"><span>Figure 4-6: String slice referring to part of a\n<code>String</code></span></p>\n<p dir=\"auto\">With Rust’s <code>..</code> range syntax, if you want to start at index 0, you can drop\nthe value before the two periods. In other words, these are equal:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"let s = String::from(&quot;hello&quot;);\n\nlet slice = &amp;s[0..2];\nlet slice = &amp;s[..2];\"><pre><span class=\"pl-k\">let</span> s = <span class=\"pl-smi\">String</span><span class=\"pl-kos\">::</span><span class=\"pl-en\">from</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"hello\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">let</span> slice = <span class=\"pl-c1\">&amp;</span>s<span class=\"pl-kos\">[</span><span class=\"pl-c1\">0</span>..<span class=\"pl-c1\">2</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> slice = <span class=\"pl-c1\">&amp;</span>s<span class=\"pl-kos\">[</span>..<span class=\"pl-c1\">2</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">By the same token, if your slice includes the last byte of the <code>String</code>, you\ncan drop the trailing number. That means these are equal:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"let s = String::from(&quot;hello&quot;);\n\nlet len = s.len();\n\nlet slice = &amp;s[3..len];\nlet slice = &amp;s[3..];\"><pre><span class=\"pl-k\">let</span> s = <span class=\"pl-smi\">String</span><span class=\"pl-kos\">::</span><span class=\"pl-en\">from</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"hello\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">let</span> len = s<span class=\"pl-kos\">.</span><span class=\"pl-en\">len</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">let</span> slice = <span class=\"pl-c1\">&amp;</span>s<span class=\"pl-kos\">[</span><span class=\"pl-c1\">3</span>..len<span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> slice = <span class=\"pl-c1\">&amp;</span>s<span class=\"pl-kos\">[</span><span class=\"pl-c1\">3</span>..<span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">You can also drop both values to take a slice of the entire string. So these\nare equal:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"let s = String::from(&quot;hello&quot;);\n\nlet len = s.len();\n\nlet slice = &amp;s[0..len];\nlet slice = &amp;s[..];\"><pre><span class=\"pl-k\">let</span> s = <span class=\"pl-smi\">String</span><span class=\"pl-kos\">::</span><span class=\"pl-en\">from</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"hello\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">let</span> len = s<span class=\"pl-kos\">.</span><span class=\"pl-en\">len</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">let</span> slice = <span class=\"pl-c1\">&amp;</span>s<span class=\"pl-kos\">[</span><span class=\"pl-c1\">0</span>..len<span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> slice = <span class=\"pl-c1\">&amp;</span>s<span class=\"pl-kos\">[</span>..<span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span></pre></div>\n<blockquote>\n<p dir=\"auto\">Note: String slice range indices must occur at valid UTF-8 character\nboundaries. If you attempt to create a string slice in the middle of a\nmultibyte character, your program will exit with an error. For the purposes\nof introducing string slices, we are assuming ASCII only in this section; a\nmore thorough discussion of UTF-8 handling is in the <a href=\"/rust-lang/book/blob/main/src/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings\">“Storing UTF-8 Encoded\nText with Strings”</a> section of Chapter 8.</p>\n</blockquote>\n<p dir=\"auto\">With all this information in mind, let’s rewrite <code>first_word</code> to return a\nslice. The type that signifies “string slice” is written as <code>&amp;str</code>:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-18-first-word-slice/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-<span class=\"pl-c1\">18</span>-first-word-slice/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">We get the index for the end of the word the same way we did in Listing 4-7, by\nlooking for the first occurrence of a space. When we find a space, we return a\nstring slice using the start of the string and the index of the space as the\nstarting and ending indices.</p>\n<p dir=\"auto\">Now when we call <code>first_word</code>, we get back a single value that is tied to the\nunderlying data. The value is made up of a reference to the starting point of\nthe slice and the number of elements in the slice.</p>\n<p dir=\"auto\">Returning a slice would also work for a <code>second_word</code> function:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"fn second_word(s: &amp;String) -&gt; &amp;str {\"><pre><span class=\"pl-k\">fn</span> second_word<span class=\"pl-kos\">(</span><span class=\"pl-s1\">s</span><span class=\"pl-kos\">:</span> <span class=\"pl-c1\">&amp;</span><span class=\"pl-smi\">String</span><span class=\"pl-kos\">)</span> -&gt; <span class=\"pl-c1\">&amp;</span><span class=\"pl-smi\">str</span> <span class=\"pl-kos\">{</span></pre></div>\n<p dir=\"auto\">We now have a straightforward API that’s much harder to mess up because the\ncompiler will ensure the references into the <code>String</code> remain valid. Remember\nthe bug in the program in Listing 4-8, when we got the index to the end of the\nfirst word but then cleared the string so our index was invalid? That code was\nlogically incorrect but didn’t show any immediate errors. The problems would\nshow up later if we kept trying to use the first word index with an emptied\nstring. Slices make this bug impossible and let us know we have a problem with\nour code much sooner. Using the slice version of <code>first_word</code> will throw a\ncompile-time error:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-<span class=\"pl-c1\">19</span>-slice-error/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">Here’s the compiler error:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/output.txt}}</span></pre></div>\n<p dir=\"auto\">Recall from the borrowing rules that if we have an immutable reference to\nsomething, we cannot also take a mutable reference. Because <code>clear</code> needs to\ntruncate the <code>String</code>, it needs to get a mutable reference. The <code>println!</code>\nafter the call to <code>clear</code> uses the reference in <code>word</code>, so the immutable\nreference must still be active at that point. Rust disallows the mutable\nreference in <code>clear</code> and the immutable reference in <code>word</code> from existing at the\nsame time, and compilation fails. Not only has Rust made our API easier to use,\nbut it has also eliminated an entire class of errors at compile time!</p>\n\n<p dir=\"auto\"><a id=\"user-content-string-literals-are-slices\"></a></p>\n<h4 tabindex=\"-1\" id=\"user-content-string-literals-as-slices\" dir=\"auto\"><a class=\"heading-link\" href=\"#string-literals-as-slices\">String Literals as Slices<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">Recall that we talked about string literals being stored inside the binary. Now\nthat we know about slices, we can properly understand string literals:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"let s = &quot;Hello, world!&quot;;\"><pre><span class=\"pl-k\">let</span> s = <span class=\"pl-s\">\"Hello, world!\"</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">The type of <code>s</code> here is <code>&amp;str</code>: it’s a slice pointing to that specific point of\nthe binary. This is also why string literals are immutable; <code>&amp;str</code> is an\nimmutable reference.</p>\n<h4 tabindex=\"-1\" id=\"user-content-string-slices-as-parameters\" dir=\"auto\"><a class=\"heading-link\" href=\"#string-slices-as-parameters\">String Slices as Parameters<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">Knowing that you can take slices of literals and <code>String</code> values leads us to\none more improvement on <code>first_word</code>, and that’s its signature:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"fn first_word(s: &amp;String) -&gt; &amp;str {\"><pre><span class=\"pl-k\">fn</span> first_word<span class=\"pl-kos\">(</span><span class=\"pl-s1\">s</span><span class=\"pl-kos\">:</span> <span class=\"pl-c1\">&amp;</span><span class=\"pl-smi\">String</span><span class=\"pl-kos\">)</span> -&gt; <span class=\"pl-c1\">&amp;</span><span class=\"pl-smi\">str</span> <span class=\"pl-kos\">{</span></pre></div>\n<p dir=\"auto\">A more experienced Rustacean would write the signature shown in Listing 4-9\ninstead because it allows us to use the same function on both <code>&amp;String</code> values\nand <code>&amp;str</code> values.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-09/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch04-understanding-ownership/listing-<span class=\"pl-c1\">04</span>-<span class=\"pl-c1\">09</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 4-9: Improving the <code>first_word</code> function by using\na string slice for the type of the <code>s</code> parameter</span></p>\n<p dir=\"auto\">If we have a string slice, we can pass that directly. If we have a <code>String</code>, we\ncan pass a slice of the <code>String</code> or a reference to the <code>String</code>. This\nflexibility takes advantage of <em>deref coercions</em>, a feature we will cover in\n<a href=\"/rust-lang/book/blob/main/src/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods\">“Implicit Deref Coercions with Functions and\nMethods”</a> section of Chapter 15.</p>\n<p dir=\"auto\">Defining a function to take a string slice instead of a reference to a <code>String</code>\nmakes our API more general and useful without losing any functionality:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-09/src/main.rs:usage}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch04-understanding-ownership/listing-<span class=\"pl-c1\">04</span>-<span class=\"pl-c1\">09</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>usage<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<h3 tabindex=\"-1\" id=\"user-content-other-slices\" dir=\"auto\"><a class=\"heading-link\" href=\"#other-slices\">Other Slices<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">String slices, as you might imagine, are specific to strings. But there’s a\nmore general slice type too. Consider this array:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"let a = [1, 2, 3, 4, 5];\"><pre><span class=\"pl-k\">let</span> a = <span class=\"pl-kos\">[</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">2</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">3</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">4</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">5</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">Just as we might want to refer to part of a string, we might want to refer to\npart of an array. We’d do so like this:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"let a = [1, 2, 3, 4, 5];\n\nlet slice = &amp;a[1..3];\n\nassert_eq!(slice, &amp;[2, 3]);\"><pre><span class=\"pl-k\">let</span> a = <span class=\"pl-kos\">[</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">2</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">3</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">4</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">5</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">let</span> slice = <span class=\"pl-c1\">&amp;</span>a<span class=\"pl-kos\">[</span><span class=\"pl-c1\">1</span>..<span class=\"pl-c1\">3</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-en\">assert_eq</span><span class=\"pl-en\">!</span><span class=\"pl-kos\">(</span>slice, &amp;<span class=\"pl-kos\">[</span><span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">3</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">This slice has the type <code>&amp;[i32]</code>. It works the same way as string slices do, by\nstoring a reference to the first element and a length. You’ll use this kind of\nslice for all sorts of other collections. We’ll discuss these collections in\ndetail when we talk about vectors in Chapter 8.</p>\n<h2 tabindex=\"-1\" id=\"user-content-summary\" dir=\"auto\"><a class=\"heading-link\" href=\"#summary\">Summary<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">The concepts of ownership, borrowing, and slices ensure memory safety in Rust\nprograms at compile time. The Rust language gives you control over your memory\nusage in the same way as other systems programming languages, but having the\nowner of data automatically clean up that data when the owner goes out of scope\nmeans you don’t have to write and debug extra code to get this control.</p>\n<p dir=\"auto\">Ownership affects how lots of other parts of Rust work, so we’ll talk about\nthese concepts further throughout the rest of the book. Let’s move on to\nChapter 5 and look at grouping pieces of data together in a <code>struct</code>.</p>\n</article>","renderedFileInfo":null,"shortPath":null,"tabSize":8,"topBannersInfo":{"overridingGlobalFundingFile":false,"globalPreferredFundingPath":null,"repoOwner":"rust-lang","repoName":"book","showInvalidCitationWarning":false,"citationHelpUrl":"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/about-citation-files","showDependabotConfigurationBanner":false,"actionsOnboardingTip":null},"truncated":false,"viewable":true,"workflowRedirectUrl":null,"symbols":{"timedOut":false,"notAnalyzed":true,"symbols":[]}},"copilotInfo":null,"csrf_tokens":{"/rust-lang/book/branches":{"post":"9vc-pSnsF7o0mwOx9vwZi0ghFhzWIo3JWnYOYxx2nQ9Maf0fziHBY1SblEDd71m_OGvh--2CCQg3YwLm2I4oIQ"},"/repos/preferences":{"post":"jHnWhCEBOKK0RgtQNplydi81WPZfB5PFnKm0WPliLnA_cvg9gLPYZ8mw-ieqqMgVed0h6EI7kdwX9dppV4xEog"}}},"title":"book/src/ch04-03-slices.md at main · rust-lang/book"}
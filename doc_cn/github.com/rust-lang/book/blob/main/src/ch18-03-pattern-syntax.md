{"payload":{"allShortcutsEnabled":false,"fileTree":{"src":{"items":[{"name":"img","path":"src/img","contentType":"directory"},{"name":"SUMMARY.md","path":"src/SUMMARY.md","contentType":"file"},{"name":"appendix-00.md","path":"src/appendix-00.md","contentType":"file"},{"name":"appendix-01-keywords.md","path":"src/appendix-01-keywords.md","contentType":"file"},{"name":"appendix-02-operators.md","path":"src/appendix-02-operators.md","contentType":"file"},{"name":"appendix-03-derivable-traits.md","path":"src/appendix-03-derivable-traits.md","contentType":"file"},{"name":"appendix-04-useful-development-tools.md","path":"src/appendix-04-useful-development-tools.md","contentType":"file"},{"name":"appendix-05-editions.md","path":"src/appendix-05-editions.md","contentType":"file"},{"name":"appendix-06-translation.md","path":"src/appendix-06-translation.md","contentType":"file"},{"name":"appendix-07-nightly-rust.md","path":"src/appendix-07-nightly-rust.md","contentType":"file"},{"name":"ch00-00-introduction.md","path":"src/ch00-00-introduction.md","contentType":"file"},{"name":"ch01-00-getting-started.md","path":"src/ch01-00-getting-started.md","contentType":"file"},{"name":"ch01-01-installation.md","path":"src/ch01-01-installation.md","contentType":"file"},{"name":"ch01-02-hello-world.md","path":"src/ch01-02-hello-world.md","contentType":"file"},{"name":"ch01-03-hello-cargo.md","path":"src/ch01-03-hello-cargo.md","contentType":"file"},{"name":"ch02-00-guessing-game-tutorial.md","path":"src/ch02-00-guessing-game-tutorial.md","contentType":"file"},{"name":"ch03-00-common-programming-concepts.md","path":"src/ch03-00-common-programming-concepts.md","contentType":"file"},{"name":"ch03-01-variables-and-mutability.md","path":"src/ch03-01-variables-and-mutability.md","contentType":"file"},{"name":"ch03-02-data-types.md","path":"src/ch03-02-data-types.md","contentType":"file"},{"name":"ch03-03-how-functions-work.md","path":"src/ch03-03-how-functions-work.md","contentType":"file"},{"name":"ch03-04-comments.md","path":"src/ch03-04-comments.md","contentType":"file"},{"name":"ch03-05-control-flow.md","path":"src/ch03-05-control-flow.md","contentType":"file"},{"name":"ch04-00-understanding-ownership.md","path":"src/ch04-00-understanding-ownership.md","contentType":"file"},{"name":"ch04-01-what-is-ownership.md","path":"src/ch04-01-what-is-ownership.md","contentType":"file"},{"name":"ch04-02-references-and-borrowing.md","path":"src/ch04-02-references-and-borrowing.md","contentType":"file"},{"name":"ch04-03-slices.md","path":"src/ch04-03-slices.md","contentType":"file"},{"name":"ch05-00-structs.md","path":"src/ch05-00-structs.md","contentType":"file"},{"name":"ch05-01-defining-structs.md","path":"src/ch05-01-defining-structs.md","contentType":"file"},{"name":"ch05-02-example-structs.md","path":"src/ch05-02-example-structs.md","contentType":"file"},{"name":"ch05-03-method-syntax.md","path":"src/ch05-03-method-syntax.md","contentType":"file"},{"name":"ch06-00-enums.md","path":"src/ch06-00-enums.md","contentType":"file"},{"name":"ch06-01-defining-an-enum.md","path":"src/ch06-01-defining-an-enum.md","contentType":"file"},{"name":"ch06-02-match.md","path":"src/ch06-02-match.md","contentType":"file"},{"name":"ch06-03-if-let.md","path":"src/ch06-03-if-let.md","contentType":"file"},{"name":"ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","path":"src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","contentType":"file"},{"name":"ch07-01-packages-and-crates.md","path":"src/ch07-01-packages-and-crates.md","contentType":"file"},{"name":"ch07-02-defining-modules-to-control-scope-and-privacy.md","path":"src/ch07-02-defining-modules-to-control-scope-and-privacy.md","contentType":"file"},{"name":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","path":"src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","contentType":"file"},{"name":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","path":"src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","contentType":"file"},{"name":"ch07-05-separating-modules-into-different-files.md","path":"src/ch07-05-separating-modules-into-different-files.md","contentType":"file"},{"name":"ch08-00-common-collections.md","path":"src/ch08-00-common-collections.md","contentType":"file"},{"name":"ch08-01-vectors.md","path":"src/ch08-01-vectors.md","contentType":"file"},{"name":"ch08-02-strings.md","path":"src/ch08-02-strings.md","contentType":"file"},{"name":"ch08-03-hash-maps.md","path":"src/ch08-03-hash-maps.md","contentType":"file"},{"name":"ch09-00-error-handling.md","path":"src/ch09-00-error-handling.md","contentType":"file"},{"name":"ch09-01-unrecoverable-errors-with-panic.md","path":"src/ch09-01-unrecoverable-errors-with-panic.md","contentType":"file"},{"name":"ch09-02-recoverable-errors-with-result.md","path":"src/ch09-02-recoverable-errors-with-result.md","contentType":"file"},{"name":"ch09-03-to-panic-or-not-to-panic.md","path":"src/ch09-03-to-panic-or-not-to-panic.md","contentType":"file"},{"name":"ch10-00-generics.md","path":"src/ch10-00-generics.md","contentType":"file"},{"name":"ch10-01-syntax.md","path":"src/ch10-01-syntax.md","contentType":"file"},{"name":"ch10-02-traits.md","path":"src/ch10-02-traits.md","contentType":"file"},{"name":"ch10-03-lifetime-syntax.md","path":"src/ch10-03-lifetime-syntax.md","contentType":"file"},{"name":"ch11-00-testing.md","path":"src/ch11-00-testing.md","contentType":"file"},{"name":"ch11-01-writing-tests.md","path":"src/ch11-01-writing-tests.md","contentType":"file"},{"name":"ch11-02-running-tests.md","path":"src/ch11-02-running-tests.md","contentType":"file"},{"name":"ch11-03-test-organization.md","path":"src/ch11-03-test-organization.md","contentType":"file"},{"name":"ch12-00-an-io-project.md","path":"src/ch12-00-an-io-project.md","contentType":"file"},{"name":"ch12-01-accepting-command-line-arguments.md","path":"src/ch12-01-accepting-command-line-arguments.md","contentType":"file"},{"name":"ch12-02-reading-a-file.md","path":"src/ch12-02-reading-a-file.md","contentType":"file"},{"name":"ch12-03-improving-error-handling-and-modularity.md","path":"src/ch12-03-improving-error-handling-and-modularity.md","contentType":"file"},{"name":"ch12-04-testing-the-librarys-functionality.md","path":"src/ch12-04-testing-the-librarys-functionality.md","contentType":"file"},{"name":"ch12-05-working-with-environment-variables.md","path":"src/ch12-05-working-with-environment-variables.md","contentType":"file"},{"name":"ch12-06-writing-to-stderr-instead-of-stdout.md","path":"src/ch12-06-writing-to-stderr-instead-of-stdout.md","contentType":"file"},{"name":"ch13-00-functional-features.md","path":"src/ch13-00-functional-features.md","contentType":"file"},{"name":"ch13-01-closures.md","path":"src/ch13-01-closures.md","contentType":"file"},{"name":"ch13-02-iterators.md","path":"src/ch13-02-iterators.md","contentType":"file"},{"name":"ch13-03-improving-our-io-project.md","path":"src/ch13-03-improving-our-io-project.md","contentType":"file"},{"name":"ch13-04-performance.md","path":"src/ch13-04-performance.md","contentType":"file"},{"name":"ch14-00-more-about-cargo.md","path":"src/ch14-00-more-about-cargo.md","contentType":"file"},{"name":"ch14-01-release-profiles.md","path":"src/ch14-01-release-profiles.md","contentType":"file"},{"name":"ch14-02-publishing-to-crates-io.md","path":"src/ch14-02-publishing-to-crates-io.md","contentType":"file"},{"name":"ch14-03-cargo-workspaces.md","path":"src/ch14-03-cargo-workspaces.md","contentType":"file"},{"name":"ch14-04-installing-binaries.md","path":"src/ch14-04-installing-binaries.md","contentType":"file"},{"name":"ch14-05-extending-cargo.md","path":"src/ch14-05-extending-cargo.md","contentType":"file"},{"name":"ch15-00-smart-pointers.md","path":"src/ch15-00-smart-pointers.md","contentType":"file"},{"name":"ch15-01-box.md","path":"src/ch15-01-box.md","contentType":"file"},{"name":"ch15-02-deref.md","path":"src/ch15-02-deref.md","contentType":"file"},{"name":"ch15-03-drop.md","path":"src/ch15-03-drop.md","contentType":"file"},{"name":"ch15-04-rc.md","path":"src/ch15-04-rc.md","contentType":"file"},{"name":"ch15-05-interior-mutability.md","path":"src/ch15-05-interior-mutability.md","contentType":"file"},{"name":"ch15-06-reference-cycles.md","path":"src/ch15-06-reference-cycles.md","contentType":"file"},{"name":"ch16-00-concurrency.md","path":"src/ch16-00-concurrency.md","contentType":"file"},{"name":"ch16-01-threads.md","path":"src/ch16-01-threads.md","contentType":"file"},{"name":"ch16-02-message-passing.md","path":"src/ch16-02-message-passing.md","contentType":"file"},{"name":"ch16-03-shared-state.md","path":"src/ch16-03-shared-state.md","contentType":"file"},{"name":"ch16-04-extensible-concurrency-sync-and-send.md","path":"src/ch16-04-extensible-concurrency-sync-and-send.md","contentType":"file"},{"name":"ch17-00-oop.md","path":"src/ch17-00-oop.md","contentType":"file"},{"name":"ch17-01-what-is-oo.md","path":"src/ch17-01-what-is-oo.md","contentType":"file"},{"name":"ch17-02-trait-objects.md","path":"src/ch17-02-trait-objects.md","contentType":"file"},{"name":"ch17-03-oo-design-patterns.md","path":"src/ch17-03-oo-design-patterns.md","contentType":"file"},{"name":"ch18-00-patterns.md","path":"src/ch18-00-patterns.md","contentType":"file"},{"name":"ch18-01-all-the-places-for-patterns.md","path":"src/ch18-01-all-the-places-for-patterns.md","contentType":"file"},{"name":"ch18-02-refutability.md","path":"src/ch18-02-refutability.md","contentType":"file"},{"name":"ch18-03-pattern-syntax.md","path":"src/ch18-03-pattern-syntax.md","contentType":"file"},{"name":"ch19-00-advanced-features.md","path":"src/ch19-00-advanced-features.md","contentType":"file"},{"name":"ch19-01-unsafe-rust.md","path":"src/ch19-01-unsafe-rust.md","contentType":"file"},{"name":"ch19-03-advanced-traits.md","path":"src/ch19-03-advanced-traits.md","contentType":"file"},{"name":"ch19-04-advanced-types.md","path":"src/ch19-04-advanced-types.md","contentType":"file"},{"name":"ch19-05-advanced-functions-and-closures.md","path":"src/ch19-05-advanced-functions-and-closures.md","contentType":"file"},{"name":"ch19-06-macros.md","path":"src/ch19-06-macros.md","contentType":"file"},{"name":"ch20-00-final-project-a-web-server.md","path":"src/ch20-00-final-project-a-web-server.md","contentType":"file"},{"name":"ch20-01-single-threaded.md","path":"src/ch20-01-single-threaded.md","contentType":"file"},{"name":"ch20-02-multithreaded.md","path":"src/ch20-02-multithreaded.md","contentType":"file"},{"name":"ch20-03-graceful-shutdown-and-cleanup.md","path":"src/ch20-03-graceful-shutdown-and-cleanup.md","contentType":"file"},{"name":"foreword.md","path":"src/foreword.md","contentType":"file"},{"name":"title-page.md","path":"src/title-page.md","contentType":"file"}],"totalCount":106},"":{"items":[{"name":".cargo","path":".cargo","contentType":"directory"},{"name":".github","path":".github","contentType":"directory"},{"name":"2018-edition","path":"2018-edition","contentType":"directory"},{"name":"ci","path":"ci","contentType":"directory"},{"name":"dot","path":"dot","contentType":"directory"},{"name":"first-edition","path":"first-edition","contentType":"directory"},{"name":"listings","path":"listings","contentType":"directory"},{"name":"nostarch","path":"nostarch","contentType":"directory"},{"name":"redirects","path":"redirects","contentType":"directory"},{"name":"second-edition","path":"second-edition","contentType":"directory"},{"name":"src","path":"src","contentType":"directory"},{"name":"theme","path":"theme","contentType":"directory"},{"name":"tools","path":"tools","contentType":"directory"},{"name":".gitattributes","path":".gitattributes","contentType":"file"},{"name":".gitignore","path":".gitignore","contentType":"file"},{"name":"ADMIN_TASKS.md","path":"ADMIN_TASKS.md","contentType":"file"},{"name":"CONTRIBUTING.md","path":"CONTRIBUTING.md","contentType":"file"},{"name":"COPYRIGHT","path":"COPYRIGHT","contentType":"file"},{"name":"Cargo.lock","path":"Cargo.lock","contentType":"file"},{"name":"Cargo.toml","path":"Cargo.toml","contentType":"file"},{"name":"LICENSE-APACHE","path":"LICENSE-APACHE","contentType":"file"},{"name":"LICENSE-MIT","path":"LICENSE-MIT","contentType":"file"},{"name":"README.md","path":"README.md","contentType":"file"},{"name":"TODO.md","path":"TODO.md","contentType":"file"},{"name":"book.toml","path":"book.toml","contentType":"file"},{"name":"ferris.css","path":"ferris.css","contentType":"file"},{"name":"ferris.js","path":"ferris.js","contentType":"file"},{"name":"rust-toolchain","path":"rust-toolchain","contentType":"file"},{"name":"rustfmt.toml","path":"rustfmt.toml","contentType":"file"},{"name":"style-guide.md","path":"style-guide.md","contentType":"file"}],"totalCount":30}},"fileTreeProcessingTime":11.745637,"foldersToFetch":[],"reducedMotionEnabled":null,"repo":{"id":47854924,"defaultBranch":"main","name":"book","ownerLogin":"rust-lang","currentUserCanPush":false,"isFork":false,"isEmpty":false,"createdAt":"2015-12-11T22:49:49.000Z","ownerAvatar":"https://avatars.githubusercontent.com/u/5430905?v=4","public":true,"private":false,"isOrgOwned":true},"symbolsExpanded":false,"treeExpanded":true,"refInfo":{"name":"main","listCacheKey":"v0:1688046669.0","canEdit":false,"refType":"branch","currentOid":"72187f5cd0beaaa9c6f584156bcd88f921871e83"},"path":"src/ch18-03-pattern-syntax.md","currentUser":null,"blob":{"rawLines":null,"stylingDirectives":null,"csv":null,"csvError":null,"dependabotInfo":{"showConfigurationBanner":false,"configFilePath":null,"networkDependabotPath":"/rust-lang/book/network/updates","dismissConfigurationNoticePath":"/settings/dismiss-notice/dependabot_configuration_notice","configurationNoticeDismissed":null,"repoAlertsPath":"/rust-lang/book/security/dependabot","repoSecurityAndAnalysisPath":"/rust-lang/book/settings/security_analysis","repoOwnerIsOrg":true,"currentUserCanAdminRepo":false},"displayName":"ch18-03-pattern-syntax.md","displayUrl":"https://github.com/rust-lang/book/blob/main/src/ch18-03-pattern-syntax.md?raw=true","headerInfo":{"blobSize":"26.2 KB","deleteInfo":{"deleteTooltip":"You must be signed in to make or propose changes"},"editInfo":{"editTooltip":"You must be signed in to make or propose changes"},"ghDesktopPath":"https://desktop.github.com","gitLfsPath":null,"onBranch":true,"shortPath":"aeaa766","siteNavLoginPath":"/login?return_to=https%3A%2F%2Fgithub.com%2Frust-lang%2Fbook%2Fblob%2Fmain%2Fsrc%2Fch18-03-pattern-syntax.md","isCSV":false,"isRichtext":true,"toc":[{"level":2,"text":"Pattern Syntax","anchor":"pattern-syntax","htmlText":"Pattern Syntax"},{"level":3,"text":"Matching Literals","anchor":"matching-literals","htmlText":"Matching Literals"},{"level":3,"text":"Matching Named Variables","anchor":"matching-named-variables","htmlText":"Matching Named Variables"},{"level":3,"text":"Multiple Patterns","anchor":"multiple-patterns","htmlText":"Multiple Patterns"},{"level":3,"text":"Matching Ranges of Values with ..=","anchor":"matching-ranges-of-values-with-","htmlText":"Matching Ranges of Values with ..="},{"level":3,"text":"Destructuring to Break Apart Values","anchor":"destructuring-to-break-apart-values","htmlText":"Destructuring to Break Apart Values"},{"level":4,"text":"Destructuring Structs","anchor":"destructuring-structs","htmlText":"Destructuring Structs"},{"level":4,"text":"Destructuring Enums","anchor":"destructuring-enums","htmlText":"Destructuring Enums"},{"level":4,"text":"Destructuring Nested Structs and Enums","anchor":"destructuring-nested-structs-and-enums","htmlText":"Destructuring Nested Structs and Enums"},{"level":4,"text":"Destructuring Structs and Tuples","anchor":"destructuring-structs-and-tuples","htmlText":"Destructuring Structs and Tuples"},{"level":3,"text":"Ignoring Values in a Pattern","anchor":"ignoring-values-in-a-pattern","htmlText":"Ignoring Values in a Pattern"},{"level":4,"text":"Ignoring an Entire Value with _","anchor":"ignoring-an-entire-value-with-_","htmlText":"Ignoring an Entire Value with _"},{"level":4,"text":"Ignoring Parts of a Value with a Nested _","anchor":"ignoring-parts-of-a-value-with-a-nested-_","htmlText":"Ignoring Parts of a Value with a Nested _"},{"level":4,"text":"Ignoring an Unused Variable by Starting Its Name with _","anchor":"ignoring-an-unused-variable-by-starting-its-name-with-_","htmlText":"Ignoring an Unused Variable by Starting Its Name with _"},{"level":4,"text":"Ignoring Remaining Parts of a Value with ..","anchor":"ignoring-remaining-parts-of-a-value-with-","htmlText":"Ignoring Remaining Parts of a Value with .."},{"level":3,"text":"Extra Conditionals with Match Guards","anchor":"extra-conditionals-with-match-guards","htmlText":"Extra Conditionals with Match Guards"},{"level":3,"text":"@ Bindings","anchor":"-bindings","htmlText":"@ Bindings"},{"level":2,"text":"Summary","anchor":"summary","htmlText":"Summary"}],"lineInfo":{"truncatedLoc":"594","truncatedSloc":"445"},"mode":"file"},"image":false,"isCodeownersFile":null,"isPlain":false,"isValidLegacyIssueTemplate":false,"issueTemplateHelpUrl":"https://docs.github.com/articles/about-issue-and-pull-request-templates","issueTemplate":null,"discussionTemplate":null,"language":"Markdown","languageID":222,"large":false,"loggedIn":false,"newDiscussionPath":"/rust-lang/book/discussions/new","newIssuePath":"/rust-lang/book/issues/new","planSupportInfo":{"repoIsFork":null,"repoOwnedByCurrentUser":null,"requestFullPath":"/rust-lang/book/blob/main/src/ch18-03-pattern-syntax.md","showFreeOrgGatedFeatureMessage":null,"showPlanSupportBanner":null,"upgradeDataAttributes":null,"upgradePath":null},"publishBannersInfo":{"dismissActionNoticePath":"/settings/dismiss-notice/publish_action_from_dockerfile","dismissStackNoticePath":"/settings/dismiss-notice/publish_stack_from_file","releasePath":"/rust-lang/book/releases/new?marketplace=true","showPublishActionBanner":false,"showPublishStackBanner":false},"renderImageOrRaw":false,"richText":"<article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><h2 tabindex=\"-1\" id=\"user-content-pattern-syntax\" dir=\"auto\"><a class=\"heading-link\" href=\"#pattern-syntax\">Pattern Syntax<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">In this section, we gather all the syntax valid in patterns and discuss why and\nwhen you might want to use each one.</p>\n<h3 tabindex=\"-1\" id=\"user-content-matching-literals\" dir=\"auto\"><a class=\"heading-link\" href=\"#matching-literals\">Matching Literals<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">As you saw in Chapter 6, you can match patterns against literals directly. The\nfollowing code gives some examples:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-01-literals/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-<span class=\"pl-c1\">01</span>-literals/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">This code prints <code>one</code> because the value in <code>x</code> is 1. This syntax is useful\nwhen you want your code to take an action if it gets a particular concrete\nvalue.</p>\n<h3 tabindex=\"-1\" id=\"user-content-matching-named-variables\" dir=\"auto\"><a class=\"heading-link\" href=\"#matching-named-variables\">Matching Named Variables<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">Named variables are irrefutable patterns that match any value, and we’ve used\nthem many times in the book. However, there is a complication when you use\nnamed variables in <code>match</code> expressions. Because <code>match</code> starts a new scope,\nvariables declared as part of a pattern inside the <code>match</code> expression will\nshadow those with the same name outside the <code>match</code> construct, as is the case\nwith all variables. In Listing 18-11, we declare a variable named <code>x</code> with the\nvalue <code>Some(5)</code> and a variable <code>y</code> with the value <code>10</code>. We then create a\n<code>match</code> expression on the value <code>x</code>. Look at the patterns in the match arms and\n<code>println!</code> at the end, and try to figure out what the code will print before\nrunning this code or reading further.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-11/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">11</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-11: A <code>match</code> expression with an arm that\nintroduces a shadowed variable <code>y</code></span></p>\n<p dir=\"auto\">Let’s walk through what happens when the <code>match</code> expression runs. The pattern\nin the first match arm doesn’t match the defined value of <code>x</code>, so the code\ncontinues.</p>\n<p dir=\"auto\">The pattern in the second match arm introduces a new variable named <code>y</code> that\nwill match any value inside a <code>Some</code> value. Because we’re in a new scope inside\nthe <code>match</code> expression, this is a new <code>y</code> variable, not the <code>y</code> we declared at\nthe beginning with the value 10. This new <code>y</code> binding will match any value\ninside a <code>Some</code>, which is what we have in <code>x</code>. Therefore, this new <code>y</code> binds to\nthe inner value of the <code>Some</code> in <code>x</code>. That value is <code>5</code>, so the expression for\nthat arm executes and prints <code>Matched, y = 5</code>.</p>\n<p dir=\"auto\">If <code>x</code> had been a <code>None</code> value instead of <code>Some(5)</code>, the patterns in the first\ntwo arms wouldn’t have matched, so the value would have matched to the\nunderscore. We didn’t introduce the <code>x</code> variable in the pattern of the\nunderscore arm, so the <code>x</code> in the expression is still the outer <code>x</code> that hasn’t\nbeen shadowed. In this hypothetical case, the <code>match</code> would print <code>Default case, x = None</code>.</p>\n<p dir=\"auto\">When the <code>match</code> expression is done, its scope ends, and so does the scope of\nthe inner <code>y</code>. The last <code>println!</code> produces <code>at the end: x = Some(5), y = 10</code>.</p>\n<p dir=\"auto\">To create a <code>match</code> expression that compares the values of the outer <code>x</code> and\n<code>y</code>, rather than introducing a shadowed variable, we would need to use a match\nguard conditional instead. We’ll talk about match guards later in the <a href=\"#extra-conditionals-with-match-guards\">“Extra\nConditionals with Match Guards”</a> section.</p>\n<h3 tabindex=\"-1\" id=\"user-content-multiple-patterns\" dir=\"auto\"><a class=\"heading-link\" href=\"#multiple-patterns\">Multiple Patterns<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">In <code>match</code> expressions, you can match multiple patterns using the <code>|</code> syntax,\nwhich is the pattern <em>or</em> operator. For example, in the following code we match\nthe value of <code>x</code> against the match arms, the first of which has an <em>or</em> option,\nmeaning if the value of <code>x</code> matches either of the values in that arm, that\narm’s code will run:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-02-multiple-patterns/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-<span class=\"pl-c1\">02</span>-multiple-patterns/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">This code prints <code>one or two</code>.</p>\n<h3 tabindex=\"-1\" id=\"user-content-matching-ranges-of-values-with-\" dir=\"auto\"><a class=\"heading-link\" href=\"#matching-ranges-of-values-with-\">Matching Ranges of Values with <code>..=</code><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">The <code>..=</code> syntax allows us to match to an inclusive range of values. In the\nfollowing code, when a pattern matches any of the values within the given\nrange, that arm will execute:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-03-ranges/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-<span class=\"pl-c1\">03</span>-ranges/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">If <code>x</code> is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more\nconvenient for multiple match values than using the <code>|</code> operator to express the\nsame idea; if we were to use <code>|</code> we would have to specify <code>1 | 2 | 3 | 4 | 5</code>.\nSpecifying a range is much shorter, especially if we want to match, say, any\nnumber between 1 and 1,000!</p>\n<p dir=\"auto\">The compiler checks that the range isn’t empty at compile time, and because the\nonly types for which Rust can tell if a range is empty or not are <code>char</code> and\nnumeric values, ranges are only allowed with numeric or <code>char</code> values.</p>\n<p dir=\"auto\">Here is an example using ranges of <code>char</code> values:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-04-ranges-of-char/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-<span class=\"pl-c1\">04</span>-ranges-of-char/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">Rust can tell that <code>'c'</code> is within the first pattern’s range and prints <code>early ASCII letter</code>.</p>\n<h3 tabindex=\"-1\" id=\"user-content-destructuring-to-break-apart-values\" dir=\"auto\"><a class=\"heading-link\" href=\"#destructuring-to-break-apart-values\">Destructuring to Break Apart Values<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">We can also use patterns to destructure structs, enums, and tuples to use\ndifferent parts of these values. Let’s walk through each value.</p>\n<h4 tabindex=\"-1\" id=\"user-content-destructuring-structs\" dir=\"auto\"><a class=\"heading-link\" href=\"#destructuring-structs\">Destructuring Structs<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">Listing 18-12 shows a <code>Point</code> struct with two fields, <code>x</code> and <code>y</code>, that we can\nbreak apart using a pattern with a <code>let</code> statement.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-12/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">12</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-12: Destructuring a struct’s fields into\nseparate variables</span></p>\n<p dir=\"auto\">This code creates the variables <code>a</code> and <code>b</code> that match the values of the <code>x</code>\nand <code>y</code> fields of the <code>p</code> struct. This example shows that the names of the\nvariables in the pattern don’t have to match the field names of the struct.\nHowever, it’s common to match the variable names to the field names to make it\neasier to remember which variables came from which fields. Because of this\ncommon usage, and because writing <code>let Point { x: x, y: y } = p;</code> contains a\nlot of duplication, Rust has a shorthand for patterns that match struct fields:\nyou only need to list the name of the struct field, and the variables created\nfrom the pattern will have the same names. Listing 18-13 behaves in the same\nway as the code in Listing 18-12, but the variables created in the <code>let</code>\npattern are <code>x</code> and <code>y</code> instead of <code>a</code> and <code>b</code>.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-13/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">13</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-13: Destructuring struct fields using struct\nfield shorthand</span></p>\n<p dir=\"auto\">This code creates the variables <code>x</code> and <code>y</code> that match the <code>x</code> and <code>y</code> fields\nof the <code>p</code> variable. The outcome is that the variables <code>x</code> and <code>y</code> contain the\nvalues from the <code>p</code> struct.</p>\n<p dir=\"auto\">We can also destructure with literal values as part of the struct pattern\nrather than creating variables for all the fields. Doing so allows us to test\nsome of the fields for particular values while creating variables to\ndestructure the other fields.</p>\n<p dir=\"auto\">In Listing 18-14, we have a <code>match</code> expression that separates <code>Point</code> values\ninto three cases: points that lie directly on the <code>x</code> axis (which is true when\n<code>y = 0</code>), on the <code>y</code> axis (<code>x = 0</code>), or neither.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-14/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">14</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-14: Destructuring and matching literal values\nin one pattern</span></p>\n<p dir=\"auto\">The first arm will match any point that lies on the <code>x</code> axis by specifying that\nthe <code>y</code> field matches if its value matches the literal <code>0</code>. The pattern still\ncreates an <code>x</code> variable that we can use in the code for this arm.</p>\n<p dir=\"auto\">Similarly, the second arm matches any point on the <code>y</code> axis by specifying that\nthe <code>x</code> field matches if its value is <code>0</code> and creates a variable <code>y</code> for the\nvalue of the <code>y</code> field. The third arm doesn’t specify any literals, so it\nmatches any other <code>Point</code> and creates variables for both the <code>x</code> and <code>y</code> fields.</p>\n<p dir=\"auto\">In this example, the value <code>p</code> matches the second arm by virtue of <code>x</code>\ncontaining a 0, so this code will print <code>On the y axis at 7</code>.</p>\n<p dir=\"auto\">Remember that a <code>match</code> expression stops checking arms once it has found the\nfirst matching pattern, so even though <code>Point { x: 0, y: 0}</code> is on the <code>x</code> axis\nand the <code>y</code> axis, this code would only print <code>On the x axis at 0</code>.</p>\n<h4 tabindex=\"-1\" id=\"user-content-destructuring-enums\" dir=\"auto\"><a class=\"heading-link\" href=\"#destructuring-enums\">Destructuring Enums<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">We've destructured enums in this book (for example, Listing 6-5 in Chapter 6),\nbut haven’t yet explicitly discussed that the pattern to destructure an enum\ncorresponds to the way the data stored within the enum is defined. As an\nexample, in Listing 18-15 we use the <code>Message</code> enum from Listing 6-2 and write\na <code>match</code> with patterns that will destructure each inner value.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-15/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">15</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-15: Destructuring enum variants that hold\ndifferent kinds of values</span></p>\n<p dir=\"auto\">This code will print <code>Change the color to red 0, green 160, and blue 255</code>. Try\nchanging the value of <code>msg</code> to see the code from the other arms run.</p>\n<p dir=\"auto\">For enum variants without any data, like <code>Message::Quit</code>, we can’t destructure\nthe value any further. We can only match on the literal <code>Message::Quit</code> value,\nand no variables are in that pattern.</p>\n<p dir=\"auto\">For struct-like enum variants, such as <code>Message::Move</code>, we can use a pattern\nsimilar to the pattern we specify to match structs. After the variant name, we\nplace curly brackets and then list the fields with variables so we break apart\nthe pieces to use in the code for this arm. Here we use the shorthand form as\nwe did in Listing 18-13.</p>\n<p dir=\"auto\">For tuple-like enum variants, like <code>Message::Write</code> that holds a tuple with one\nelement and <code>Message::ChangeColor</code> that holds a tuple with three elements, the\npattern is similar to the pattern we specify to match tuples. The number of\nvariables in the pattern must match the number of elements in the variant we’re\nmatching.</p>\n<h4 tabindex=\"-1\" id=\"user-content-destructuring-nested-structs-and-enums\" dir=\"auto\"><a class=\"heading-link\" href=\"#destructuring-nested-structs-and-enums\">Destructuring Nested Structs and Enums<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">So far, our examples have all been matching structs or enums one level deep,\nbut matching can work on nested items too! For example, we can refactor the\ncode in Listing 18-15 to support RGB and HSV colors in the <code>ChangeColor</code>\nmessage, as shown in Listing 18-16.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-16/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">16</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-16: Matching on nested enums</span></p>\n<p dir=\"auto\">The pattern of the first arm in the <code>match</code> expression matches a\n<code>Message::ChangeColor</code> enum variant that contains a <code>Color::Rgb</code> variant; then\nthe pattern binds to the three inner <code>i32</code> values. The pattern of the second\narm also matches a <code>Message::ChangeColor</code> enum variant, but the inner enum\nmatches <code>Color::Hsv</code> instead. We can specify these complex conditions in one\n<code>match</code> expression, even though two enums are involved.</p>\n<h4 tabindex=\"-1\" id=\"user-content-destructuring-structs-and-tuples\" dir=\"auto\"><a class=\"heading-link\" href=\"#destructuring-structs-and-tuples\">Destructuring Structs and Tuples<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">We can mix, match, and nest destructuring patterns in even more complex ways.\nThe following example shows a complicated destructure where we nest structs and\ntuples inside a tuple and destructure all the primitive values out:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-05-destructuring-structs-and-tuples/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-<span class=\"pl-c1\">05</span>-destructuring-structs-and-tuples/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">This code lets us break complex types into their component parts so we can use\nthe values we’re interested in separately.</p>\n<p dir=\"auto\">Destructuring with patterns is a convenient way to use pieces of values, such\nas the value from each field in a struct, separately from each other.</p>\n<h3 tabindex=\"-1\" id=\"user-content-ignoring-values-in-a-pattern\" dir=\"auto\"><a class=\"heading-link\" href=\"#ignoring-values-in-a-pattern\">Ignoring Values in a Pattern<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">You’ve seen that it’s sometimes useful to ignore values in a pattern, such as\nin the last arm of a <code>match</code>, to get a catchall that doesn’t actually do\nanything but does account for all remaining possible values. There are a few\nways to ignore entire values or parts of values in a pattern: using the <code>_</code>\npattern (which you’ve seen), using the <code>_</code> pattern within another pattern,\nusing a name that starts with an underscore, or using <code>..</code> to ignore remaining\nparts of a value. Let’s explore how and why to use each of these patterns.</p>\n<h4 tabindex=\"-1\" id=\"user-content-ignoring-an-entire-value-with-_\" dir=\"auto\"><a class=\"heading-link\" href=\"#ignoring-an-entire-value-with-_\">Ignoring an Entire Value with <code>_</code><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">We’ve used the underscore as a wildcard pattern that will match any value but\nnot bind to the value. This is especially useful as the last arm in a <code>match</code>\nexpression, but we can also use it in any pattern, including function\nparameters, as shown in Listing 18-17.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-17/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">17</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-17: Using <code>_</code> in a function signature</span></p>\n<p dir=\"auto\">This code will completely ignore the value <code>3</code> passed as the first argument,\nand will print <code>This code only uses the y parameter: 4</code>.</p>\n<p dir=\"auto\">In most cases when you no longer need a particular function parameter, you\nwould change the signature so it doesn’t include the unused parameter. Ignoring\na function parameter can be especially useful in cases when, for example,\nyou're implementing a trait when you need a certain type signature but the\nfunction body in your implementation doesn’t need one of the parameters. You\nthen avoid getting a compiler warning about unused function parameters, as you\nwould if you used a name instead.</p>\n<h4 tabindex=\"-1\" id=\"user-content-ignoring-parts-of-a-value-with-a-nested-_\" dir=\"auto\"><a class=\"heading-link\" href=\"#ignoring-parts-of-a-value-with-a-nested-_\">Ignoring Parts of a Value with a Nested <code>_</code><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">We can also use <code>_</code> inside another pattern to ignore just part of a value, for\nexample, when we want to test for only part of a value but have no use for the\nother parts in the corresponding code we want to run. Listing 18-18 shows code\nresponsible for managing a setting’s value. The business requirements are that\nthe user should not be allowed to overwrite an existing customization of a\nsetting but can unset the setting and give it a value if it is currently unset.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-18/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">18</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-18: Using an underscore within patterns that\nmatch <code>Some</code> variants when we don’t need to use the value inside the\n<code>Some</code></span></p>\n<p dir=\"auto\">This code will print <code>Can't overwrite an existing customized value</code> and then\n<code>setting is Some(5)</code>. In the first match arm, we don’t need to match on or use\nthe values inside either <code>Some</code> variant, but we do need to test for the case\nwhen <code>setting_value</code> and <code>new_setting_value</code> are the <code>Some</code> variant. In that\ncase, we print the reason for not changing <code>setting_value</code>, and it doesn’t get\nchanged.</p>\n<p dir=\"auto\">In all other cases (if either <code>setting_value</code> or <code>new_setting_value</code> are\n<code>None</code>) expressed by the <code>_</code> pattern in the second arm, we want to allow\n<code>new_setting_value</code> to become <code>setting_value</code>.</p>\n<p dir=\"auto\">We can also use underscores in multiple places within one pattern to ignore\nparticular values. Listing 18-19 shows an example of ignoring the second and\nfourth values in a tuple of five items.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-19/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">19</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-19: Ignoring multiple parts of a tuple</span></p>\n<p dir=\"auto\">This code will print <code>Some numbers: 2, 8, 32</code>, and the values 4 and 16 will be\nignored.</p>\n<h4 tabindex=\"-1\" id=\"user-content-ignoring-an-unused-variable-by-starting-its-name-with-_\" dir=\"auto\"><a class=\"heading-link\" href=\"#ignoring-an-unused-variable-by-starting-its-name-with-_\">Ignoring an Unused Variable by Starting Its Name with <code>_</code><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">If you create a variable but don’t use it anywhere, Rust will usually issue a\nwarning because an unused variable could be a bug. However, sometimes it’s\nuseful to be able to create a variable you won’t use yet, such as when you’re\nprototyping or just starting a project. In this situation, you can tell Rust\nnot to warn you about the unused variable by starting the name of the variable\nwith an underscore. In Listing 18-20, we create two unused variables, but when\nwe compile this code, we should only get a warning about one of them.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-20/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">20</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-20: Starting a variable name with an\nunderscore to avoid getting unused variable warnings</span></p>\n<p dir=\"auto\">Here we get a warning about not using the variable <code>y</code>, but we don’t get a\nwarning about not using <code>_x</code>.</p>\n<p dir=\"auto\">Note that there is a subtle difference between using only <code>_</code> and using a name\nthat starts with an underscore. The syntax <code>_x</code> still binds the value to the\nvariable, whereas <code>_</code> doesn’t bind at all. To show a case where this\ndistinction matters, Listing 18-21 will provide us with an error.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-21/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">21</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-21: An unused variable starting with an\nunderscore still binds the value, which might take ownership of the value</span></p>\n<p dir=\"auto\">We’ll receive an error because the <code>s</code> value will still be moved into <code>_s</code>,\nwhich prevents us from using <code>s</code> again. However, using the underscore by itself\ndoesn’t ever bind to the value. Listing 18-22 will compile without any errors\nbecause <code>s</code> doesn’t get moved into <code>_</code>.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-22/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">22</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-22: Using an underscore does not bind the\nvalue</span></p>\n<p dir=\"auto\">This code works just fine because we never bind <code>s</code> to anything; it isn’t moved.</p>\n<h4 tabindex=\"-1\" id=\"user-content-ignoring-remaining-parts-of-a-value-with-\" dir=\"auto\"><a class=\"heading-link\" href=\"#ignoring-remaining-parts-of-a-value-with-\">Ignoring Remaining Parts of a Value with <code>..</code><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">With values that have many parts, we can use the <code>..</code> syntax to use specific\nparts and ignore the rest, avoiding the need to list underscores for each\nignored value. The <code>..</code> pattern ignores any parts of a value that we haven’t\nexplicitly matched in the rest of the pattern. In Listing 18-23, we have a\n<code>Point</code> struct that holds a coordinate in three-dimensional space. In the\n<code>match</code> expression, we want to operate only on the <code>x</code> coordinate and ignore\nthe values in the <code>y</code> and <code>z</code> fields.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-23/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">23</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-23: Ignoring all fields of a <code>Point</code> except\nfor <code>x</code> by using <code>..</code></span></p>\n<p dir=\"auto\">We list the <code>x</code> value and then just include the <code>..</code> pattern. This is quicker\nthan having to list <code>y: _</code> and <code>z: _</code>, particularly when we’re working with\nstructs that have lots of fields in situations where only one or two fields are\nrelevant.</p>\n<p dir=\"auto\">The syntax <code>..</code> will expand to as many values as it needs to be. Listing 18-24\nshows how to use <code>..</code> with a tuple.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-24/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">24</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-24: Matching only the first and last values in\na tuple and ignoring all other values</span></p>\n<p dir=\"auto\">In this code, the first and last value are matched with <code>first</code> and <code>last</code>. The\n<code>..</code> will match and ignore everything in the middle.</p>\n<p dir=\"auto\">However, using <code>..</code> must be unambiguous. If it is unclear which values are\nintended for matching and which should be ignored, Rust will give us an error.\nListing 18-25 shows an example of using <code>..</code> ambiguously, so it will not\ncompile.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-25/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">25</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-25: An attempt to use <code>..</code> in an ambiguous\nway</span></p>\n<p dir=\"auto\">When we compile this example, we get this error:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch18-patterns-and-matching/listing-18-25/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch18-patterns-and-matching/listing-18-25/output.txt}}</span></pre></div>\n<p dir=\"auto\">It’s impossible for Rust to determine how many values in the tuple to ignore\nbefore matching a value with <code>second</code> and then how many further values to\nignore thereafter. This code could mean that we want to ignore <code>2</code>, bind\n<code>second</code> to <code>4</code>, and then ignore <code>8</code>, <code>16</code>, and <code>32</code>; or that we want to ignore\n<code>2</code> and <code>4</code>, bind <code>second</code> to <code>8</code>, and then ignore <code>16</code> and <code>32</code>; and so forth.\nThe variable name <code>second</code> doesn’t mean anything special to Rust, so we get a\ncompiler error because using <code>..</code> in two places like this is ambiguous.</p>\n<h3 tabindex=\"-1\" id=\"user-content-extra-conditionals-with-match-guards\" dir=\"auto\"><a class=\"heading-link\" href=\"#extra-conditionals-with-match-guards\">Extra Conditionals with Match Guards<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">A <em>match guard</em> is an additional <code>if</code> condition, specified after the pattern in\na <code>match</code> arm, that must also match for that arm to be chosen. Match guards are\nuseful for expressing more complex ideas than a pattern alone allows.</p>\n<p dir=\"auto\">The condition can use variables created in the pattern. Listing 18-26 shows a\n<code>match</code> where the first arm has the pattern <code>Some(x)</code> and also has a match\nguard of <code>if x % 2 == 0</code> (which will be true if the number is even).</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-26/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">26</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-26: Adding a match guard to a pattern</span></p>\n<p dir=\"auto\">This example will print <code>The number 4 is even</code>. When <code>num</code> is compared to the\npattern in the first arm, it matches, because <code>Some(4)</code> matches <code>Some(x)</code>. Then\nthe match guard checks whether the remainder of dividing <code>x</code> by 2 is equal to\n0, and because it is, the first arm is selected.</p>\n<p dir=\"auto\">If <code>num</code> had been <code>Some(5)</code> instead, the match guard in the first arm would\nhave been false because the remainder of 5 divided by 2 is 1, which is not\nequal to 0. Rust would then go to the second arm, which would match because the\nsecond arm doesn’t have a match guard and therefore matches any <code>Some</code> variant.</p>\n<p dir=\"auto\">There is no way to express the <code>if x % 2 == 0</code> condition within a pattern, so\nthe match guard gives us the ability to express this logic. The downside of\nthis additional expressiveness is that the compiler doesn't try to check for\nexhaustiveness when match guard expressions are involved.</p>\n<p dir=\"auto\">In Listing 18-11, we mentioned that we could use match guards to solve our\npattern-shadowing problem. Recall that we created a new variable inside the\npattern in the <code>match</code> expression instead of using the variable outside the\n<code>match</code>. That new variable meant we couldn’t test against the value of the\nouter variable. Listing 18-27 shows how we can use a match guard to fix this\nproblem.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-27/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">27</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-27: Using a match guard to test for equality\nwith an outer variable</span></p>\n<p dir=\"auto\">This code will now print <code>Default case, x = Some(5)</code>. The pattern in the second\nmatch arm doesn’t introduce a new variable <code>y</code> that would shadow the outer <code>y</code>,\nmeaning we can use the outer <code>y</code> in the match guard. Instead of specifying the\npattern as <code>Some(y)</code>, which would have shadowed the outer <code>y</code>, we specify\n<code>Some(n)</code>. This creates a new variable <code>n</code> that doesn’t shadow anything because\nthere is no <code>n</code> variable outside the <code>match</code>.</p>\n<p dir=\"auto\">The match guard <code>if n == y</code> is not a pattern and therefore doesn’t introduce\nnew variables. This <code>y</code> <em>is</em> the outer <code>y</code> rather than a new shadowed <code>y</code>, and\nwe can look for a value that has the same value as the outer <code>y</code> by comparing\n<code>n</code> to <code>y</code>.</p>\n<p dir=\"auto\">You can also use the <em>or</em> operator <code>|</code> in a match guard to specify multiple\npatterns; the match guard condition will apply to all the patterns. Listing\n18-28 shows the precedence when combining a pattern that uses <code>|</code> with a match\nguard. The important part of this example is that the <code>if y</code> match guard\napplies to <code>4</code>, <code>5</code>, <em>and</em> <code>6</code>, even though it might look like <code>if y</code> only\napplies to <code>6</code>.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-28/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">28</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-28: Combining multiple patterns with a match\nguard</span></p>\n<p dir=\"auto\">The match condition states that the arm only matches if the value of <code>x</code> is\nequal to <code>4</code>, <code>5</code>, or <code>6</code> <em>and</em> if <code>y</code> is <code>true</code>. When this code runs, the\npattern of the first arm matches because <code>x</code> is <code>4</code>, but the match guard <code>if y</code>\nis false, so the first arm is not chosen. The code moves on to the second arm,\nwhich does match, and this program prints <code>no</code>. The reason is that the <code>if</code>\ncondition applies to the whole pattern <code>4 | 5 | 6</code>, not only to the last value\n<code>6</code>. In other words, the precedence of a match guard in relation to a pattern\nbehaves like this:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"(4 | 5 | 6) if y =&gt; ...\"><pre lang=\"text\" class=\"notranslate\"><code>(4 | 5 | 6) if y =&gt; ...\n</code></pre></div>\n<p dir=\"auto\">rather than this:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"4 | 5 | (6 if y) =&gt; ...\"><pre lang=\"text\" class=\"notranslate\"><code>4 | 5 | (6 if y) =&gt; ...\n</code></pre></div>\n<p dir=\"auto\">After running the code, the precedence behavior is evident: if the match guard\nwere applied only to the final value in the list of values specified using the\n<code>|</code> operator, the arm would have matched and the program would have printed\n<code>yes</code>.</p>\n<h3 tabindex=\"-1\" id=\"user-content--bindings\" dir=\"auto\"><a class=\"heading-link\" href=\"#-bindings\"><code>@</code> Bindings<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">The <em>at</em> operator <code>@</code> lets us create a variable that holds a value at the same\ntime as we’re testing that value for a pattern match. In Listing 18-29, we want\nto test that a <code>Message::Hello</code> <code>id</code> field is within the range <code>3..=7</code>. We also\nwant to bind the value to the variable <code>id_variable</code> so we can use it in the\ncode associated with the arm. We could name this variable <code>id</code>, the same as the\nfield, but for this example we’ll use a different name.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-29/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch18-patterns-and-matching/listing-<span class=\"pl-c1\">18</span>-<span class=\"pl-c1\">29</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 18-29: Using <code>@</code> to bind to a value in a pattern\nwhile also testing it</span></p>\n<p dir=\"auto\">This example will print <code>Found an id in range: 5</code>. By specifying <code>id_variable @</code> before the range <code>3..=7</code>, we’re capturing whatever value matched the range\nwhile also testing that the value matched the range pattern.</p>\n<p dir=\"auto\">In the second arm, where we only have a range specified in the pattern, the code\nassociated with the arm doesn’t have a variable that contains the actual value\nof the <code>id</code> field. The <code>id</code> field’s value could have been 10, 11, or 12, but\nthe code that goes with that pattern doesn’t know which it is. The pattern code\nisn’t able to use the value from the <code>id</code> field, because we haven’t saved the\n<code>id</code> value in a variable.</p>\n<p dir=\"auto\">In the last arm, where we’ve specified a variable without a range, we do have\nthe value available to use in the arm’s code in a variable named <code>id</code>. The\nreason is that we’ve used the struct field shorthand syntax. But we haven’t\napplied any test to the value in the <code>id</code> field in this arm, as we did with the\nfirst two arms: any value would match this pattern.</p>\n<p dir=\"auto\">Using <code>@</code> lets us test a value and save it in a variable within one pattern.</p>\n<h2 tabindex=\"-1\" id=\"user-content-summary\" dir=\"auto\"><a class=\"heading-link\" href=\"#summary\">Summary<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">Rust’s patterns are very useful in distinguishing between different kinds of\ndata. When used in <code>match</code> expressions, Rust ensures your patterns cover every\npossible value, or your program won’t compile. Patterns in <code>let</code> statements and\nfunction parameters make those constructs more useful, enabling the\ndestructuring of values into smaller parts at the same time as assigning to\nvariables. We can create simple or complex patterns to suit our needs.</p>\n<p dir=\"auto\">Next, for the penultimate chapter of the book, we’ll look at some advanced\naspects of a variety of Rust’s features.</p>\n</article>","renderedFileInfo":null,"shortPath":null,"tabSize":8,"topBannersInfo":{"overridingGlobalFundingFile":false,"globalPreferredFundingPath":null,"repoOwner":"rust-lang","repoName":"book","showInvalidCitationWarning":false,"citationHelpUrl":"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/about-citation-files","showDependabotConfigurationBanner":false,"actionsOnboardingTip":null},"truncated":false,"viewable":true,"workflowRedirectUrl":null,"symbols":{"timedOut":false,"notAnalyzed":true,"symbols":[]}},"copilotInfo":null,"csrf_tokens":{"/rust-lang/book/branches":{"post":"cTzzjAxL4RzWITlXc9DUe7WJ5Rt0-94fqrgzMEQyp8z2v-yE0PtZyn8ZFXiOyFijKNFudLJEYFniVHcLdiCD1w"},"/repos/preferences":{"post":"HuCHoy8vXfHqq-fWfvVSVm7g7957-2kNRG0ZrYyv8mPJGB5nadgPx5uAmLTEEmx1OKzMepjjk0dr7xZ2aWuIvQ"}}},"title":"book/src/ch18-03-pattern-syntax.md at main · rust-lang/book"}
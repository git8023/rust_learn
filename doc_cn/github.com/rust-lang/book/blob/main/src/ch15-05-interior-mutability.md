{"payload":{"allShortcutsEnabled":false,"fileTree":{"src":{"items":[{"name":"img","path":"src/img","contentType":"directory"},{"name":"SUMMARY.md","path":"src/SUMMARY.md","contentType":"file"},{"name":"appendix-00.md","path":"src/appendix-00.md","contentType":"file"},{"name":"appendix-01-keywords.md","path":"src/appendix-01-keywords.md","contentType":"file"},{"name":"appendix-02-operators.md","path":"src/appendix-02-operators.md","contentType":"file"},{"name":"appendix-03-derivable-traits.md","path":"src/appendix-03-derivable-traits.md","contentType":"file"},{"name":"appendix-04-useful-development-tools.md","path":"src/appendix-04-useful-development-tools.md","contentType":"file"},{"name":"appendix-05-editions.md","path":"src/appendix-05-editions.md","contentType":"file"},{"name":"appendix-06-translation.md","path":"src/appendix-06-translation.md","contentType":"file"},{"name":"appendix-07-nightly-rust.md","path":"src/appendix-07-nightly-rust.md","contentType":"file"},{"name":"ch00-00-introduction.md","path":"src/ch00-00-introduction.md","contentType":"file"},{"name":"ch01-00-getting-started.md","path":"src/ch01-00-getting-started.md","contentType":"file"},{"name":"ch01-01-installation.md","path":"src/ch01-01-installation.md","contentType":"file"},{"name":"ch01-02-hello-world.md","path":"src/ch01-02-hello-world.md","contentType":"file"},{"name":"ch01-03-hello-cargo.md","path":"src/ch01-03-hello-cargo.md","contentType":"file"},{"name":"ch02-00-guessing-game-tutorial.md","path":"src/ch02-00-guessing-game-tutorial.md","contentType":"file"},{"name":"ch03-00-common-programming-concepts.md","path":"src/ch03-00-common-programming-concepts.md","contentType":"file"},{"name":"ch03-01-variables-and-mutability.md","path":"src/ch03-01-variables-and-mutability.md","contentType":"file"},{"name":"ch03-02-data-types.md","path":"src/ch03-02-data-types.md","contentType":"file"},{"name":"ch03-03-how-functions-work.md","path":"src/ch03-03-how-functions-work.md","contentType":"file"},{"name":"ch03-04-comments.md","path":"src/ch03-04-comments.md","contentType":"file"},{"name":"ch03-05-control-flow.md","path":"src/ch03-05-control-flow.md","contentType":"file"},{"name":"ch04-00-understanding-ownership.md","path":"src/ch04-00-understanding-ownership.md","contentType":"file"},{"name":"ch04-01-what-is-ownership.md","path":"src/ch04-01-what-is-ownership.md","contentType":"file"},{"name":"ch04-02-references-and-borrowing.md","path":"src/ch04-02-references-and-borrowing.md","contentType":"file"},{"name":"ch04-03-slices.md","path":"src/ch04-03-slices.md","contentType":"file"},{"name":"ch05-00-structs.md","path":"src/ch05-00-structs.md","contentType":"file"},{"name":"ch05-01-defining-structs.md","path":"src/ch05-01-defining-structs.md","contentType":"file"},{"name":"ch05-02-example-structs.md","path":"src/ch05-02-example-structs.md","contentType":"file"},{"name":"ch05-03-method-syntax.md","path":"src/ch05-03-method-syntax.md","contentType":"file"},{"name":"ch06-00-enums.md","path":"src/ch06-00-enums.md","contentType":"file"},{"name":"ch06-01-defining-an-enum.md","path":"src/ch06-01-defining-an-enum.md","contentType":"file"},{"name":"ch06-02-match.md","path":"src/ch06-02-match.md","contentType":"file"},{"name":"ch06-03-if-let.md","path":"src/ch06-03-if-let.md","contentType":"file"},{"name":"ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","path":"src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","contentType":"file"},{"name":"ch07-01-packages-and-crates.md","path":"src/ch07-01-packages-and-crates.md","contentType":"file"},{"name":"ch07-02-defining-modules-to-control-scope-and-privacy.md","path":"src/ch07-02-defining-modules-to-control-scope-and-privacy.md","contentType":"file"},{"name":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","path":"src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","contentType":"file"},{"name":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","path":"src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","contentType":"file"},{"name":"ch07-05-separating-modules-into-different-files.md","path":"src/ch07-05-separating-modules-into-different-files.md","contentType":"file"},{"name":"ch08-00-common-collections.md","path":"src/ch08-00-common-collections.md","contentType":"file"},{"name":"ch08-01-vectors.md","path":"src/ch08-01-vectors.md","contentType":"file"},{"name":"ch08-02-strings.md","path":"src/ch08-02-strings.md","contentType":"file"},{"name":"ch08-03-hash-maps.md","path":"src/ch08-03-hash-maps.md","contentType":"file"},{"name":"ch09-00-error-handling.md","path":"src/ch09-00-error-handling.md","contentType":"file"},{"name":"ch09-01-unrecoverable-errors-with-panic.md","path":"src/ch09-01-unrecoverable-errors-with-panic.md","contentType":"file"},{"name":"ch09-02-recoverable-errors-with-result.md","path":"src/ch09-02-recoverable-errors-with-result.md","contentType":"file"},{"name":"ch09-03-to-panic-or-not-to-panic.md","path":"src/ch09-03-to-panic-or-not-to-panic.md","contentType":"file"},{"name":"ch10-00-generics.md","path":"src/ch10-00-generics.md","contentType":"file"},{"name":"ch10-01-syntax.md","path":"src/ch10-01-syntax.md","contentType":"file"},{"name":"ch10-02-traits.md","path":"src/ch10-02-traits.md","contentType":"file"},{"name":"ch10-03-lifetime-syntax.md","path":"src/ch10-03-lifetime-syntax.md","contentType":"file"},{"name":"ch11-00-testing.md","path":"src/ch11-00-testing.md","contentType":"file"},{"name":"ch11-01-writing-tests.md","path":"src/ch11-01-writing-tests.md","contentType":"file"},{"name":"ch11-02-running-tests.md","path":"src/ch11-02-running-tests.md","contentType":"file"},{"name":"ch11-03-test-organization.md","path":"src/ch11-03-test-organization.md","contentType":"file"},{"name":"ch12-00-an-io-project.md","path":"src/ch12-00-an-io-project.md","contentType":"file"},{"name":"ch12-01-accepting-command-line-arguments.md","path":"src/ch12-01-accepting-command-line-arguments.md","contentType":"file"},{"name":"ch12-02-reading-a-file.md","path":"src/ch12-02-reading-a-file.md","contentType":"file"},{"name":"ch12-03-improving-error-handling-and-modularity.md","path":"src/ch12-03-improving-error-handling-and-modularity.md","contentType":"file"},{"name":"ch12-04-testing-the-librarys-functionality.md","path":"src/ch12-04-testing-the-librarys-functionality.md","contentType":"file"},{"name":"ch12-05-working-with-environment-variables.md","path":"src/ch12-05-working-with-environment-variables.md","contentType":"file"},{"name":"ch12-06-writing-to-stderr-instead-of-stdout.md","path":"src/ch12-06-writing-to-stderr-instead-of-stdout.md","contentType":"file"},{"name":"ch13-00-functional-features.md","path":"src/ch13-00-functional-features.md","contentType":"file"},{"name":"ch13-01-closures.md","path":"src/ch13-01-closures.md","contentType":"file"},{"name":"ch13-02-iterators.md","path":"src/ch13-02-iterators.md","contentType":"file"},{"name":"ch13-03-improving-our-io-project.md","path":"src/ch13-03-improving-our-io-project.md","contentType":"file"},{"name":"ch13-04-performance.md","path":"src/ch13-04-performance.md","contentType":"file"},{"name":"ch14-00-more-about-cargo.md","path":"src/ch14-00-more-about-cargo.md","contentType":"file"},{"name":"ch14-01-release-profiles.md","path":"src/ch14-01-release-profiles.md","contentType":"file"},{"name":"ch14-02-publishing-to-crates-io.md","path":"src/ch14-02-publishing-to-crates-io.md","contentType":"file"},{"name":"ch14-03-cargo-workspaces.md","path":"src/ch14-03-cargo-workspaces.md","contentType":"file"},{"name":"ch14-04-installing-binaries.md","path":"src/ch14-04-installing-binaries.md","contentType":"file"},{"name":"ch14-05-extending-cargo.md","path":"src/ch14-05-extending-cargo.md","contentType":"file"},{"name":"ch15-00-smart-pointers.md","path":"src/ch15-00-smart-pointers.md","contentType":"file"},{"name":"ch15-01-box.md","path":"src/ch15-01-box.md","contentType":"file"},{"name":"ch15-02-deref.md","path":"src/ch15-02-deref.md","contentType":"file"},{"name":"ch15-03-drop.md","path":"src/ch15-03-drop.md","contentType":"file"},{"name":"ch15-04-rc.md","path":"src/ch15-04-rc.md","contentType":"file"},{"name":"ch15-05-interior-mutability.md","path":"src/ch15-05-interior-mutability.md","contentType":"file"},{"name":"ch15-06-reference-cycles.md","path":"src/ch15-06-reference-cycles.md","contentType":"file"},{"name":"ch16-00-concurrency.md","path":"src/ch16-00-concurrency.md","contentType":"file"},{"name":"ch16-01-threads.md","path":"src/ch16-01-threads.md","contentType":"file"},{"name":"ch16-02-message-passing.md","path":"src/ch16-02-message-passing.md","contentType":"file"},{"name":"ch16-03-shared-state.md","path":"src/ch16-03-shared-state.md","contentType":"file"},{"name":"ch16-04-extensible-concurrency-sync-and-send.md","path":"src/ch16-04-extensible-concurrency-sync-and-send.md","contentType":"file"},{"name":"ch17-00-oop.md","path":"src/ch17-00-oop.md","contentType":"file"},{"name":"ch17-01-what-is-oo.md","path":"src/ch17-01-what-is-oo.md","contentType":"file"},{"name":"ch17-02-trait-objects.md","path":"src/ch17-02-trait-objects.md","contentType":"file"},{"name":"ch17-03-oo-design-patterns.md","path":"src/ch17-03-oo-design-patterns.md","contentType":"file"},{"name":"ch18-00-patterns.md","path":"src/ch18-00-patterns.md","contentType":"file"},{"name":"ch18-01-all-the-places-for-patterns.md","path":"src/ch18-01-all-the-places-for-patterns.md","contentType":"file"},{"name":"ch18-02-refutability.md","path":"src/ch18-02-refutability.md","contentType":"file"},{"name":"ch18-03-pattern-syntax.md","path":"src/ch18-03-pattern-syntax.md","contentType":"file"},{"name":"ch19-00-advanced-features.md","path":"src/ch19-00-advanced-features.md","contentType":"file"},{"name":"ch19-01-unsafe-rust.md","path":"src/ch19-01-unsafe-rust.md","contentType":"file"},{"name":"ch19-03-advanced-traits.md","path":"src/ch19-03-advanced-traits.md","contentType":"file"},{"name":"ch19-04-advanced-types.md","path":"src/ch19-04-advanced-types.md","contentType":"file"},{"name":"ch19-05-advanced-functions-and-closures.md","path":"src/ch19-05-advanced-functions-and-closures.md","contentType":"file"},{"name":"ch19-06-macros.md","path":"src/ch19-06-macros.md","contentType":"file"},{"name":"ch20-00-final-project-a-web-server.md","path":"src/ch20-00-final-project-a-web-server.md","contentType":"file"},{"name":"ch20-01-single-threaded.md","path":"src/ch20-01-single-threaded.md","contentType":"file"},{"name":"ch20-02-multithreaded.md","path":"src/ch20-02-multithreaded.md","contentType":"file"},{"name":"ch20-03-graceful-shutdown-and-cleanup.md","path":"src/ch20-03-graceful-shutdown-and-cleanup.md","contentType":"file"},{"name":"foreword.md","path":"src/foreword.md","contentType":"file"},{"name":"title-page.md","path":"src/title-page.md","contentType":"file"}],"totalCount":106},"":{"items":[{"name":".cargo","path":".cargo","contentType":"directory"},{"name":".github","path":".github","contentType":"directory"},{"name":"2018-edition","path":"2018-edition","contentType":"directory"},{"name":"ci","path":"ci","contentType":"directory"},{"name":"dot","path":"dot","contentType":"directory"},{"name":"first-edition","path":"first-edition","contentType":"directory"},{"name":"listings","path":"listings","contentType":"directory"},{"name":"nostarch","path":"nostarch","contentType":"directory"},{"name":"redirects","path":"redirects","contentType":"directory"},{"name":"second-edition","path":"second-edition","contentType":"directory"},{"name":"src","path":"src","contentType":"directory"},{"name":"theme","path":"theme","contentType":"directory"},{"name":"tools","path":"tools","contentType":"directory"},{"name":".gitattributes","path":".gitattributes","contentType":"file"},{"name":".gitignore","path":".gitignore","contentType":"file"},{"name":"ADMIN_TASKS.md","path":"ADMIN_TASKS.md","contentType":"file"},{"name":"CONTRIBUTING.md","path":"CONTRIBUTING.md","contentType":"file"},{"name":"COPYRIGHT","path":"COPYRIGHT","contentType":"file"},{"name":"Cargo.lock","path":"Cargo.lock","contentType":"file"},{"name":"Cargo.toml","path":"Cargo.toml","contentType":"file"},{"name":"LICENSE-APACHE","path":"LICENSE-APACHE","contentType":"file"},{"name":"LICENSE-MIT","path":"LICENSE-MIT","contentType":"file"},{"name":"README.md","path":"README.md","contentType":"file"},{"name":"TODO.md","path":"TODO.md","contentType":"file"},{"name":"book.toml","path":"book.toml","contentType":"file"},{"name":"ferris.css","path":"ferris.css","contentType":"file"},{"name":"ferris.js","path":"ferris.js","contentType":"file"},{"name":"rust-toolchain","path":"rust-toolchain","contentType":"file"},{"name":"rustfmt.toml","path":"rustfmt.toml","contentType":"file"},{"name":"style-guide.md","path":"style-guide.md","contentType":"file"}],"totalCount":30}},"fileTreeProcessingTime":19.307678000000003,"foldersToFetch":[],"reducedMotionEnabled":null,"repo":{"id":47854924,"defaultBranch":"main","name":"book","ownerLogin":"rust-lang","currentUserCanPush":false,"isFork":false,"isEmpty":false,"createdAt":"2015-12-11T22:49:49.000Z","ownerAvatar":"https://avatars.githubusercontent.com/u/5430905?v=4","public":true,"private":false,"isOrgOwned":true},"symbolsExpanded":false,"treeExpanded":true,"refInfo":{"name":"main","listCacheKey":"v0:1688046669.0","canEdit":false,"refType":"branch","currentOid":"72187f5cd0beaaa9c6f584156bcd88f921871e83"},"path":"src/ch15-05-interior-mutability.md","currentUser":null,"blob":{"rawLines":null,"stylingDirectives":null,"csv":null,"csvError":null,"dependabotInfo":{"showConfigurationBanner":false,"configFilePath":null,"networkDependabotPath":"/rust-lang/book/network/updates","dismissConfigurationNoticePath":"/settings/dismiss-notice/dependabot_configuration_notice","configurationNoticeDismissed":null,"repoAlertsPath":"/rust-lang/book/security/dependabot","repoSecurityAndAnalysisPath":"/rust-lang/book/settings/security_analysis","repoOwnerIsOrg":true,"currentUserCanAdminRepo":false},"displayName":"ch15-05-interior-mutability.md","displayUrl":"https://github.com/rust-lang/book/blob/main/src/ch15-05-interior-mutability.md?raw=true","headerInfo":{"blobSize":"17.6 KB","deleteInfo":{"deleteTooltip":"You must be signed in to make or propose changes"},"editInfo":{"editTooltip":"You must be signed in to make or propose changes"},"ghDesktopPath":"https://desktop.github.com","gitLfsPath":null,"onBranch":true,"shortPath":"7b5e825","siteNavLoginPath":"/login?return_to=https%3A%2F%2Fgithub.com%2Frust-lang%2Fbook%2Fblob%2Fmain%2Fsrc%2Fch15-05-interior-mutability.md","isCSV":false,"isRichtext":true,"toc":[{"level":2,"text":"RefCell<T> and the Interior Mutability Pattern","anchor":"refcellt-and-the-interior-mutability-pattern","htmlText":"RefCell&lt;T&gt; and the Interior Mutability Pattern"},{"level":3,"text":"Enforcing Borrowing Rules at Runtime with RefCell<T>","anchor":"enforcing-borrowing-rules-at-runtime-with-refcellt","htmlText":"Enforcing Borrowing Rules at Runtime with RefCell&lt;T&gt;"},{"level":3,"text":"Interior Mutability: A Mutable Borrow to an Immutable Value","anchor":"interior-mutability-a-mutable-borrow-to-an-immutable-value","htmlText":"Interior Mutability: A Mutable Borrow to an Immutable Value"},{"level":4,"text":"A Use Case for Interior Mutability: Mock Objects","anchor":"a-use-case-for-interior-mutability-mock-objects","htmlText":"A Use Case for Interior Mutability: Mock Objects"},{"level":4,"text":"Keeping Track of Borrows at Runtime with RefCell<T>","anchor":"keeping-track-of-borrows-at-runtime-with-refcellt","htmlText":"Keeping Track of Borrows at Runtime with RefCell&lt;T&gt;"},{"level":3,"text":"Having Multiple Owners of Mutable Data by Combining Rc<T> and RefCell<T>","anchor":"having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt","htmlText":"Having Multiple Owners of Mutable Data by Combining Rc&lt;T&gt; and RefCell&lt;T&gt;"}],"lineInfo":{"truncatedLoc":"344","truncatedSloc":"273"},"mode":"file"},"image":false,"isCodeownersFile":null,"isPlain":false,"isValidLegacyIssueTemplate":false,"issueTemplateHelpUrl":"https://docs.github.com/articles/about-issue-and-pull-request-templates","issueTemplate":null,"discussionTemplate":null,"language":"Markdown","languageID":222,"large":false,"loggedIn":false,"newDiscussionPath":"/rust-lang/book/discussions/new","newIssuePath":"/rust-lang/book/issues/new","planSupportInfo":{"repoIsFork":null,"repoOwnedByCurrentUser":null,"requestFullPath":"/rust-lang/book/blob/main/src/ch15-05-interior-mutability.md","showFreeOrgGatedFeatureMessage":null,"showPlanSupportBanner":null,"upgradeDataAttributes":null,"upgradePath":null},"publishBannersInfo":{"dismissActionNoticePath":"/settings/dismiss-notice/publish_action_from_dockerfile","dismissStackNoticePath":"/settings/dismiss-notice/publish_stack_from_file","releasePath":"/rust-lang/book/releases/new?marketplace=true","showPublishActionBanner":false,"showPublishStackBanner":false},"renderImageOrRaw":false,"richText":"<article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><h2 tabindex=\"-1\" id=\"user-content-refcellt-and-the-interior-mutability-pattern\" dir=\"auto\"><a class=\"heading-link\" href=\"#refcellt-and-the-interior-mutability-pattern\"><code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\"><em>Interior mutability</em> is a design pattern in Rust that allows you to mutate\ndata even when there are immutable references to that data; normally, this\naction is disallowed by the borrowing rules. To mutate data, the pattern uses\n<code>unsafe</code> code inside a data structure to bend Rust’s usual rules that govern\nmutation and borrowing. Unsafe code indicates to the compiler that we’re\nchecking the rules manually instead of relying on the compiler to check them\nfor us; we will discuss unsafe code more in Chapter 19.</p>\n<p dir=\"auto\">We can use types that use the interior mutability pattern only when we can\nensure that the borrowing rules will be followed at runtime, even though the\ncompiler can’t guarantee that. The <code>unsafe</code> code involved is then wrapped in a\nsafe API, and the outer type is still immutable.</p>\n<p dir=\"auto\">Let’s explore this concept by looking at the <code>RefCell&lt;T&gt;</code> type that follows the\ninterior mutability pattern.</p>\n<h3 tabindex=\"-1\" id=\"user-content-enforcing-borrowing-rules-at-runtime-with-refcellt\" dir=\"auto\"><a class=\"heading-link\" href=\"#enforcing-borrowing-rules-at-runtime-with-refcellt\">Enforcing Borrowing Rules at Runtime with <code>RefCell&lt;T&gt;</code><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">Unlike <code>Rc&lt;T&gt;</code>, the <code>RefCell&lt;T&gt;</code> type represents single ownership over the data\nit holds. So, what makes <code>RefCell&lt;T&gt;</code> different from a type like <code>Box&lt;T&gt;</code>?\nRecall the borrowing rules you learned in Chapter 4:</p>\n<ul dir=\"auto\">\n<li>At any given time, you can have <em>either</em> (but not both) one mutable reference\nor any number of immutable references.</li>\n<li>References must always be valid.</li>\n</ul>\n<p dir=\"auto\">With references and <code>Box&lt;T&gt;</code>, the borrowing rules’ invariants are enforced at\ncompile time. With <code>RefCell&lt;T&gt;</code>, these invariants are enforced <em>at runtime</em>.\nWith references, if you break these rules, you’ll get a compiler error. With\n<code>RefCell&lt;T&gt;</code>, if you break these rules, your program will panic and exit.</p>\n<p dir=\"auto\">The advantages of checking the borrowing rules at compile time are that errors\nwill be caught sooner in the development process, and there is no impact on\nruntime performance because all the analysis is completed beforehand. For those\nreasons, checking the borrowing rules at compile time is the best choice in the\nmajority of cases, which is why this is Rust’s default.</p>\n<p dir=\"auto\">The advantage of checking the borrowing rules at runtime instead is that\ncertain memory-safe scenarios are then allowed, where they would’ve been\ndisallowed by the compile-time checks. Static analysis, like the Rust compiler,\nis inherently conservative. Some properties of code are impossible to detect by\nanalyzing the code: the most famous example is the Halting Problem, which is\nbeyond the scope of this book but is an interesting topic to research.</p>\n<p dir=\"auto\">Because some analysis is impossible, if the Rust compiler can’t be sure the\ncode complies with the ownership rules, it might reject a correct program; in\nthis way, it’s conservative. If Rust accepted an incorrect program, users\nwouldn’t be able to trust in the guarantees Rust makes. However, if Rust\nrejects a correct program, the programmer will be inconvenienced, but nothing\ncatastrophic can occur. The <code>RefCell&lt;T&gt;</code> type is useful when you’re sure your\ncode follows the borrowing rules but the compiler is unable to understand and\nguarantee that.</p>\n<p dir=\"auto\">Similar to <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> is only for use in single-threaded scenarios\nand will give you a compile-time error if you try using it in a multithreaded\ncontext. We’ll talk about how to get the functionality of <code>RefCell&lt;T&gt;</code> in a\nmultithreaded program in Chapter 16.</p>\n<p dir=\"auto\">Here is a recap of the reasons to choose <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, or <code>RefCell&lt;T&gt;</code>:</p>\n<ul dir=\"auto\">\n<li><code>Rc&lt;T&gt;</code> enables multiple owners of the same data; <code>Box&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>\nhave single owners.</li>\n<li><code>Box&lt;T&gt;</code> allows immutable or mutable borrows checked at compile time; <code>Rc&lt;T&gt;</code>\nallows only immutable borrows checked at compile time; <code>RefCell&lt;T&gt;</code> allows\nimmutable or mutable borrows checked at runtime.</li>\n<li>Because <code>RefCell&lt;T&gt;</code> allows mutable borrows checked at runtime, you can\nmutate the value inside the <code>RefCell&lt;T&gt;</code> even when the <code>RefCell&lt;T&gt;</code> is\nimmutable.</li>\n</ul>\n<p dir=\"auto\">Mutating the value inside an immutable value is the <em>interior mutability</em>\npattern. Let’s look at a situation in which interior mutability is useful and\nexamine how it’s possible.</p>\n<h3 tabindex=\"-1\" id=\"user-content-interior-mutability-a-mutable-borrow-to-an-immutable-value\" dir=\"auto\"><a class=\"heading-link\" href=\"#interior-mutability-a-mutable-borrow-to-an-immutable-value\">Interior Mutability: A Mutable Borrow to an Immutable Value<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">A consequence of the borrowing rules is that when you have an immutable value,\nyou can’t borrow it mutably. For example, this code won’t compile:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/no-listing-01-cant-borrow-immutable-as-mutable/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/no-listing-<span class=\"pl-c1\">01</span>-cant-borrow-immutable-as-mutable/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">If you tried to compile this code, you’d get the following error:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch15-smart-pointers/no-listing-01-cant-borrow-immutable-as-mutable/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch15-smart-pointers/no-listing-01-cant-borrow-immutable-as-mutable/output.txt}}</span></pre></div>\n<p dir=\"auto\">However, there are situations in which it would be useful for a value to mutate\nitself in its methods but appear immutable to other code. Code outside the\nvalue’s methods would not be able to mutate the value. Using <code>RefCell&lt;T&gt;</code> is\none way to get the ability to have interior mutability, but <code>RefCell&lt;T&gt;</code>\ndoesn’t get around the borrowing rules completely: the borrow checker in the\ncompiler allows this interior mutability, and the borrowing rules are checked\nat runtime instead. If you violate the rules, you’ll get a <code>panic!</code> instead of\na compiler error.</p>\n<p dir=\"auto\">Let’s work through a practical example where we can use <code>RefCell&lt;T&gt;</code> to mutate\nan immutable value and see why that is useful.</p>\n<h4 tabindex=\"-1\" id=\"user-content-a-use-case-for-interior-mutability-mock-objects\" dir=\"auto\"><a class=\"heading-link\" href=\"#a-use-case-for-interior-mutability-mock-objects\">A Use Case for Interior Mutability: Mock Objects<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">Sometimes during testing a programmer will use a type in place of another type,\nin order to observe particular behavior and assert it’s implemented correctly.\nThis placeholder type is called a <em>test double</em>. Think of it in the sense of a\n“stunt double” in filmmaking, where a person steps in and substitutes for an\nactor to do a particular tricky scene. Test doubles stand in for other types\nwhen we’re running tests. <em>Mock objects</em> are specific types of test doubles\nthat record what happens during a test so you can assert that the correct\nactions took place.</p>\n<p dir=\"auto\">Rust doesn’t have objects in the same sense as other languages have objects,\nand Rust doesn’t have mock object functionality built into the standard library\nas some other languages do. However, you can definitely create a struct that\nwill serve the same purposes as a mock object.</p>\n<p dir=\"auto\">Here’s the scenario we’ll test: we’ll create a library that tracks a value\nagainst a maximum value and sends messages based on how close to the maximum\nvalue the current value is. This library could be used to keep track of a\nuser’s quota for the number of API calls they’re allowed to make, for example.</p>\n<p dir=\"auto\">Our library will only provide the functionality of tracking how close to the\nmaximum a value is and what the messages should be at what times. Applications\nthat use our library will be expected to provide the mechanism for sending the\nmessages: the application could put a message in the application, send an\nemail, send a text message, or something else. The library doesn’t need to know\nthat detail. All it needs is something that implements a trait we’ll provide\ncalled <code>Messenger</code>. Listing 15-20 shows the library code:</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-20/src/lib.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">20</span>/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-20: A library to keep track of how close a\nvalue is to a maximum value and warn when the value is at certain levels</span></p>\n<p dir=\"auto\">One important part of this code is that the <code>Messenger</code> trait has one method\ncalled <code>send</code> that takes an immutable reference to <code>self</code> and the text of the\nmessage. This trait is the interface our mock object needs to implement so that\nthe mock can be used in the same way a real object is. The other important part\nis that we want to test the behavior of the <code>set_value</code> method on the\n<code>LimitTracker</code>. We can change what we pass in for the <code>value</code> parameter, but\n<code>set_value</code> doesn’t return anything for us to make assertions on. We want to be\nable to say that if we create a <code>LimitTracker</code> with something that implements\nthe <code>Messenger</code> trait and a particular value for <code>max</code>, when we pass different\nnumbers for <code>value</code>, the messenger is told to send the appropriate messages.</p>\n<p dir=\"auto\">We need a mock object that, instead of sending an email or text message when we\ncall <code>send</code>, will only keep track of the messages it’s told to send. We can\ncreate a new instance of the mock object, create a <code>LimitTracker</code> that uses the\nmock object, call the <code>set_value</code> method on <code>LimitTracker</code>, and then check that\nthe mock object has the messages we expect. Listing 15-21 shows an attempt to\nimplement a mock object to do just that, but the borrow checker won’t allow it:</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-21/src/lib.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">21</span>/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-21: An attempt to implement a <code>MockMessenger</code>\nthat isn’t allowed by the borrow checker</span></p>\n<p dir=\"auto\">This test code defines a <code>MockMessenger</code> struct that has a <code>sent_messages</code>\nfield with a <code>Vec</code> of <code>String</code> values to keep track of the messages it’s told\nto send. We also define an associated function <code>new</code> to make it convenient to\ncreate new <code>MockMessenger</code> values that start with an empty list of messages. We\nthen implement the <code>Messenger</code> trait for <code>MockMessenger</code> so we can give a\n<code>MockMessenger</code> to a <code>LimitTracker</code>. In the definition of the <code>send</code> method, we\ntake the message passed in as a parameter and store it in the <code>MockMessenger</code>\nlist of <code>sent_messages</code>.</p>\n<p dir=\"auto\">In the test, we’re testing what happens when the <code>LimitTracker</code> is told to set\n<code>value</code> to something that is more than 75 percent of the <code>max</code> value. First, we\ncreate a new <code>MockMessenger</code>, which will start with an empty list of messages.\nThen we create a new <code>LimitTracker</code> and give it a reference to the new\n<code>MockMessenger</code> and a <code>max</code> value of 100. We call the <code>set_value</code> method on the\n<code>LimitTracker</code> with a value of 80, which is more than 75 percent of 100. Then\nwe assert that the list of messages that the <code>MockMessenger</code> is keeping track\nof should now have one message in it.</p>\n<p dir=\"auto\">However, there’s one problem with this test, as shown here:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch15-smart-pointers/listing-15-21/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch15-smart-pointers/listing-15-21/output.txt}}</span></pre></div>\n<p dir=\"auto\">We can’t modify the <code>MockMessenger</code> to keep track of the messages, because the\n<code>send</code> method takes an immutable reference to <code>self</code>. We also can’t take the\nsuggestion from the error text to use <code>&amp;mut self</code> instead, because then the\nsignature of <code>send</code> wouldn’t match the signature in the <code>Messenger</code> trait\ndefinition (feel free to try and see what error message you get).</p>\n<p dir=\"auto\">This is a situation in which interior mutability can help! We’ll store the\n<code>sent_messages</code> within a <code>RefCell&lt;T&gt;</code>, and then the <code>send</code> method will be\nable to modify <code>sent_messages</code> to store the messages we’ve seen. Listing 15-22\nshows what that looks like:</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-22/src/lib.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">22</span>/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-22: Using <code>RefCell&lt;T&gt;</code> to mutate an inner\nvalue while the outer value is considered immutable</span></p>\n<p dir=\"auto\">The <code>sent_messages</code> field is now of type <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> instead of\n<code>Vec&lt;String&gt;</code>. In the <code>new</code> function, we create a new <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>\ninstance around the empty vector.</p>\n<p dir=\"auto\">For the implementation of the <code>send</code> method, the first parameter is still an\nimmutable borrow of <code>self</code>, which matches the trait definition. We call\n<code>borrow_mut</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> in <code>self.sent_messages</code> to get a\nmutable reference to the value inside the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, which is the\nvector. Then we can call <code>push</code> on the mutable reference to the vector to keep\ntrack of the messages sent during the test.</p>\n<p dir=\"auto\">The last change we have to make is in the assertion: to see how many items are\nin the inner vector, we call <code>borrow</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> to get an\nimmutable reference to the vector.</p>\n<p dir=\"auto\">Now that you’ve seen how to use <code>RefCell&lt;T&gt;</code>, let’s dig into how it works!</p>\n<h4 tabindex=\"-1\" id=\"user-content-keeping-track-of-borrows-at-runtime-with-refcellt\" dir=\"auto\"><a class=\"heading-link\" href=\"#keeping-track-of-borrows-at-runtime-with-refcellt\">Keeping Track of Borrows at Runtime with <code>RefCell&lt;T&gt;</code><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">When creating immutable and mutable references, we use the <code>&amp;</code> and <code>&amp;mut</code>\nsyntax, respectively. With <code>RefCell&lt;T&gt;</code>, we use the <code>borrow</code> and <code>borrow_mut</code>\nmethods, which are part of the safe API that belongs to <code>RefCell&lt;T&gt;</code>. The\n<code>borrow</code> method returns the smart pointer type <code>Ref&lt;T&gt;</code>, and <code>borrow_mut</code>\nreturns the smart pointer type <code>RefMut&lt;T&gt;</code>. Both types implement <code>Deref</code>, so we\ncan treat them like regular references.</p>\n<p dir=\"auto\">The <code>RefCell&lt;T&gt;</code> keeps track of how many <code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code> smart\npointers are currently active. Every time we call <code>borrow</code>, the <code>RefCell&lt;T&gt;</code>\nincreases its count of how many immutable borrows are active. When a <code>Ref&lt;T&gt;</code>\nvalue goes out of scope, the count of immutable borrows goes down by one. Just\nlike the compile-time borrowing rules, <code>RefCell&lt;T&gt;</code> lets us have many immutable\nborrows or one mutable borrow at any point in time.</p>\n<p dir=\"auto\">If we try to violate these rules, rather than getting a compiler error as we\nwould with references, the implementation of <code>RefCell&lt;T&gt;</code> will panic at\nruntime. Listing 15-23 shows a modification of the implementation of <code>send</code> in\nListing 15-22. We’re deliberately trying to create two mutable borrows active\nfor the same scope to illustrate that <code>RefCell&lt;T&gt;</code> prevents us from doing this\nat runtime.</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-23/src/lib.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">23</span>/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-23: Creating two mutable references in the\nsame scope to see that <code>RefCell&lt;T&gt;</code> will panic</span></p>\n<p dir=\"auto\">We create a variable <code>one_borrow</code> for the <code>RefMut&lt;T&gt;</code> smart pointer returned\nfrom <code>borrow_mut</code>. Then we create another mutable borrow in the same way in the\nvariable <code>two_borrow</code>. This makes two mutable references in the same scope,\nwhich isn’t allowed. When we run the tests for our library, the code in Listing\n15-23 will compile without any errors, but the test will fail:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch15-smart-pointers/listing-15-23/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch15-smart-pointers/listing-15-23/output.txt}}</span></pre></div>\n<p dir=\"auto\">Notice that the code panicked with the message <code>already borrowed: BorrowMutError</code>. This is how <code>RefCell&lt;T&gt;</code> handles violations of the borrowing\nrules at runtime.</p>\n<p dir=\"auto\">Choosing to catch borrowing errors at runtime rather than compile time, as\nwe’ve done here, means you’d potentially be finding mistakes in your code later\nin the development process: possibly not until your code was deployed to\nproduction. Also, your code would incur a small runtime performance penalty as\na result of keeping track of the borrows at runtime rather than compile time.\nHowever, using <code>RefCell&lt;T&gt;</code> makes it possible to write a mock object that can\nmodify itself to keep track of the messages it has seen while you’re using it\nin a context where only immutable values are allowed. You can use <code>RefCell&lt;T&gt;</code>\ndespite its trade-offs to get more functionality than regular references\nprovide.</p>\n<h3 tabindex=\"-1\" id=\"user-content-having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt\" dir=\"auto\"><a class=\"heading-link\" href=\"#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt\">Having Multiple Owners of Mutable Data by Combining <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">A common way to use <code>RefCell&lt;T&gt;</code> is in combination with <code>Rc&lt;T&gt;</code>. Recall that\n<code>Rc&lt;T&gt;</code> lets you have multiple owners of some data, but it only gives immutable\naccess to that data. If you have an <code>Rc&lt;T&gt;</code> that holds a <code>RefCell&lt;T&gt;</code>, you can\nget a value that can have multiple owners <em>and</em> that you can mutate!</p>\n<p dir=\"auto\">For example, recall the cons list example in Listing 15-18 where we used\n<code>Rc&lt;T&gt;</code> to allow multiple lists to share ownership of another list. Because\n<code>Rc&lt;T&gt;</code> holds only immutable values, we can’t change any of the values in the\nlist once we’ve created them. Let’s add in <code>RefCell&lt;T&gt;</code> to gain the ability to\nchange the values in the lists. Listing 15-24 shows that by using a\n<code>RefCell&lt;T&gt;</code> in the <code>Cons</code> definition, we can modify the value stored in all\nthe lists:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-24/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">24</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-24: Using <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> to create a\n<code>List</code> that we can mutate</span></p>\n<p dir=\"auto\">We create a value that is an instance of <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> and store it in a\nvariable named <code>value</code> so we can access it directly later. Then we create a\n<code>List</code> in <code>a</code> with a <code>Cons</code> variant that holds <code>value</code>. We need to clone\n<code>value</code> so both <code>a</code> and <code>value</code> have ownership of the inner <code>5</code> value rather\nthan transferring ownership from <code>value</code> to <code>a</code> or having <code>a</code> borrow from\n<code>value</code>.</p>\n<p dir=\"auto\">We wrap the list <code>a</code> in an <code>Rc&lt;T&gt;</code> so when we create lists <code>b</code> and <code>c</code>, they\ncan both refer to <code>a</code>, which is what we did in Listing 15-18.</p>\n<p dir=\"auto\">After we’ve created the lists in <code>a</code>, <code>b</code>, and <code>c</code>, we want to add 10 to the\nvalue in <code>value</code>. We do this by calling <code>borrow_mut</code> on <code>value</code>, which uses the\nautomatic dereferencing feature we discussed in Chapter 5 (see the section\n<a href=\"/rust-lang/book/blob/main/src/ch05-03-method-syntax.html#wheres-the---operator\">“Where’s the <code>-&gt;</code> Operator?”</a>) to\ndereference the <code>Rc&lt;T&gt;</code> to the inner <code>RefCell&lt;T&gt;</code> value. The <code>borrow_mut</code>\nmethod returns a <code>RefMut&lt;T&gt;</code> smart pointer, and we use the dereference operator\non it and change the inner value.</p>\n<p dir=\"auto\">When we print <code>a</code>, <code>b</code>, and <code>c</code>, we can see that they all have the modified\nvalue of 15 rather than 5:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch15-smart-pointers/listing-15-24/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch15-smart-pointers/listing-15-24/output.txt}}</span></pre></div>\n<p dir=\"auto\">This technique is pretty neat! By using <code>RefCell&lt;T&gt;</code>, we have an outwardly\nimmutable <code>List</code> value. But we can use the methods on <code>RefCell&lt;T&gt;</code> that provide\naccess to its interior mutability so we can modify our data when we need to.\nThe runtime checks of the borrowing rules protect us from data races, and it’s\nsometimes worth trading a bit of speed for this flexibility in our data\nstructures. Note that <code>RefCell&lt;T&gt;</code> does not work for multithreaded code!\n<code>Mutex&lt;T&gt;</code> is the thread-safe version of <code>RefCell&lt;T&gt;</code> and we’ll discuss\n<code>Mutex&lt;T&gt;</code> in Chapter 16.</p>\n</article>","renderedFileInfo":null,"shortPath":null,"tabSize":8,"topBannersInfo":{"overridingGlobalFundingFile":false,"globalPreferredFundingPath":null,"repoOwner":"rust-lang","repoName":"book","showInvalidCitationWarning":false,"citationHelpUrl":"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/about-citation-files","showDependabotConfigurationBanner":false,"actionsOnboardingTip":null},"truncated":false,"viewable":true,"workflowRedirectUrl":null,"symbols":{"timedOut":false,"notAnalyzed":true,"symbols":[]}},"copilotInfo":null,"csrf_tokens":{"/rust-lang/book/branches":{"post":"vLUkH3ZyJwK-eYNYxaObhUvxoQzVIq_QI1GMSZjqhDWicAf3mQQJs8khVK3uecb0ZEG1SNpraDCyReu3E2LNcA"},"/repos/preferences":{"post":"DtcVtLOPZp8yt_-6qQRKnwMCwKiw7XxgKBQooGMdccIZGKnXRyqsrUi-NTUnzDYo4wFgRPr8yG-eOO2LXDvZ8w"}}},"title":"book/src/ch15-05-interior-mutability.md at main · rust-lang/book"}
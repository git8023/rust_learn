{"payload":{"allShortcutsEnabled":false,"fileTree":{"src":{"items":[{"name":"img","path":"src/img","contentType":"directory"},{"name":"SUMMARY.md","path":"src/SUMMARY.md","contentType":"file"},{"name":"appendix-00.md","path":"src/appendix-00.md","contentType":"file"},{"name":"appendix-01-keywords.md","path":"src/appendix-01-keywords.md","contentType":"file"},{"name":"appendix-02-operators.md","path":"src/appendix-02-operators.md","contentType":"file"},{"name":"appendix-03-derivable-traits.md","path":"src/appendix-03-derivable-traits.md","contentType":"file"},{"name":"appendix-04-useful-development-tools.md","path":"src/appendix-04-useful-development-tools.md","contentType":"file"},{"name":"appendix-05-editions.md","path":"src/appendix-05-editions.md","contentType":"file"},{"name":"appendix-06-translation.md","path":"src/appendix-06-translation.md","contentType":"file"},{"name":"appendix-07-nightly-rust.md","path":"src/appendix-07-nightly-rust.md","contentType":"file"},{"name":"ch00-00-introduction.md","path":"src/ch00-00-introduction.md","contentType":"file"},{"name":"ch01-00-getting-started.md","path":"src/ch01-00-getting-started.md","contentType":"file"},{"name":"ch01-01-installation.md","path":"src/ch01-01-installation.md","contentType":"file"},{"name":"ch01-02-hello-world.md","path":"src/ch01-02-hello-world.md","contentType":"file"},{"name":"ch01-03-hello-cargo.md","path":"src/ch01-03-hello-cargo.md","contentType":"file"},{"name":"ch02-00-guessing-game-tutorial.md","path":"src/ch02-00-guessing-game-tutorial.md","contentType":"file"},{"name":"ch03-00-common-programming-concepts.md","path":"src/ch03-00-common-programming-concepts.md","contentType":"file"},{"name":"ch03-01-variables-and-mutability.md","path":"src/ch03-01-variables-and-mutability.md","contentType":"file"},{"name":"ch03-02-data-types.md","path":"src/ch03-02-data-types.md","contentType":"file"},{"name":"ch03-03-how-functions-work.md","path":"src/ch03-03-how-functions-work.md","contentType":"file"},{"name":"ch03-04-comments.md","path":"src/ch03-04-comments.md","contentType":"file"},{"name":"ch03-05-control-flow.md","path":"src/ch03-05-control-flow.md","contentType":"file"},{"name":"ch04-00-understanding-ownership.md","path":"src/ch04-00-understanding-ownership.md","contentType":"file"},{"name":"ch04-01-what-is-ownership.md","path":"src/ch04-01-what-is-ownership.md","contentType":"file"},{"name":"ch04-02-references-and-borrowing.md","path":"src/ch04-02-references-and-borrowing.md","contentType":"file"},{"name":"ch04-03-slices.md","path":"src/ch04-03-slices.md","contentType":"file"},{"name":"ch05-00-structs.md","path":"src/ch05-00-structs.md","contentType":"file"},{"name":"ch05-01-defining-structs.md","path":"src/ch05-01-defining-structs.md","contentType":"file"},{"name":"ch05-02-example-structs.md","path":"src/ch05-02-example-structs.md","contentType":"file"},{"name":"ch05-03-method-syntax.md","path":"src/ch05-03-method-syntax.md","contentType":"file"},{"name":"ch06-00-enums.md","path":"src/ch06-00-enums.md","contentType":"file"},{"name":"ch06-01-defining-an-enum.md","path":"src/ch06-01-defining-an-enum.md","contentType":"file"},{"name":"ch06-02-match.md","path":"src/ch06-02-match.md","contentType":"file"},{"name":"ch06-03-if-let.md","path":"src/ch06-03-if-let.md","contentType":"file"},{"name":"ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","path":"src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","contentType":"file"},{"name":"ch07-01-packages-and-crates.md","path":"src/ch07-01-packages-and-crates.md","contentType":"file"},{"name":"ch07-02-defining-modules-to-control-scope-and-privacy.md","path":"src/ch07-02-defining-modules-to-control-scope-and-privacy.md","contentType":"file"},{"name":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","path":"src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","contentType":"file"},{"name":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","path":"src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","contentType":"file"},{"name":"ch07-05-separating-modules-into-different-files.md","path":"src/ch07-05-separating-modules-into-different-files.md","contentType":"file"},{"name":"ch08-00-common-collections.md","path":"src/ch08-00-common-collections.md","contentType":"file"},{"name":"ch08-01-vectors.md","path":"src/ch08-01-vectors.md","contentType":"file"},{"name":"ch08-02-strings.md","path":"src/ch08-02-strings.md","contentType":"file"},{"name":"ch08-03-hash-maps.md","path":"src/ch08-03-hash-maps.md","contentType":"file"},{"name":"ch09-00-error-handling.md","path":"src/ch09-00-error-handling.md","contentType":"file"},{"name":"ch09-01-unrecoverable-errors-with-panic.md","path":"src/ch09-01-unrecoverable-errors-with-panic.md","contentType":"file"},{"name":"ch09-02-recoverable-errors-with-result.md","path":"src/ch09-02-recoverable-errors-with-result.md","contentType":"file"},{"name":"ch09-03-to-panic-or-not-to-panic.md","path":"src/ch09-03-to-panic-or-not-to-panic.md","contentType":"file"},{"name":"ch10-00-generics.md","path":"src/ch10-00-generics.md","contentType":"file"},{"name":"ch10-01-syntax.md","path":"src/ch10-01-syntax.md","contentType":"file"},{"name":"ch10-02-traits.md","path":"src/ch10-02-traits.md","contentType":"file"},{"name":"ch10-03-lifetime-syntax.md","path":"src/ch10-03-lifetime-syntax.md","contentType":"file"},{"name":"ch11-00-testing.md","path":"src/ch11-00-testing.md","contentType":"file"},{"name":"ch11-01-writing-tests.md","path":"src/ch11-01-writing-tests.md","contentType":"file"},{"name":"ch11-02-running-tests.md","path":"src/ch11-02-running-tests.md","contentType":"file"},{"name":"ch11-03-test-organization.md","path":"src/ch11-03-test-organization.md","contentType":"file"},{"name":"ch12-00-an-io-project.md","path":"src/ch12-00-an-io-project.md","contentType":"file"},{"name":"ch12-01-accepting-command-line-arguments.md","path":"src/ch12-01-accepting-command-line-arguments.md","contentType":"file"},{"name":"ch12-02-reading-a-file.md","path":"src/ch12-02-reading-a-file.md","contentType":"file"},{"name":"ch12-03-improving-error-handling-and-modularity.md","path":"src/ch12-03-improving-error-handling-and-modularity.md","contentType":"file"},{"name":"ch12-04-testing-the-librarys-functionality.md","path":"src/ch12-04-testing-the-librarys-functionality.md","contentType":"file"},{"name":"ch12-05-working-with-environment-variables.md","path":"src/ch12-05-working-with-environment-variables.md","contentType":"file"},{"name":"ch12-06-writing-to-stderr-instead-of-stdout.md","path":"src/ch12-06-writing-to-stderr-instead-of-stdout.md","contentType":"file"},{"name":"ch13-00-functional-features.md","path":"src/ch13-00-functional-features.md","contentType":"file"},{"name":"ch13-01-closures.md","path":"src/ch13-01-closures.md","contentType":"file"},{"name":"ch13-02-iterators.md","path":"src/ch13-02-iterators.md","contentType":"file"},{"name":"ch13-03-improving-our-io-project.md","path":"src/ch13-03-improving-our-io-project.md","contentType":"file"},{"name":"ch13-04-performance.md","path":"src/ch13-04-performance.md","contentType":"file"},{"name":"ch14-00-more-about-cargo.md","path":"src/ch14-00-more-about-cargo.md","contentType":"file"},{"name":"ch14-01-release-profiles.md","path":"src/ch14-01-release-profiles.md","contentType":"file"},{"name":"ch14-02-publishing-to-crates-io.md","path":"src/ch14-02-publishing-to-crates-io.md","contentType":"file"},{"name":"ch14-03-cargo-workspaces.md","path":"src/ch14-03-cargo-workspaces.md","contentType":"file"},{"name":"ch14-04-installing-binaries.md","path":"src/ch14-04-installing-binaries.md","contentType":"file"},{"name":"ch14-05-extending-cargo.md","path":"src/ch14-05-extending-cargo.md","contentType":"file"},{"name":"ch15-00-smart-pointers.md","path":"src/ch15-00-smart-pointers.md","contentType":"file"},{"name":"ch15-01-box.md","path":"src/ch15-01-box.md","contentType":"file"},{"name":"ch15-02-deref.md","path":"src/ch15-02-deref.md","contentType":"file"},{"name":"ch15-03-drop.md","path":"src/ch15-03-drop.md","contentType":"file"},{"name":"ch15-04-rc.md","path":"src/ch15-04-rc.md","contentType":"file"},{"name":"ch15-05-interior-mutability.md","path":"src/ch15-05-interior-mutability.md","contentType":"file"},{"name":"ch15-06-reference-cycles.md","path":"src/ch15-06-reference-cycles.md","contentType":"file"},{"name":"ch16-00-concurrency.md","path":"src/ch16-00-concurrency.md","contentType":"file"},{"name":"ch16-01-threads.md","path":"src/ch16-01-threads.md","contentType":"file"},{"name":"ch16-02-message-passing.md","path":"src/ch16-02-message-passing.md","contentType":"file"},{"name":"ch16-03-shared-state.md","path":"src/ch16-03-shared-state.md","contentType":"file"},{"name":"ch16-04-extensible-concurrency-sync-and-send.md","path":"src/ch16-04-extensible-concurrency-sync-and-send.md","contentType":"file"},{"name":"ch17-00-oop.md","path":"src/ch17-00-oop.md","contentType":"file"},{"name":"ch17-01-what-is-oo.md","path":"src/ch17-01-what-is-oo.md","contentType":"file"},{"name":"ch17-02-trait-objects.md","path":"src/ch17-02-trait-objects.md","contentType":"file"},{"name":"ch17-03-oo-design-patterns.md","path":"src/ch17-03-oo-design-patterns.md","contentType":"file"},{"name":"ch18-00-patterns.md","path":"src/ch18-00-patterns.md","contentType":"file"},{"name":"ch18-01-all-the-places-for-patterns.md","path":"src/ch18-01-all-the-places-for-patterns.md","contentType":"file"},{"name":"ch18-02-refutability.md","path":"src/ch18-02-refutability.md","contentType":"file"},{"name":"ch18-03-pattern-syntax.md","path":"src/ch18-03-pattern-syntax.md","contentType":"file"},{"name":"ch19-00-advanced-features.md","path":"src/ch19-00-advanced-features.md","contentType":"file"},{"name":"ch19-01-unsafe-rust.md","path":"src/ch19-01-unsafe-rust.md","contentType":"file"},{"name":"ch19-03-advanced-traits.md","path":"src/ch19-03-advanced-traits.md","contentType":"file"},{"name":"ch19-04-advanced-types.md","path":"src/ch19-04-advanced-types.md","contentType":"file"},{"name":"ch19-05-advanced-functions-and-closures.md","path":"src/ch19-05-advanced-functions-and-closures.md","contentType":"file"},{"name":"ch19-06-macros.md","path":"src/ch19-06-macros.md","contentType":"file"},{"name":"ch20-00-final-project-a-web-server.md","path":"src/ch20-00-final-project-a-web-server.md","contentType":"file"},{"name":"ch20-01-single-threaded.md","path":"src/ch20-01-single-threaded.md","contentType":"file"},{"name":"ch20-02-multithreaded.md","path":"src/ch20-02-multithreaded.md","contentType":"file"},{"name":"ch20-03-graceful-shutdown-and-cleanup.md","path":"src/ch20-03-graceful-shutdown-and-cleanup.md","contentType":"file"},{"name":"foreword.md","path":"src/foreword.md","contentType":"file"},{"name":"title-page.md","path":"src/title-page.md","contentType":"file"}],"totalCount":106},"":{"items":[{"name":".cargo","path":".cargo","contentType":"directory"},{"name":".github","path":".github","contentType":"directory"},{"name":"2018-edition","path":"2018-edition","contentType":"directory"},{"name":"ci","path":"ci","contentType":"directory"},{"name":"dot","path":"dot","contentType":"directory"},{"name":"first-edition","path":"first-edition","contentType":"directory"},{"name":"listings","path":"listings","contentType":"directory"},{"name":"nostarch","path":"nostarch","contentType":"directory"},{"name":"redirects","path":"redirects","contentType":"directory"},{"name":"second-edition","path":"second-edition","contentType":"directory"},{"name":"src","path":"src","contentType":"directory"},{"name":"theme","path":"theme","contentType":"directory"},{"name":"tools","path":"tools","contentType":"directory"},{"name":".gitattributes","path":".gitattributes","contentType":"file"},{"name":".gitignore","path":".gitignore","contentType":"file"},{"name":"ADMIN_TASKS.md","path":"ADMIN_TASKS.md","contentType":"file"},{"name":"CONTRIBUTING.md","path":"CONTRIBUTING.md","contentType":"file"},{"name":"COPYRIGHT","path":"COPYRIGHT","contentType":"file"},{"name":"Cargo.lock","path":"Cargo.lock","contentType":"file"},{"name":"Cargo.toml","path":"Cargo.toml","contentType":"file"},{"name":"LICENSE-APACHE","path":"LICENSE-APACHE","contentType":"file"},{"name":"LICENSE-MIT","path":"LICENSE-MIT","contentType":"file"},{"name":"README.md","path":"README.md","contentType":"file"},{"name":"TODO.md","path":"TODO.md","contentType":"file"},{"name":"book.toml","path":"book.toml","contentType":"file"},{"name":"ferris.css","path":"ferris.css","contentType":"file"},{"name":"ferris.js","path":"ferris.js","contentType":"file"},{"name":"rust-toolchain","path":"rust-toolchain","contentType":"file"},{"name":"rustfmt.toml","path":"rustfmt.toml","contentType":"file"},{"name":"style-guide.md","path":"style-guide.md","contentType":"file"}],"totalCount":30}},"fileTreeProcessingTime":14.931268,"foldersToFetch":[],"reducedMotionEnabled":null,"repo":{"id":47854924,"defaultBranch":"main","name":"book","ownerLogin":"rust-lang","currentUserCanPush":false,"isFork":false,"isEmpty":false,"createdAt":"2015-12-11T22:49:49.000Z","ownerAvatar":"https://avatars.githubusercontent.com/u/5430905?v=4","public":true,"private":false,"isOrgOwned":true},"symbolsExpanded":false,"treeExpanded":true,"refInfo":{"name":"main","listCacheKey":"v0:1688046669.0","canEdit":false,"refType":"branch","currentOid":"72187f5cd0beaaa9c6f584156bcd88f921871e83"},"path":"src/ch15-06-reference-cycles.md","currentUser":null,"blob":{"rawLines":null,"stylingDirectives":null,"csv":null,"csvError":null,"dependabotInfo":{"showConfigurationBanner":false,"configFilePath":null,"networkDependabotPath":"/rust-lang/book/network/updates","dismissConfigurationNoticePath":"/settings/dismiss-notice/dependabot_configuration_notice","configurationNoticeDismissed":null,"repoAlertsPath":"/rust-lang/book/security/dependabot","repoSecurityAndAnalysisPath":"/rust-lang/book/settings/security_analysis","repoOwnerIsOrg":true,"currentUserCanAdminRepo":false},"displayName":"ch15-06-reference-cycles.md","displayUrl":"https://github.com/rust-lang/book/blob/main/src/ch15-06-reference-cycles.md?raw=true","headerInfo":{"blobSize":"15.3 KB","deleteInfo":{"deleteTooltip":"You must be signed in to make or propose changes"},"editInfo":{"editTooltip":"You must be signed in to make or propose changes"},"ghDesktopPath":"https://desktop.github.com","gitLfsPath":null,"onBranch":true,"shortPath":"beb2bc2","siteNavLoginPath":"/login?return_to=https%3A%2F%2Fgithub.com%2Frust-lang%2Fbook%2Fblob%2Fmain%2Fsrc%2Fch15-06-reference-cycles.md","isCSV":false,"isRichtext":true,"toc":[{"level":2,"text":"Reference Cycles Can Leak Memory","anchor":"reference-cycles-can-leak-memory","htmlText":"Reference Cycles Can Leak Memory"},{"level":3,"text":"Creating a Reference Cycle","anchor":"creating-a-reference-cycle","htmlText":"Creating a Reference Cycle"},{"level":3,"text":"Preventing Reference Cycles: Turning an Rc<T> into a Weak<T>","anchor":"preventing-reference-cycles-turning-an-rct-into-a-weakt","htmlText":"Preventing Reference Cycles: Turning an Rc&lt;T&gt; into a Weak&lt;T&gt;"},{"level":4,"text":"Creating a Tree Data Structure: a Node with Child Nodes","anchor":"creating-a-tree-data-structure-a-node-with-child-nodes","htmlText":"Creating a Tree Data Structure: a Node with Child Nodes"},{"level":4,"text":"Adding a Reference from a Child to Its Parent","anchor":"adding-a-reference-from-a-child-to-its-parent","htmlText":"Adding a Reference from a Child to Its Parent"},{"level":4,"text":"Visualizing Changes to strong_count and weak_count","anchor":"visualizing-changes-to-strong_count-and-weak_count","htmlText":"Visualizing Changes to strong_count and weak_count"},{"level":2,"text":"Summary","anchor":"summary","htmlText":"Summary"}],"lineInfo":{"truncatedLoc":"320","truncatedSloc":"251"},"mode":"file"},"image":false,"isCodeownersFile":null,"isPlain":false,"isValidLegacyIssueTemplate":false,"issueTemplateHelpUrl":"https://docs.github.com/articles/about-issue-and-pull-request-templates","issueTemplate":null,"discussionTemplate":null,"language":"Markdown","languageID":222,"large":false,"loggedIn":false,"newDiscussionPath":"/rust-lang/book/discussions/new","newIssuePath":"/rust-lang/book/issues/new","planSupportInfo":{"repoIsFork":null,"repoOwnedByCurrentUser":null,"requestFullPath":"/rust-lang/book/blob/main/src/ch15-06-reference-cycles.md","showFreeOrgGatedFeatureMessage":null,"showPlanSupportBanner":null,"upgradeDataAttributes":null,"upgradePath":null},"publishBannersInfo":{"dismissActionNoticePath":"/settings/dismiss-notice/publish_action_from_dockerfile","dismissStackNoticePath":"/settings/dismiss-notice/publish_stack_from_file","releasePath":"/rust-lang/book/releases/new?marketplace=true","showPublishActionBanner":false,"showPublishStackBanner":false},"renderImageOrRaw":false,"richText":"<article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><h2 tabindex=\"-1\" id=\"user-content-reference-cycles-can-leak-memory\" dir=\"auto\"><a class=\"heading-link\" href=\"#reference-cycles-can-leak-memory\">Reference Cycles Can Leak Memory<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">Rust’s memory safety guarantees make it difficult, but not impossible, to\naccidentally create memory that is never cleaned up (known as a <em>memory leak</em>).\nPreventing memory leaks entirely is not one of Rust’s guarantees, meaning\nmemory leaks are memory safe in Rust. We can see that Rust allows memory leaks\nby using <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>: it’s possible to create references where\nitems refer to each other in a cycle. This creates memory leaks because the\nreference count of each item in the cycle will never reach 0, and the values\nwill never be dropped.</p>\n<h3 tabindex=\"-1\" id=\"user-content-creating-a-reference-cycle\" dir=\"auto\"><a class=\"heading-link\" href=\"#creating-a-reference-cycle\">Creating a Reference Cycle<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">Let’s look at how a reference cycle might happen and how to prevent it,\nstarting with the definition of the <code>List</code> enum and a <code>tail</code> method in Listing\n15-25:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-25/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">25</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-25: A cons list definition that holds a\n<code>RefCell&lt;T&gt;</code> so we can modify what a <code>Cons</code> variant is referring to</span></p>\n<p dir=\"auto\">We’re using another variation of the <code>List</code> definition from Listing 15-5. The\nsecond element in the <code>Cons</code> variant is now <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, meaning that\ninstead of having the ability to modify the <code>i32</code> value as we did in Listing\n15-24, we want to modify the <code>List</code> value a <code>Cons</code> variant is pointing to.\nWe’re also adding a <code>tail</code> method to make it convenient for us to access the\nsecond item if we have a <code>Cons</code> variant.</p>\n<p dir=\"auto\">In Listing 15-26, we’re adding a <code>main</code> function that uses the definitions in\nListing 15-25. This code creates a list in <code>a</code> and a list in <code>b</code> that points to\nthe list in <code>a</code>. Then it modifies the list in <code>a</code> to point to <code>b</code>, creating a\nreference cycle. There are <code>println!</code> statements along the way to show what the\nreference counts are at various points in this process.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-26/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">26</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-26: Creating a reference cycle of two <code>List</code>\nvalues pointing to each other</span></p>\n<p dir=\"auto\">We create an <code>Rc&lt;List&gt;</code> instance holding a <code>List</code> value in the variable <code>a</code>\nwith an initial list of <code>5, Nil</code>. We then create an <code>Rc&lt;List&gt;</code> instance holding\nanother <code>List</code> value in the variable <code>b</code> that contains the value 10 and points\nto the list in <code>a</code>.</p>\n<p dir=\"auto\">We modify <code>a</code> so it points to <code>b</code> instead of <code>Nil</code>, creating a cycle. We do\nthat by using the <code>tail</code> method to get a reference to the <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>\nin <code>a</code>, which we put in the variable <code>link</code>. Then we use the <code>borrow_mut</code>\nmethod on the <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> to change the value inside from an <code>Rc&lt;List&gt;</code>\nthat holds a <code>Nil</code> value to the <code>Rc&lt;List&gt;</code> in <code>b</code>.</p>\n<p dir=\"auto\">When we run this code, keeping the last <code>println!</code> commented out for the\nmoment, we’ll get this output:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch15-smart-pointers/listing-15-26/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch15-smart-pointers/listing-15-26/output.txt}}</span></pre></div>\n<p dir=\"auto\">The reference count of the <code>Rc&lt;List&gt;</code> instances in both <code>a</code> and <code>b</code> are 2 after\nwe change the list in <code>a</code> to point to <code>b</code>. At the end of <code>main</code>, Rust drops the\nvariable <code>b</code>, which decreases the reference count of the <code>b</code> <code>Rc&lt;List&gt;</code> instance\nfrom 2 to 1. The memory that <code>Rc&lt;List&gt;</code> has on the heap won’t be dropped at\nthis point, because its reference count is 1, not 0. Then Rust drops <code>a</code>, which\ndecreases the reference count of the <code>a</code> <code>Rc&lt;List&gt;</code> instance from 2 to 1 as\nwell. This instance’s memory can’t be dropped either, because the other\n<code>Rc&lt;List&gt;</code> instance still refers to it. The memory allocated to the list will\nremain uncollected forever. To visualize this reference cycle, we’ve created a\ndiagram in Figure 15-4.</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/rust-lang/book/blob/main/src/img/trpl15-04.svg\"><img alt=\"Reference cycle of lists\" src=\"/rust-lang/book/raw/main/src/img/trpl15-04.svg\" style=\"max-width: 100%;\"></a></p>\n<p dir=\"auto\"><span>Figure 15-4: A reference cycle of lists <code>a</code> and <code>b</code>\npointing to each other</span></p>\n<p dir=\"auto\">If you uncomment the last <code>println!</code> and run the program, Rust will try to\nprint this cycle with <code>a</code> pointing to <code>b</code> pointing to <code>a</code> and so forth until it\noverflows the stack.</p>\n<p dir=\"auto\">Compared to a real-world program, the consequences of creating a reference cycle\nin this example aren’t very dire: right after we create the reference cycle,\nthe program ends. However, if a more complex program allocated lots of memory\nin a cycle and held onto it for a long time, the program would use more memory\nthan it needed and might overwhelm the system, causing it to run out of\navailable memory.</p>\n<p dir=\"auto\">Creating reference cycles is not easily done, but it’s not impossible either.\nIf you have <code>RefCell&lt;T&gt;</code> values that contain <code>Rc&lt;T&gt;</code> values or similar nested\ncombinations of types with interior mutability and reference counting, you must\nensure that you don’t create cycles; you can’t rely on Rust to catch them.\nCreating a reference cycle would be a logic bug in your program that you should\nuse automated tests, code reviews, and other software development practices to\nminimize.</p>\n<p dir=\"auto\">Another solution for avoiding reference cycles is reorganizing your data\nstructures so that some references express ownership and some references don’t.\nAs a result, you can have cycles made up of some ownership relationships and\nsome non-ownership relationships, and only the ownership relationships affect\nwhether or not a value can be dropped. In Listing 15-25, we always want <code>Cons</code>\nvariants to own their list, so reorganizing the data structure isn’t possible.\nLet’s look at an example using graphs made up of parent nodes and child nodes\nto see when non-ownership relationships are an appropriate way to prevent\nreference cycles.</p>\n<h3 tabindex=\"-1\" id=\"user-content-preventing-reference-cycles-turning-an-rct-into-a-weakt\" dir=\"auto\"><a class=\"heading-link\" href=\"#preventing-reference-cycles-turning-an-rct-into-a-weakt\">Preventing Reference Cycles: Turning an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">So far, we’ve demonstrated that calling <code>Rc::clone</code> increases the\n<code>strong_count</code> of an <code>Rc&lt;T&gt;</code> instance, and an <code>Rc&lt;T&gt;</code> instance is only cleaned\nup if its <code>strong_count</code> is 0. You can also create a <em>weak reference</em> to the\nvalue within an <code>Rc&lt;T&gt;</code> instance by calling <code>Rc::downgrade</code> and passing a\nreference to the <code>Rc&lt;T&gt;</code>. Strong references are how you can share ownership of\nan <code>Rc&lt;T&gt;</code> instance. Weak references don’t express an ownership relationship,\nand their count doesn’t affect when an <code>Rc&lt;T&gt;</code> instance is cleaned up. They\nwon’t cause a reference cycle because any cycle involving some weak references\nwill be broken once the strong reference count of values involved is 0.</p>\n<p dir=\"auto\">When you call <code>Rc::downgrade</code>, you get a smart pointer of type <code>Weak&lt;T&gt;</code>.\nInstead of increasing the <code>strong_count</code> in the <code>Rc&lt;T&gt;</code> instance by 1, calling\n<code>Rc::downgrade</code> increases the <code>weak_count</code> by 1. The <code>Rc&lt;T&gt;</code> type uses\n<code>weak_count</code> to keep track of how many <code>Weak&lt;T&gt;</code> references exist, similar to\n<code>strong_count</code>. The difference is the <code>weak_count</code> doesn’t need to be 0 for the\n<code>Rc&lt;T&gt;</code> instance to be cleaned up.</p>\n<p dir=\"auto\">Because the value that <code>Weak&lt;T&gt;</code> references might have been dropped, to do\nanything with the value that a <code>Weak&lt;T&gt;</code> is pointing to, you must make sure the\nvalue still exists. Do this by calling the <code>upgrade</code> method on a <code>Weak&lt;T&gt;</code>\ninstance, which will return an <code>Option&lt;Rc&lt;T&gt;&gt;</code>. You’ll get a result of <code>Some</code>\nif the <code>Rc&lt;T&gt;</code> value has not been dropped yet and a result of <code>None</code> if the\n<code>Rc&lt;T&gt;</code> value has been dropped. Because <code>upgrade</code> returns an <code>Option&lt;Rc&lt;T&gt;&gt;</code>,\nRust will ensure that the <code>Some</code> case and the <code>None</code> case are handled, and\nthere won’t be an invalid pointer.</p>\n<p dir=\"auto\">As an example, rather than using a list whose items know only about the next\nitem, we’ll create a tree whose items know about their children items <em>and</em>\ntheir parent items.</p>\n<h4 tabindex=\"-1\" id=\"user-content-creating-a-tree-data-structure-a-node-with-child-nodes\" dir=\"auto\"><a class=\"heading-link\" href=\"#creating-a-tree-data-structure-a-node-with-child-nodes\">Creating a Tree Data Structure: a <code>Node</code> with Child Nodes<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">To start, we’ll build a tree with nodes that know about their child nodes.\nWe’ll create a struct named <code>Node</code> that holds its own <code>i32</code> value as well as\nreferences to its children <code>Node</code> values:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-27/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">27</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">We want a <code>Node</code> to own its children, and we want to share that ownership with\nvariables so we can access each <code>Node</code> in the tree directly. To do this, we\ndefine the <code>Vec&lt;T&gt;</code> items to be values of type <code>Rc&lt;Node&gt;</code>. We also want to\nmodify which nodes are children of another node, so we have a <code>RefCell&lt;T&gt;</code> in\n<code>children</code> around the <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>\n<p dir=\"auto\">Next, we’ll use our struct definition and create one <code>Node</code> instance named\n<code>leaf</code> with the value 3 and no children, and another instance named <code>branch</code>\nwith the value 5 and <code>leaf</code> as one of its children, as shown in Listing 15-27:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-27/src/main.rs:there}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">27</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>there<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-27: Creating a <code>leaf</code> node with no children\nand a <code>branch</code> node with <code>leaf</code> as one of its children</span></p>\n<p dir=\"auto\">We clone the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> and store that in <code>branch</code>, meaning the\n<code>Node</code> in <code>leaf</code> now has two owners: <code>leaf</code> and <code>branch</code>. We can get from\n<code>branch</code> to <code>leaf</code> through <code>branch.children</code>, but there’s no way to get from\n<code>leaf</code> to <code>branch</code>. The reason is that <code>leaf</code> has no reference to <code>branch</code> and\ndoesn’t know they’re related. We want <code>leaf</code> to know that <code>branch</code> is its\nparent. We’ll do that next.</p>\n<h4 tabindex=\"-1\" id=\"user-content-adding-a-reference-from-a-child-to-its-parent\" dir=\"auto\"><a class=\"heading-link\" href=\"#adding-a-reference-from-a-child-to-its-parent\">Adding a Reference from a Child to Its Parent<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">To make the child node aware of its parent, we need to add a <code>parent</code> field to\nour <code>Node</code> struct definition. The trouble is in deciding what the type of\n<code>parent</code> should be. We know it can’t contain an <code>Rc&lt;T&gt;</code>, because that would\ncreate a reference cycle with <code>leaf.parent</code> pointing to <code>branch</code> and\n<code>branch.children</code> pointing to <code>leaf</code>, which would cause their <code>strong_count</code>\nvalues to never be 0.</p>\n<p dir=\"auto\">Thinking about the relationships another way, a parent node should own its\nchildren: if a parent node is dropped, its child nodes should be dropped as\nwell. However, a child should not own its parent: if we drop a child node, the\nparent should still exist. This is a case for weak references!</p>\n<p dir=\"auto\">So instead of <code>Rc&lt;T&gt;</code>, we’ll make the type of <code>parent</code> use <code>Weak&lt;T&gt;</code>,\nspecifically a <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Now our <code>Node</code> struct definition looks\nlike this:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-28/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">28</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">A node will be able to refer to its parent node but doesn’t own its parent.\nIn Listing 15-28, we update <code>main</code> to use this new definition so the <code>leaf</code>\nnode will have a way to refer to its parent, <code>branch</code>:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-28/src/main.rs:there}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">28</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>there<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-28: A <code>leaf</code> node with a weak reference to its\nparent node <code>branch</code></span></p>\n<p dir=\"auto\">Creating the <code>leaf</code> node looks similar to Listing 15-27 with the exception of\nthe <code>parent</code> field: <code>leaf</code> starts out without a parent, so we create a new,\nempty <code>Weak&lt;Node&gt;</code> reference instance.</p>\n<p dir=\"auto\">At this point, when we try to get a reference to the parent of <code>leaf</code> by using\nthe <code>upgrade</code> method, we get a <code>None</code> value. We see this in the output from the\nfirst <code>println!</code> statement:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"leaf parent = None\"><pre lang=\"text\" class=\"notranslate\"><code>leaf parent = None\n</code></pre></div>\n<p dir=\"auto\">When we create the <code>branch</code> node, it will also have a new <code>Weak&lt;Node&gt;</code>\nreference in the <code>parent</code> field, because <code>branch</code> doesn’t have a parent node.\nWe still have <code>leaf</code> as one of the children of <code>branch</code>. Once we have the\n<code>Node</code> instance in <code>branch</code>, we can modify <code>leaf</code> to give it a <code>Weak&lt;Node&gt;</code>\nreference to its parent. We use the <code>borrow_mut</code> method on the\n<code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> in the <code>parent</code> field of <code>leaf</code>, and then we use the\n<code>Rc::downgrade</code> function to create a <code>Weak&lt;Node&gt;</code> reference to <code>branch</code> from\nthe <code>Rc&lt;Node&gt;</code> in <code>branch.</code></p>\n<p dir=\"auto\">When we print the parent of <code>leaf</code> again, this time we’ll get a <code>Some</code> variant\nholding <code>branch</code>: now <code>leaf</code> can access its parent! When we print <code>leaf</code>, we\nalso avoid the cycle that eventually ended in a stack overflow like we had in\nListing 15-26; the <code>Weak&lt;Node&gt;</code> references are printed as <code>(Weak)</code>:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [] } }] } })\"><pre lang=\"text\" class=\"notranslate\"><code>leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [] } }] } })\n</code></pre></div>\n<p dir=\"auto\">The lack of infinite output indicates that this code didn’t create a reference\ncycle. We can also tell this by looking at the values we get from calling\n<code>Rc::strong_count</code> and <code>Rc::weak_count</code>.</p>\n<h4 tabindex=\"-1\" id=\"user-content-visualizing-changes-to-strong_count-and-weak_count\" dir=\"auto\"><a class=\"heading-link\" href=\"#visualizing-changes-to-strong_count-and-weak_count\">Visualizing Changes to <code>strong_count</code> and <code>weak_count</code><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">Let’s look at how the <code>strong_count</code> and <code>weak_count</code> values of the <code>Rc&lt;Node&gt;</code>\ninstances change by creating a new inner scope and moving the creation of\n<code>branch</code> into that scope. By doing so, we can see what happens when <code>branch</code> is\ncreated and then dropped when it goes out of scope. The modifications are shown\nin Listing 15-29:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-29/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">29</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-29: Creating <code>branch</code> in an inner scope and\nexamining strong and weak reference counts</span></p>\n<p dir=\"auto\">After <code>leaf</code> is created, its <code>Rc&lt;Node&gt;</code> has a strong count of 1 and a weak\ncount of 0. In the inner scope, we create <code>branch</code> and associate it with\n<code>leaf</code>, at which point when we print the counts, the <code>Rc&lt;Node&gt;</code> in <code>branch</code>\nwill have a strong count of 1 and a weak count of 1 (for <code>leaf.parent</code> pointing\nto <code>branch</code> with a <code>Weak&lt;Node&gt;</code>). When we print the counts in <code>leaf</code>, we’ll see\nit will have a strong count of 2, because <code>branch</code> now has a clone of the\n<code>Rc&lt;Node&gt;</code> of <code>leaf</code> stored in <code>branch.children</code>, but will still have a weak\ncount of 0.</p>\n<p dir=\"auto\">When the inner scope ends, <code>branch</code> goes out of scope and the strong count of\nthe <code>Rc&lt;Node&gt;</code> decreases to 0, so its <code>Node</code> is dropped. The weak count of 1\nfrom <code>leaf.parent</code> has no bearing on whether or not <code>Node</code> is dropped, so we\ndon’t get any memory leaks!</p>\n<p dir=\"auto\">If we try to access the parent of <code>leaf</code> after the end of the scope, we’ll get\n<code>None</code> again. At the end of the program, the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> has a strong\ncount of 1 and a weak count of 0, because the variable <code>leaf</code> is now the only\nreference to the <code>Rc&lt;Node&gt;</code> again.</p>\n<p dir=\"auto\">All of the logic that manages the counts and value dropping is built into\n<code>Rc&lt;T&gt;</code> and <code>Weak&lt;T&gt;</code> and their implementations of the <code>Drop</code> trait. By\nspecifying that the relationship from a child to its parent should be a\n<code>Weak&lt;T&gt;</code> reference in the definition of <code>Node</code>, you’re able to have parent\nnodes point to child nodes and vice versa without creating a reference cycle\nand memory leaks.</p>\n<h2 tabindex=\"-1\" id=\"user-content-summary\" dir=\"auto\"><a class=\"heading-link\" href=\"#summary\">Summary<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">This chapter covered how to use smart pointers to make different guarantees and\ntrade-offs from those Rust makes by default with regular references. The\n<code>Box&lt;T&gt;</code> type has a known size and points to data allocated on the heap. The\n<code>Rc&lt;T&gt;</code> type keeps track of the number of references to data on the heap so\nthat data can have multiple owners. The <code>RefCell&lt;T&gt;</code> type with its interior\nmutability gives us a type that we can use when we need an immutable type but\nneed to change an inner value of that type; it also enforces the borrowing\nrules at runtime instead of at compile time.</p>\n<p dir=\"auto\">Also discussed were the <code>Deref</code> and <code>Drop</code> traits, which enable a lot of the\nfunctionality of smart pointers. We explored reference cycles that can cause\nmemory leaks and how to prevent them using <code>Weak&lt;T&gt;</code>.</p>\n<p dir=\"auto\">If this chapter has piqued your interest and you want to implement your own\nsmart pointers, check out <a href=\"/rust-lang/book/blob/main/nomicon/index.html\">“The Rustonomicon”</a> for more useful\ninformation.</p>\n<p dir=\"auto\">Next, we’ll talk about concurrency in Rust. You’ll even learn about a few new\nsmart pointers.</p>\n</article>","renderedFileInfo":null,"shortPath":null,"tabSize":8,"topBannersInfo":{"overridingGlobalFundingFile":false,"globalPreferredFundingPath":null,"repoOwner":"rust-lang","repoName":"book","showInvalidCitationWarning":false,"citationHelpUrl":"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/about-citation-files","showDependabotConfigurationBanner":false,"actionsOnboardingTip":null},"truncated":false,"viewable":true,"workflowRedirectUrl":null,"symbols":{"timedOut":false,"notAnalyzed":true,"symbols":[]}},"copilotInfo":null,"csrf_tokens":{"/rust-lang/book/branches":{"post":"rLXIW2palEgWlfYaeK3Bq6a8jALkW8OcqgBAI_naEzJB8SdeYpiBuN4fCKVU0TAsCGNqPqsoASRxz0fFzo_VIw"},"/repos/preferences":{"post":"MWrosKvZBxSSGTv6p4g-Letlsu_ln5wzQIbcocPLT9LxbAF8o3AUYftAdUH6aZvJ9ufYl5GmglFntQfEOfr06Q"}}},"title":"book/src/ch15-06-reference-cycles.md at main · rust-lang/book"}
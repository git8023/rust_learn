{"payload":{"allShortcutsEnabled":false,"fileTree":{"src":{"items":[{"name":"img","path":"src/img","contentType":"directory"},{"name":"SUMMARY.md","path":"src/SUMMARY.md","contentType":"file"},{"name":"appendix-00.md","path":"src/appendix-00.md","contentType":"file"},{"name":"appendix-01-keywords.md","path":"src/appendix-01-keywords.md","contentType":"file"},{"name":"appendix-02-operators.md","path":"src/appendix-02-operators.md","contentType":"file"},{"name":"appendix-03-derivable-traits.md","path":"src/appendix-03-derivable-traits.md","contentType":"file"},{"name":"appendix-04-useful-development-tools.md","path":"src/appendix-04-useful-development-tools.md","contentType":"file"},{"name":"appendix-05-editions.md","path":"src/appendix-05-editions.md","contentType":"file"},{"name":"appendix-06-translation.md","path":"src/appendix-06-translation.md","contentType":"file"},{"name":"appendix-07-nightly-rust.md","path":"src/appendix-07-nightly-rust.md","contentType":"file"},{"name":"ch00-00-introduction.md","path":"src/ch00-00-introduction.md","contentType":"file"},{"name":"ch01-00-getting-started.md","path":"src/ch01-00-getting-started.md","contentType":"file"},{"name":"ch01-01-installation.md","path":"src/ch01-01-installation.md","contentType":"file"},{"name":"ch01-02-hello-world.md","path":"src/ch01-02-hello-world.md","contentType":"file"},{"name":"ch01-03-hello-cargo.md","path":"src/ch01-03-hello-cargo.md","contentType":"file"},{"name":"ch02-00-guessing-game-tutorial.md","path":"src/ch02-00-guessing-game-tutorial.md","contentType":"file"},{"name":"ch03-00-common-programming-concepts.md","path":"src/ch03-00-common-programming-concepts.md","contentType":"file"},{"name":"ch03-01-variables-and-mutability.md","path":"src/ch03-01-variables-and-mutability.md","contentType":"file"},{"name":"ch03-02-data-types.md","path":"src/ch03-02-data-types.md","contentType":"file"},{"name":"ch03-03-how-functions-work.md","path":"src/ch03-03-how-functions-work.md","contentType":"file"},{"name":"ch03-04-comments.md","path":"src/ch03-04-comments.md","contentType":"file"},{"name":"ch03-05-control-flow.md","path":"src/ch03-05-control-flow.md","contentType":"file"},{"name":"ch04-00-understanding-ownership.md","path":"src/ch04-00-understanding-ownership.md","contentType":"file"},{"name":"ch04-01-what-is-ownership.md","path":"src/ch04-01-what-is-ownership.md","contentType":"file"},{"name":"ch04-02-references-and-borrowing.md","path":"src/ch04-02-references-and-borrowing.md","contentType":"file"},{"name":"ch04-03-slices.md","path":"src/ch04-03-slices.md","contentType":"file"},{"name":"ch05-00-structs.md","path":"src/ch05-00-structs.md","contentType":"file"},{"name":"ch05-01-defining-structs.md","path":"src/ch05-01-defining-structs.md","contentType":"file"},{"name":"ch05-02-example-structs.md","path":"src/ch05-02-example-structs.md","contentType":"file"},{"name":"ch05-03-method-syntax.md","path":"src/ch05-03-method-syntax.md","contentType":"file"},{"name":"ch06-00-enums.md","path":"src/ch06-00-enums.md","contentType":"file"},{"name":"ch06-01-defining-an-enum.md","path":"src/ch06-01-defining-an-enum.md","contentType":"file"},{"name":"ch06-02-match.md","path":"src/ch06-02-match.md","contentType":"file"},{"name":"ch06-03-if-let.md","path":"src/ch06-03-if-let.md","contentType":"file"},{"name":"ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","path":"src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","contentType":"file"},{"name":"ch07-01-packages-and-crates.md","path":"src/ch07-01-packages-and-crates.md","contentType":"file"},{"name":"ch07-02-defining-modules-to-control-scope-and-privacy.md","path":"src/ch07-02-defining-modules-to-control-scope-and-privacy.md","contentType":"file"},{"name":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","path":"src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","contentType":"file"},{"name":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","path":"src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","contentType":"file"},{"name":"ch07-05-separating-modules-into-different-files.md","path":"src/ch07-05-separating-modules-into-different-files.md","contentType":"file"},{"name":"ch08-00-common-collections.md","path":"src/ch08-00-common-collections.md","contentType":"file"},{"name":"ch08-01-vectors.md","path":"src/ch08-01-vectors.md","contentType":"file"},{"name":"ch08-02-strings.md","path":"src/ch08-02-strings.md","contentType":"file"},{"name":"ch08-03-hash-maps.md","path":"src/ch08-03-hash-maps.md","contentType":"file"},{"name":"ch09-00-error-handling.md","path":"src/ch09-00-error-handling.md","contentType":"file"},{"name":"ch09-01-unrecoverable-errors-with-panic.md","path":"src/ch09-01-unrecoverable-errors-with-panic.md","contentType":"file"},{"name":"ch09-02-recoverable-errors-with-result.md","path":"src/ch09-02-recoverable-errors-with-result.md","contentType":"file"},{"name":"ch09-03-to-panic-or-not-to-panic.md","path":"src/ch09-03-to-panic-or-not-to-panic.md","contentType":"file"},{"name":"ch10-00-generics.md","path":"src/ch10-00-generics.md","contentType":"file"},{"name":"ch10-01-syntax.md","path":"src/ch10-01-syntax.md","contentType":"file"},{"name":"ch10-02-traits.md","path":"src/ch10-02-traits.md","contentType":"file"},{"name":"ch10-03-lifetime-syntax.md","path":"src/ch10-03-lifetime-syntax.md","contentType":"file"},{"name":"ch11-00-testing.md","path":"src/ch11-00-testing.md","contentType":"file"},{"name":"ch11-01-writing-tests.md","path":"src/ch11-01-writing-tests.md","contentType":"file"},{"name":"ch11-02-running-tests.md","path":"src/ch11-02-running-tests.md","contentType":"file"},{"name":"ch11-03-test-organization.md","path":"src/ch11-03-test-organization.md","contentType":"file"},{"name":"ch12-00-an-io-project.md","path":"src/ch12-00-an-io-project.md","contentType":"file"},{"name":"ch12-01-accepting-command-line-arguments.md","path":"src/ch12-01-accepting-command-line-arguments.md","contentType":"file"},{"name":"ch12-02-reading-a-file.md","path":"src/ch12-02-reading-a-file.md","contentType":"file"},{"name":"ch12-03-improving-error-handling-and-modularity.md","path":"src/ch12-03-improving-error-handling-and-modularity.md","contentType":"file"},{"name":"ch12-04-testing-the-librarys-functionality.md","path":"src/ch12-04-testing-the-librarys-functionality.md","contentType":"file"},{"name":"ch12-05-working-with-environment-variables.md","path":"src/ch12-05-working-with-environment-variables.md","contentType":"file"},{"name":"ch12-06-writing-to-stderr-instead-of-stdout.md","path":"src/ch12-06-writing-to-stderr-instead-of-stdout.md","contentType":"file"},{"name":"ch13-00-functional-features.md","path":"src/ch13-00-functional-features.md","contentType":"file"},{"name":"ch13-01-closures.md","path":"src/ch13-01-closures.md","contentType":"file"},{"name":"ch13-02-iterators.md","path":"src/ch13-02-iterators.md","contentType":"file"},{"name":"ch13-03-improving-our-io-project.md","path":"src/ch13-03-improving-our-io-project.md","contentType":"file"},{"name":"ch13-04-performance.md","path":"src/ch13-04-performance.md","contentType":"file"},{"name":"ch14-00-more-about-cargo.md","path":"src/ch14-00-more-about-cargo.md","contentType":"file"},{"name":"ch14-01-release-profiles.md","path":"src/ch14-01-release-profiles.md","contentType":"file"},{"name":"ch14-02-publishing-to-crates-io.md","path":"src/ch14-02-publishing-to-crates-io.md","contentType":"file"},{"name":"ch14-03-cargo-workspaces.md","path":"src/ch14-03-cargo-workspaces.md","contentType":"file"},{"name":"ch14-04-installing-binaries.md","path":"src/ch14-04-installing-binaries.md","contentType":"file"},{"name":"ch14-05-extending-cargo.md","path":"src/ch14-05-extending-cargo.md","contentType":"file"},{"name":"ch15-00-smart-pointers.md","path":"src/ch15-00-smart-pointers.md","contentType":"file"},{"name":"ch15-01-box.md","path":"src/ch15-01-box.md","contentType":"file"},{"name":"ch15-02-deref.md","path":"src/ch15-02-deref.md","contentType":"file"},{"name":"ch15-03-drop.md","path":"src/ch15-03-drop.md","contentType":"file"},{"name":"ch15-04-rc.md","path":"src/ch15-04-rc.md","contentType":"file"},{"name":"ch15-05-interior-mutability.md","path":"src/ch15-05-interior-mutability.md","contentType":"file"},{"name":"ch15-06-reference-cycles.md","path":"src/ch15-06-reference-cycles.md","contentType":"file"},{"name":"ch16-00-concurrency.md","path":"src/ch16-00-concurrency.md","contentType":"file"},{"name":"ch16-01-threads.md","path":"src/ch16-01-threads.md","contentType":"file"},{"name":"ch16-02-message-passing.md","path":"src/ch16-02-message-passing.md","contentType":"file"},{"name":"ch16-03-shared-state.md","path":"src/ch16-03-shared-state.md","contentType":"file"},{"name":"ch16-04-extensible-concurrency-sync-and-send.md","path":"src/ch16-04-extensible-concurrency-sync-and-send.md","contentType":"file"},{"name":"ch17-00-oop.md","path":"src/ch17-00-oop.md","contentType":"file"},{"name":"ch17-01-what-is-oo.md","path":"src/ch17-01-what-is-oo.md","contentType":"file"},{"name":"ch17-02-trait-objects.md","path":"src/ch17-02-trait-objects.md","contentType":"file"},{"name":"ch17-03-oo-design-patterns.md","path":"src/ch17-03-oo-design-patterns.md","contentType":"file"},{"name":"ch18-00-patterns.md","path":"src/ch18-00-patterns.md","contentType":"file"},{"name":"ch18-01-all-the-places-for-patterns.md","path":"src/ch18-01-all-the-places-for-patterns.md","contentType":"file"},{"name":"ch18-02-refutability.md","path":"src/ch18-02-refutability.md","contentType":"file"},{"name":"ch18-03-pattern-syntax.md","path":"src/ch18-03-pattern-syntax.md","contentType":"file"},{"name":"ch19-00-advanced-features.md","path":"src/ch19-00-advanced-features.md","contentType":"file"},{"name":"ch19-01-unsafe-rust.md","path":"src/ch19-01-unsafe-rust.md","contentType":"file"},{"name":"ch19-03-advanced-traits.md","path":"src/ch19-03-advanced-traits.md","contentType":"file"},{"name":"ch19-04-advanced-types.md","path":"src/ch19-04-advanced-types.md","contentType":"file"},{"name":"ch19-05-advanced-functions-and-closures.md","path":"src/ch19-05-advanced-functions-and-closures.md","contentType":"file"},{"name":"ch19-06-macros.md","path":"src/ch19-06-macros.md","contentType":"file"},{"name":"ch20-00-final-project-a-web-server.md","path":"src/ch20-00-final-project-a-web-server.md","contentType":"file"},{"name":"ch20-01-single-threaded.md","path":"src/ch20-01-single-threaded.md","contentType":"file"},{"name":"ch20-02-multithreaded.md","path":"src/ch20-02-multithreaded.md","contentType":"file"},{"name":"ch20-03-graceful-shutdown-and-cleanup.md","path":"src/ch20-03-graceful-shutdown-and-cleanup.md","contentType":"file"},{"name":"foreword.md","path":"src/foreword.md","contentType":"file"},{"name":"title-page.md","path":"src/title-page.md","contentType":"file"}],"totalCount":106},"":{"items":[{"name":".cargo","path":".cargo","contentType":"directory"},{"name":".github","path":".github","contentType":"directory"},{"name":"2018-edition","path":"2018-edition","contentType":"directory"},{"name":"ci","path":"ci","contentType":"directory"},{"name":"dot","path":"dot","contentType":"directory"},{"name":"first-edition","path":"first-edition","contentType":"directory"},{"name":"listings","path":"listings","contentType":"directory"},{"name":"nostarch","path":"nostarch","contentType":"directory"},{"name":"redirects","path":"redirects","contentType":"directory"},{"name":"second-edition","path":"second-edition","contentType":"directory"},{"name":"src","path":"src","contentType":"directory"},{"name":"theme","path":"theme","contentType":"directory"},{"name":"tools","path":"tools","contentType":"directory"},{"name":".gitattributes","path":".gitattributes","contentType":"file"},{"name":".gitignore","path":".gitignore","contentType":"file"},{"name":"ADMIN_TASKS.md","path":"ADMIN_TASKS.md","contentType":"file"},{"name":"CONTRIBUTING.md","path":"CONTRIBUTING.md","contentType":"file"},{"name":"COPYRIGHT","path":"COPYRIGHT","contentType":"file"},{"name":"Cargo.lock","path":"Cargo.lock","contentType":"file"},{"name":"Cargo.toml","path":"Cargo.toml","contentType":"file"},{"name":"LICENSE-APACHE","path":"LICENSE-APACHE","contentType":"file"},{"name":"LICENSE-MIT","path":"LICENSE-MIT","contentType":"file"},{"name":"README.md","path":"README.md","contentType":"file"},{"name":"TODO.md","path":"TODO.md","contentType":"file"},{"name":"book.toml","path":"book.toml","contentType":"file"},{"name":"ferris.css","path":"ferris.css","contentType":"file"},{"name":"ferris.js","path":"ferris.js","contentType":"file"},{"name":"rust-toolchain","path":"rust-toolchain","contentType":"file"},{"name":"rustfmt.toml","path":"rustfmt.toml","contentType":"file"},{"name":"style-guide.md","path":"style-guide.md","contentType":"file"}],"totalCount":30}},"fileTreeProcessingTime":13.708253000000001,"foldersToFetch":[],"reducedMotionEnabled":null,"repo":{"id":47854924,"defaultBranch":"main","name":"book","ownerLogin":"rust-lang","currentUserCanPush":false,"isFork":false,"isEmpty":false,"createdAt":"2015-12-11T22:49:49.000Z","ownerAvatar":"https://avatars.githubusercontent.com/u/5430905?v=4","public":true,"private":false,"isOrgOwned":true},"symbolsExpanded":false,"treeExpanded":true,"refInfo":{"name":"main","listCacheKey":"v0:1688046669.0","canEdit":false,"refType":"branch","currentOid":"72187f5cd0beaaa9c6f584156bcd88f921871e83"},"path":"src/ch06-01-defining-an-enum.md","currentUser":null,"blob":{"rawLines":null,"stylingDirectives":null,"csv":null,"csvError":null,"dependabotInfo":{"showConfigurationBanner":false,"configFilePath":null,"networkDependabotPath":"/rust-lang/book/network/updates","dismissConfigurationNoticePath":"/settings/dismiss-notice/dependabot_configuration_notice","configurationNoticeDismissed":null,"repoAlertsPath":"/rust-lang/book/security/dependabot","repoSecurityAndAnalysisPath":"/rust-lang/book/settings/security_analysis","repoOwnerIsOrg":true,"currentUserCanAdminRepo":false},"displayName":"ch06-01-defining-an-enum.md","displayUrl":"https://github.com/rust-lang/book/blob/main/src/ch06-01-defining-an-enum.md?raw=true","headerInfo":{"blobSize":"15.3 KB","deleteInfo":{"deleteTooltip":"You must be signed in to make or propose changes"},"editInfo":{"editTooltip":"You must be signed in to make or propose changes"},"ghDesktopPath":"https://desktop.github.com","gitLfsPath":null,"onBranch":true,"shortPath":"eacd091","siteNavLoginPath":"/login?return_to=https%3A%2F%2Fgithub.com%2Frust-lang%2Fbook%2Fblob%2Fmain%2Fsrc%2Fch06-01-defining-an-enum.md","isCSV":false,"isRichtext":true,"toc":[{"level":2,"text":"Defining an Enum","anchor":"defining-an-enum","htmlText":"Defining an Enum"},{"level":3,"text":"Enum Values","anchor":"enum-values","htmlText":"Enum Values"},{"level":3,"text":"The Option Enum and Its Advantages Over Null Values","anchor":"the-option-enum-and-its-advantages-over-null-values","htmlText":"The Option Enum and Its Advantages Over Null Values"}],"lineInfo":{"truncatedLoc":"324","truncatedSloc":"259"},"mode":"file"},"image":false,"isCodeownersFile":null,"isPlain":false,"isValidLegacyIssueTemplate":false,"issueTemplateHelpUrl":"https://docs.github.com/articles/about-issue-and-pull-request-templates","issueTemplate":null,"discussionTemplate":null,"language":"Markdown","languageID":222,"large":false,"loggedIn":false,"newDiscussionPath":"/rust-lang/book/discussions/new","newIssuePath":"/rust-lang/book/issues/new","planSupportInfo":{"repoIsFork":null,"repoOwnedByCurrentUser":null,"requestFullPath":"/rust-lang/book/blob/main/src/ch06-01-defining-an-enum.md","showFreeOrgGatedFeatureMessage":null,"showPlanSupportBanner":null,"upgradeDataAttributes":null,"upgradePath":null},"publishBannersInfo":{"dismissActionNoticePath":"/settings/dismiss-notice/publish_action_from_dockerfile","dismissStackNoticePath":"/settings/dismiss-notice/publish_stack_from_file","releasePath":"/rust-lang/book/releases/new?marketplace=true","showPublishActionBanner":false,"showPublishStackBanner":false},"renderImageOrRaw":false,"richText":"<article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><h2 tabindex=\"-1\" id=\"user-content-defining-an-enum\" dir=\"auto\"><a class=\"heading-link\" href=\"#defining-an-enum\">Defining an Enum<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">Where structs give you a way of grouping together related fields and data, like\na <code>Rectangle</code> with its <code>width</code> and <code>height</code>, enums give you a way of saying a\nvalue is one of a possible set of values. For example, we may want to say that\n<code>Rectangle</code> is one of a set of possible shapes that also includes <code>Circle</code> and\n<code>Triangle</code>. To do this, Rust allows us to encode these possibilities as an enum.</p>\n<p dir=\"auto\">Let’s look at a situation we might want to express in code and see why enums\nare useful and more appropriate than structs in this case. Say we need to work\nwith IP addresses. Currently, two major standards are used for IP addresses:\nversion four and version six. Because these are the only possibilities for an\nIP address that our program will come across, we can <em>enumerate</em> all possible\nvariants, which is where enumeration gets its name.</p>\n<p dir=\"auto\">Any IP address can be either a version four or a version six address, but not\nboth at the same time. That property of IP addresses makes the enum data\nstructure appropriate because an enum value can only be one of its variants.\nBoth version four and version six addresses are still fundamentally IP\naddresses, so they should be treated as the same type when the code is handling\nsituations that apply to any kind of IP address.</p>\n<p dir=\"auto\">We can express this concept in code by defining an <code>IpAddrKind</code> enumeration and\nlisting the possible kinds an IP address can be, <code>V4</code> and <code>V6</code>. These are the\nvariants of the enum:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:def}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-<span class=\"pl-c1\">01</span>-defining-enums/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>def<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><code>IpAddrKind</code> is now a custom data type that we can use elsewhere in our code.</p>\n<h3 tabindex=\"-1\" id=\"user-content-enum-values\" dir=\"auto\"><a class=\"heading-link\" href=\"#enum-values\">Enum Values<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">We can create instances of each of the two variants of <code>IpAddrKind</code> like this:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:instance}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-<span class=\"pl-c1\">01</span>-defining-enums/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>instance<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">Note that the variants of the enum are namespaced under its identifier, and we\nuse a double colon to separate the two. This is useful because now both values\n<code>IpAddrKind::V4</code> and <code>IpAddrKind::V6</code> are of the same type: <code>IpAddrKind</code>. We\ncan then, for instance, define a function that takes any <code>IpAddrKind</code>:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:fn}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-<span class=\"pl-c1\">01</span>-defining-enums/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span><span class=\"pl-k\">fn</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">And we can call this function with either variant:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:fn_call}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-<span class=\"pl-c1\">01</span>-defining-enums/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>fn_call<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">Using enums has even more advantages. Thinking more about our IP address type,\nat the moment we don’t have a way to store the actual IP address <em>data</em>; we\nonly know what <em>kind</em> it is. Given that you just learned about structs in\nChapter 5, you might be tempted to tackle this problem with structs as shown in\nListing 6-1.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-01/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-<span class=\"pl-c1\">06</span>-<span class=\"pl-c1\">01</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 6-1: Storing the data and <code>IpAddrKind</code> variant of\nan IP address using a <code>struct</code></span></p>\n<p dir=\"auto\">Here, we’ve defined a struct <code>IpAddr</code> that has two fields: a <code>kind</code> field that\nis of type <code>IpAddrKind</code> (the enum we defined previously) and an <code>address</code> field\nof type <code>String</code>. We have two instances of this struct. The first is <code>home</code>,\nand it has the value <code>IpAddrKind::V4</code> as its <code>kind</code> with associated address\ndata of <code>127.0.0.1</code>. The second instance is <code>loopback</code>. It has the other\nvariant of <code>IpAddrKind</code> as its <code>kind</code> value, <code>V6</code>, and has address <code>::1</code>\nassociated with it. We’ve used a struct to bundle the <code>kind</code> and <code>address</code>\nvalues together, so now the variant is associated with the value.</p>\n<p dir=\"auto\">However, representing the same concept using just an enum is more concise:\nrather than an enum inside a struct, we can put data directly into each enum\nvariant. This new definition of the <code>IpAddr</code> enum says that both <code>V4</code> and <code>V6</code>\nvariants will have associated <code>String</code> values:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-02-enum-with-data/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-<span class=\"pl-c1\">02</span>-enum-with-data/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">We attach data to each variant of the enum directly, so there is no need for an\nextra struct. Here, it’s also easier to see another detail of how enums work:\nthe name of each enum variant that we define also becomes a function that\nconstructs an instance of the enum. That is, <code>IpAddr::V4()</code> is a function call\nthat takes a <code>String</code> argument and returns an instance of the <code>IpAddr</code> type. We\nautomatically get this constructor function defined as a result of defining the\nenum.</p>\n<p dir=\"auto\">There’s another advantage to using an enum rather than a struct: each variant\ncan have different types and amounts of associated data. Version four IP\naddresses will always have four numeric components that will have values\nbetween 0 and 255. If we wanted to store <code>V4</code> addresses as four <code>u8</code> values but\nstill express <code>V6</code> addresses as one <code>String</code> value, we wouldn’t be able to with\na struct. Enums handle this case with ease:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-03-variants-with-different-data/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-<span class=\"pl-c1\">03</span>-variants-with-different-data/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">We’ve shown several different ways to define data structures to store version\nfour and version six IP addresses. However, as it turns out, wanting to store\nIP addresses and encode which kind they are is so common that <a href=\"/rust-lang/book/blob/main/std/net/enum.IpAddr.html\">the standard\nlibrary has a definition we can use!</a> Let’s look at how\nthe standard library defines <code>IpAddr</code>: it has the exact enum and variants that\nwe’ve defined and used, but it embeds the address data inside the variants in\nthe form of two different structs, which are defined differently for each\nvariant:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"struct Ipv4Addr {\n    // --snip--\n}\n\nstruct Ipv6Addr {\n    // --snip--\n}\n\nenum IpAddr {\n    V4(Ipv4Addr),\n    V6(Ipv6Addr),\n}\"><pre><span class=\"pl-k\">struct</span> <span class=\"pl-smi\">Ipv4Addr</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c\">// --snip--</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">struct</span> <span class=\"pl-smi\">Ipv6Addr</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c\">// --snip--</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">enum</span> <span class=\"pl-smi\">IpAddr</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-v\">V4</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">Ipv4Addr</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-v\">V6</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">Ipv6Addr</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">,</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">This code illustrates that you can put any kind of data inside an enum variant:\nstrings, numeric types, or structs, for example. You can even include another\nenum! Also, standard library types are often not much more complicated than\nwhat you might come up with.</p>\n<p dir=\"auto\">Note that even though the standard library contains a definition for <code>IpAddr</code>,\nwe can still create and use our own definition without conflict because we\nhaven’t brought the standard library’s definition into our scope. We’ll talk\nmore about bringing types into scope in Chapter 7.</p>\n<p dir=\"auto\">Let’s look at another example of an enum in Listing 6-2: this one has a wide\nvariety of types embedded in its variants.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-02/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-<span class=\"pl-c1\">06</span>-<span class=\"pl-c1\">02</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 6-2: A <code>Message</code> enum whose variants each store\ndifferent amounts and types of values</span></p>\n<p dir=\"auto\">This enum has four variants with different types:</p>\n<ul dir=\"auto\">\n<li><code>Quit</code> has no data associated with it at all.</li>\n<li><code>Move</code> has named fields, like a struct does.</li>\n<li><code>Write</code> includes a single <code>String</code>.</li>\n<li><code>ChangeColor</code> includes three <code>i32</code> values.</li>\n</ul>\n<p dir=\"auto\">Defining an enum with variants such as the ones in Listing 6-2 is similar to\ndefining different kinds of struct definitions, except the enum doesn’t use the\n<code>struct</code> keyword and all the variants are grouped together under the <code>Message</code>\ntype. The following structs could hold the same data that the preceding enum\nvariants hold:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-04-structs-similar-to-message-enum/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-<span class=\"pl-c1\">04</span>-structs-similar-to-message-enum/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">But if we used the different structs, each of which has its own type, we\ncouldn’t as easily define a function to take any of these kinds of messages as\nwe could with the <code>Message</code> enum defined in Listing 6-2, which is a single type.</p>\n<p dir=\"auto\">There is one more similarity between enums and structs: just as we’re able to\ndefine methods on structs using <code>impl</code>, we’re also able to define methods on\nenums. Here’s a method named <code>call</code> that we could define on our <code>Message</code> enum:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-05-methods-on-enums/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-<span class=\"pl-c1\">05</span>-methods-on-enums/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">The body of the method would use <code>self</code> to get the value that we called the\nmethod on. In this example, we’ve created a variable <code>m</code> that has the value\n<code>Message::Write(String::from(\"hello\"))</code>, and that is what <code>self</code> will be in the\nbody of the <code>call</code> method when <code>m.call()</code> runs.</p>\n<p dir=\"auto\">Let’s look at another enum in the standard library that is very common and\nuseful: <code>Option</code>.</p>\n<h3 tabindex=\"-1\" id=\"user-content-the-option-enum-and-its-advantages-over-null-values\" dir=\"auto\"><a class=\"heading-link\" href=\"#the-option-enum-and-its-advantages-over-null-values\">The <code>Option</code> Enum and Its Advantages Over Null Values<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">This section explores a case study of <code>Option</code>, which is another enum defined\nby the standard library. The <code>Option</code> type encodes the very common scenario in\nwhich a value could be something or it could be nothing.</p>\n<p dir=\"auto\">For example, if you request the first item in a non-empty list, you would get\na value. If you request the first item in an empty list, you would get nothing.\nExpressing this concept in terms of the type system means the compiler can\ncheck whether you’ve handled all the cases you should be handling; this\nfunctionality can prevent bugs that are extremely common in other programming\nlanguages.</p>\n<p dir=\"auto\">Programming language design is often thought of in terms of which features you\ninclude, but the features you exclude are important too. Rust doesn’t have the\nnull feature that many other languages have. <em>Null</em> is a value that means there\nis no value there. In languages with null, variables can always be in one of\ntwo states: null or not-null.</p>\n<p dir=\"auto\">In his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony\nHoare, the inventor of null, has this to say:</p>\n<blockquote>\n<p dir=\"auto\">I call it my billion-dollar mistake. At that time, I was designing the first\ncomprehensive type system for references in an object-oriented language. My\ngoal was to ensure that all use of references should be absolutely safe, with\nchecking performed automatically by the compiler. But I couldn’t resist the\ntemptation to put in a null reference, simply because it was so easy to\nimplement. This has led to innumerable errors, vulnerabilities, and system\ncrashes, which have probably caused a billion dollars of pain and damage in\nthe last forty years.</p>\n</blockquote>\n<p dir=\"auto\">The problem with null values is that if you try to use a null value as a\nnot-null value, you’ll get an error of some kind. Because this null or not-null\nproperty is pervasive, it’s extremely easy to make this kind of error.</p>\n<p dir=\"auto\">However, the concept that null is trying to express is still a useful one: a\nnull is a value that is currently invalid or absent for some reason.</p>\n<p dir=\"auto\">The problem isn’t really with the concept but with the particular\nimplementation. As such, Rust does not have nulls, but it does have an enum\nthat can encode the concept of a value being present or absent. This enum is\n<code>Option&lt;T&gt;</code>, and it is <a href=\"/rust-lang/book/blob/main/std/option/enum.Option.html\">defined by the standard library</a>\nas follows:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"enum Option&lt;T&gt; {\n    None,\n    Some(T),\n}\"><pre><span class=\"pl-k\">enum</span> <span class=\"pl-smi\">Option</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-v\">None</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-v\">Some</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">,</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">The <code>Option&lt;T&gt;</code> enum is so useful that it’s even included in the prelude; you\ndon’t need to bring it into scope explicitly. Its variants are also included in\nthe prelude: you can use <code>Some</code> and <code>None</code> directly without the <code>Option::</code>\nprefix. The <code>Option&lt;T&gt;</code> enum is still just a regular enum, and <code>Some(T)</code> and\n<code>None</code> are still variants of type <code>Option&lt;T&gt;</code>.</p>\n<p dir=\"auto\">The <code>&lt;T&gt;</code> syntax is a feature of Rust we haven’t talked about yet. It’s a\ngeneric type parameter, and we’ll cover generics in more detail in Chapter 10.\nFor now, all you need to know is that <code>&lt;T&gt;</code> means that the <code>Some</code> variant of\nthe <code>Option</code> enum can hold one piece of data of any type, and that each\nconcrete type that gets used in place of <code>T</code> makes the overall <code>Option&lt;T&gt;</code> type\na different type. Here are some examples of using <code>Option</code> values to hold\nnumber types and string types:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-06-option-examples/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-<span class=\"pl-c1\">06</span>-option-examples/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">The type of <code>some_number</code> is <code>Option&lt;i32&gt;</code>. The type of <code>some_char</code> is\n<code>Option&lt;char&gt;</code>, which is a different type. Rust can infer these types because\nwe’ve specified a value inside the <code>Some</code> variant. For <code>absent_number</code>, Rust\nrequires us to annotate the overall <code>Option</code> type: the compiler can’t infer the\ntype that the corresponding <code>Some</code> variant will hold by looking only at a\n<code>None</code> value. Here, we tell Rust that we mean for <code>absent_number</code> to be of type\n<code>Option&lt;i32&gt;</code>.</p>\n<p dir=\"auto\">When we have a <code>Some</code> value, we know that a value is present and the value is\nheld within the <code>Some</code>. When we have a <code>None</code> value, in some sense it means the\nsame thing as null: we don’t have a valid value. So why is having <code>Option&lt;T&gt;</code>\nany better than having null?</p>\n<p dir=\"auto\">In short, because <code>Option&lt;T&gt;</code> and <code>T</code> (where <code>T</code> can be any type) are different\ntypes, the compiler won’t let us use an <code>Option&lt;T&gt;</code> value as if it were\ndefinitely a valid value. For example, this code won’t compile, because it’s\ntrying to add an <code>i8</code> to an <code>Option&lt;i8&gt;</code>:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-07-cant-use-option-directly/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-<span class=\"pl-c1\">07</span>-cant-use-option-directly/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">If we run this code, we get an error message like this one:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch06-enums-and-pattern-matching/no-listing-07-cant-use-option-directly/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch06-enums-and-pattern-matching/no-listing-07-cant-use-option-directly/output.txt}}</span></pre></div>\n<p dir=\"auto\">Intense! In effect, this error message means that Rust doesn’t understand how\nto add an <code>i8</code> and an <code>Option&lt;i8&gt;</code>, because they’re different types. When we\nhave a value of a type like <code>i8</code> in Rust, the compiler will ensure that we\nalways have a valid value. We can proceed confidently without having to check\nfor null before using that value. Only when we have an <code>Option&lt;i8&gt;</code> (or\nwhatever type of value we’re working with) do we have to worry about possibly\nnot having a value, and the compiler will make sure we handle that case before\nusing the value.</p>\n<p dir=\"auto\">In other words, you have to convert an <code>Option&lt;T&gt;</code> to a <code>T</code> before you can\nperform <code>T</code> operations with it. Generally, this helps catch one of the most\ncommon issues with null: assuming that something isn’t null when it actually is.</p>\n<p dir=\"auto\">Eliminating the risk of incorrectly assuming a not-null value helps you to be\nmore confident in your code. In order to have a value that can possibly be\nnull, you must explicitly opt in by making the type of that value <code>Option&lt;T&gt;</code>.\nThen, when you use that value, you are required to explicitly handle the case\nwhen the value is null. Everywhere that a value has a type that isn’t an\n<code>Option&lt;T&gt;</code>, you <em>can</em> safely assume that the value isn’t null. This was a\ndeliberate design decision for Rust to limit null’s pervasiveness and increase\nthe safety of Rust code.</p>\n<p dir=\"auto\">So how do you get the <code>T</code> value out of a <code>Some</code> variant when you have a value\nof type <code>Option&lt;T&gt;</code> so that you can use that value? The <code>Option&lt;T&gt;</code> enum has a\nlarge number of methods that are useful in a variety of situations; you can\ncheck them out in <a href=\"/rust-lang/book/blob/main/std/option/enum.Option.html\">its documentation</a>. Becoming familiar\nwith the methods on <code>Option&lt;T&gt;</code> will be extremely useful in your journey with\nRust.</p>\n<p dir=\"auto\">In general, in order to use an <code>Option&lt;T&gt;</code> value, you want to have code that\nwill handle each variant. You want some code that will run only when you have a\n<code>Some(T)</code> value, and this code is allowed to use the inner <code>T</code>. You want some\nother code to run only if you have a <code>None</code> value, and that code doesn’t have a\n<code>T</code> value available. The <code>match</code> expression is a control flow construct that\ndoes just this when used with enums: it will run different code depending on\nwhich variant of the enum it has, and that code can use the data inside the\nmatching value.</p>\n</article>","renderedFileInfo":null,"shortPath":null,"tabSize":8,"topBannersInfo":{"overridingGlobalFundingFile":false,"globalPreferredFundingPath":null,"repoOwner":"rust-lang","repoName":"book","showInvalidCitationWarning":false,"citationHelpUrl":"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/about-citation-files","showDependabotConfigurationBanner":false,"actionsOnboardingTip":null},"truncated":false,"viewable":true,"workflowRedirectUrl":null,"symbols":{"timedOut":false,"notAnalyzed":true,"symbols":[]}},"copilotInfo":null,"csrf_tokens":{"/rust-lang/book/branches":{"post":"DV7hH7x_6HWQ0AIM6gxoyoXmW3vZcpBFFupHDm4bwig1-RkWAirZ_IFaC9R7amHazOzQQP8dAlG-LX-3O3-UvA"},"/repos/preferences":{"post":"EF5iEUbSG-8lzVxj1igNlXs1Zc_uEozm4cawdPIBowrJJXd4_5gq-kMM_DrC0mMeRwfETJ5ZBifw3oKnuan20w"}}},"title":"book/src/ch06-01-defining-an-enum.md at main · rust-lang/book"}
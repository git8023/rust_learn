{"payload":{"allShortcutsEnabled":false,"fileTree":{"src":{"items":[{"name":"img","path":"src/img","contentType":"directory"},{"name":"SUMMARY.md","path":"src/SUMMARY.md","contentType":"file"},{"name":"appendix-00.md","path":"src/appendix-00.md","contentType":"file"},{"name":"appendix-01-keywords.md","path":"src/appendix-01-keywords.md","contentType":"file"},{"name":"appendix-02-operators.md","path":"src/appendix-02-operators.md","contentType":"file"},{"name":"appendix-03-derivable-traits.md","path":"src/appendix-03-derivable-traits.md","contentType":"file"},{"name":"appendix-04-useful-development-tools.md","path":"src/appendix-04-useful-development-tools.md","contentType":"file"},{"name":"appendix-05-editions.md","path":"src/appendix-05-editions.md","contentType":"file"},{"name":"appendix-06-translation.md","path":"src/appendix-06-translation.md","contentType":"file"},{"name":"appendix-07-nightly-rust.md","path":"src/appendix-07-nightly-rust.md","contentType":"file"},{"name":"ch00-00-introduction.md","path":"src/ch00-00-introduction.md","contentType":"file"},{"name":"ch01-00-getting-started.md","path":"src/ch01-00-getting-started.md","contentType":"file"},{"name":"ch01-01-installation.md","path":"src/ch01-01-installation.md","contentType":"file"},{"name":"ch01-02-hello-world.md","path":"src/ch01-02-hello-world.md","contentType":"file"},{"name":"ch01-03-hello-cargo.md","path":"src/ch01-03-hello-cargo.md","contentType":"file"},{"name":"ch02-00-guessing-game-tutorial.md","path":"src/ch02-00-guessing-game-tutorial.md","contentType":"file"},{"name":"ch03-00-common-programming-concepts.md","path":"src/ch03-00-common-programming-concepts.md","contentType":"file"},{"name":"ch03-01-variables-and-mutability.md","path":"src/ch03-01-variables-and-mutability.md","contentType":"file"},{"name":"ch03-02-data-types.md","path":"src/ch03-02-data-types.md","contentType":"file"},{"name":"ch03-03-how-functions-work.md","path":"src/ch03-03-how-functions-work.md","contentType":"file"},{"name":"ch03-04-comments.md","path":"src/ch03-04-comments.md","contentType":"file"},{"name":"ch03-05-control-flow.md","path":"src/ch03-05-control-flow.md","contentType":"file"},{"name":"ch04-00-understanding-ownership.md","path":"src/ch04-00-understanding-ownership.md","contentType":"file"},{"name":"ch04-01-what-is-ownership.md","path":"src/ch04-01-what-is-ownership.md","contentType":"file"},{"name":"ch04-02-references-and-borrowing.md","path":"src/ch04-02-references-and-borrowing.md","contentType":"file"},{"name":"ch04-03-slices.md","path":"src/ch04-03-slices.md","contentType":"file"},{"name":"ch05-00-structs.md","path":"src/ch05-00-structs.md","contentType":"file"},{"name":"ch05-01-defining-structs.md","path":"src/ch05-01-defining-structs.md","contentType":"file"},{"name":"ch05-02-example-structs.md","path":"src/ch05-02-example-structs.md","contentType":"file"},{"name":"ch05-03-method-syntax.md","path":"src/ch05-03-method-syntax.md","contentType":"file"},{"name":"ch06-00-enums.md","path":"src/ch06-00-enums.md","contentType":"file"},{"name":"ch06-01-defining-an-enum.md","path":"src/ch06-01-defining-an-enum.md","contentType":"file"},{"name":"ch06-02-match.md","path":"src/ch06-02-match.md","contentType":"file"},{"name":"ch06-03-if-let.md","path":"src/ch06-03-if-let.md","contentType":"file"},{"name":"ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","path":"src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","contentType":"file"},{"name":"ch07-01-packages-and-crates.md","path":"src/ch07-01-packages-and-crates.md","contentType":"file"},{"name":"ch07-02-defining-modules-to-control-scope-and-privacy.md","path":"src/ch07-02-defining-modules-to-control-scope-and-privacy.md","contentType":"file"},{"name":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","path":"src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","contentType":"file"},{"name":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","path":"src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","contentType":"file"},{"name":"ch07-05-separating-modules-into-different-files.md","path":"src/ch07-05-separating-modules-into-different-files.md","contentType":"file"},{"name":"ch08-00-common-collections.md","path":"src/ch08-00-common-collections.md","contentType":"file"},{"name":"ch08-01-vectors.md","path":"src/ch08-01-vectors.md","contentType":"file"},{"name":"ch08-02-strings.md","path":"src/ch08-02-strings.md","contentType":"file"},{"name":"ch08-03-hash-maps.md","path":"src/ch08-03-hash-maps.md","contentType":"file"},{"name":"ch09-00-error-handling.md","path":"src/ch09-00-error-handling.md","contentType":"file"},{"name":"ch09-01-unrecoverable-errors-with-panic.md","path":"src/ch09-01-unrecoverable-errors-with-panic.md","contentType":"file"},{"name":"ch09-02-recoverable-errors-with-result.md","path":"src/ch09-02-recoverable-errors-with-result.md","contentType":"file"},{"name":"ch09-03-to-panic-or-not-to-panic.md","path":"src/ch09-03-to-panic-or-not-to-panic.md","contentType":"file"},{"name":"ch10-00-generics.md","path":"src/ch10-00-generics.md","contentType":"file"},{"name":"ch10-01-syntax.md","path":"src/ch10-01-syntax.md","contentType":"file"},{"name":"ch10-02-traits.md","path":"src/ch10-02-traits.md","contentType":"file"},{"name":"ch10-03-lifetime-syntax.md","path":"src/ch10-03-lifetime-syntax.md","contentType":"file"},{"name":"ch11-00-testing.md","path":"src/ch11-00-testing.md","contentType":"file"},{"name":"ch11-01-writing-tests.md","path":"src/ch11-01-writing-tests.md","contentType":"file"},{"name":"ch11-02-running-tests.md","path":"src/ch11-02-running-tests.md","contentType":"file"},{"name":"ch11-03-test-organization.md","path":"src/ch11-03-test-organization.md","contentType":"file"},{"name":"ch12-00-an-io-project.md","path":"src/ch12-00-an-io-project.md","contentType":"file"},{"name":"ch12-01-accepting-command-line-arguments.md","path":"src/ch12-01-accepting-command-line-arguments.md","contentType":"file"},{"name":"ch12-02-reading-a-file.md","path":"src/ch12-02-reading-a-file.md","contentType":"file"},{"name":"ch12-03-improving-error-handling-and-modularity.md","path":"src/ch12-03-improving-error-handling-and-modularity.md","contentType":"file"},{"name":"ch12-04-testing-the-librarys-functionality.md","path":"src/ch12-04-testing-the-librarys-functionality.md","contentType":"file"},{"name":"ch12-05-working-with-environment-variables.md","path":"src/ch12-05-working-with-environment-variables.md","contentType":"file"},{"name":"ch12-06-writing-to-stderr-instead-of-stdout.md","path":"src/ch12-06-writing-to-stderr-instead-of-stdout.md","contentType":"file"},{"name":"ch13-00-functional-features.md","path":"src/ch13-00-functional-features.md","contentType":"file"},{"name":"ch13-01-closures.md","path":"src/ch13-01-closures.md","contentType":"file"},{"name":"ch13-02-iterators.md","path":"src/ch13-02-iterators.md","contentType":"file"},{"name":"ch13-03-improving-our-io-project.md","path":"src/ch13-03-improving-our-io-project.md","contentType":"file"},{"name":"ch13-04-performance.md","path":"src/ch13-04-performance.md","contentType":"file"},{"name":"ch14-00-more-about-cargo.md","path":"src/ch14-00-more-about-cargo.md","contentType":"file"},{"name":"ch14-01-release-profiles.md","path":"src/ch14-01-release-profiles.md","contentType":"file"},{"name":"ch14-02-publishing-to-crates-io.md","path":"src/ch14-02-publishing-to-crates-io.md","contentType":"file"},{"name":"ch14-03-cargo-workspaces.md","path":"src/ch14-03-cargo-workspaces.md","contentType":"file"},{"name":"ch14-04-installing-binaries.md","path":"src/ch14-04-installing-binaries.md","contentType":"file"},{"name":"ch14-05-extending-cargo.md","path":"src/ch14-05-extending-cargo.md","contentType":"file"},{"name":"ch15-00-smart-pointers.md","path":"src/ch15-00-smart-pointers.md","contentType":"file"},{"name":"ch15-01-box.md","path":"src/ch15-01-box.md","contentType":"file"},{"name":"ch15-02-deref.md","path":"src/ch15-02-deref.md","contentType":"file"},{"name":"ch15-03-drop.md","path":"src/ch15-03-drop.md","contentType":"file"},{"name":"ch15-04-rc.md","path":"src/ch15-04-rc.md","contentType":"file"},{"name":"ch15-05-interior-mutability.md","path":"src/ch15-05-interior-mutability.md","contentType":"file"},{"name":"ch15-06-reference-cycles.md","path":"src/ch15-06-reference-cycles.md","contentType":"file"},{"name":"ch16-00-concurrency.md","path":"src/ch16-00-concurrency.md","contentType":"file"},{"name":"ch16-01-threads.md","path":"src/ch16-01-threads.md","contentType":"file"},{"name":"ch16-02-message-passing.md","path":"src/ch16-02-message-passing.md","contentType":"file"},{"name":"ch16-03-shared-state.md","path":"src/ch16-03-shared-state.md","contentType":"file"},{"name":"ch16-04-extensible-concurrency-sync-and-send.md","path":"src/ch16-04-extensible-concurrency-sync-and-send.md","contentType":"file"},{"name":"ch17-00-oop.md","path":"src/ch17-00-oop.md","contentType":"file"},{"name":"ch17-01-what-is-oo.md","path":"src/ch17-01-what-is-oo.md","contentType":"file"},{"name":"ch17-02-trait-objects.md","path":"src/ch17-02-trait-objects.md","contentType":"file"},{"name":"ch17-03-oo-design-patterns.md","path":"src/ch17-03-oo-design-patterns.md","contentType":"file"},{"name":"ch18-00-patterns.md","path":"src/ch18-00-patterns.md","contentType":"file"},{"name":"ch18-01-all-the-places-for-patterns.md","path":"src/ch18-01-all-the-places-for-patterns.md","contentType":"file"},{"name":"ch18-02-refutability.md","path":"src/ch18-02-refutability.md","contentType":"file"},{"name":"ch18-03-pattern-syntax.md","path":"src/ch18-03-pattern-syntax.md","contentType":"file"},{"name":"ch19-00-advanced-features.md","path":"src/ch19-00-advanced-features.md","contentType":"file"},{"name":"ch19-01-unsafe-rust.md","path":"src/ch19-01-unsafe-rust.md","contentType":"file"},{"name":"ch19-03-advanced-traits.md","path":"src/ch19-03-advanced-traits.md","contentType":"file"},{"name":"ch19-04-advanced-types.md","path":"src/ch19-04-advanced-types.md","contentType":"file"},{"name":"ch19-05-advanced-functions-and-closures.md","path":"src/ch19-05-advanced-functions-and-closures.md","contentType":"file"},{"name":"ch19-06-macros.md","path":"src/ch19-06-macros.md","contentType":"file"},{"name":"ch20-00-final-project-a-web-server.md","path":"src/ch20-00-final-project-a-web-server.md","contentType":"file"},{"name":"ch20-01-single-threaded.md","path":"src/ch20-01-single-threaded.md","contentType":"file"},{"name":"ch20-02-multithreaded.md","path":"src/ch20-02-multithreaded.md","contentType":"file"},{"name":"ch20-03-graceful-shutdown-and-cleanup.md","path":"src/ch20-03-graceful-shutdown-and-cleanup.md","contentType":"file"},{"name":"foreword.md","path":"src/foreword.md","contentType":"file"},{"name":"title-page.md","path":"src/title-page.md","contentType":"file"}],"totalCount":106},"":{"items":[{"name":".cargo","path":".cargo","contentType":"directory"},{"name":".github","path":".github","contentType":"directory"},{"name":"2018-edition","path":"2018-edition","contentType":"directory"},{"name":"ci","path":"ci","contentType":"directory"},{"name":"dot","path":"dot","contentType":"directory"},{"name":"first-edition","path":"first-edition","contentType":"directory"},{"name":"listings","path":"listings","contentType":"directory"},{"name":"nostarch","path":"nostarch","contentType":"directory"},{"name":"redirects","path":"redirects","contentType":"directory"},{"name":"second-edition","path":"second-edition","contentType":"directory"},{"name":"src","path":"src","contentType":"directory"},{"name":"theme","path":"theme","contentType":"directory"},{"name":"tools","path":"tools","contentType":"directory"},{"name":".gitattributes","path":".gitattributes","contentType":"file"},{"name":".gitignore","path":".gitignore","contentType":"file"},{"name":"ADMIN_TASKS.md","path":"ADMIN_TASKS.md","contentType":"file"},{"name":"CONTRIBUTING.md","path":"CONTRIBUTING.md","contentType":"file"},{"name":"COPYRIGHT","path":"COPYRIGHT","contentType":"file"},{"name":"Cargo.lock","path":"Cargo.lock","contentType":"file"},{"name":"Cargo.toml","path":"Cargo.toml","contentType":"file"},{"name":"LICENSE-APACHE","path":"LICENSE-APACHE","contentType":"file"},{"name":"LICENSE-MIT","path":"LICENSE-MIT","contentType":"file"},{"name":"README.md","path":"README.md","contentType":"file"},{"name":"TODO.md","path":"TODO.md","contentType":"file"},{"name":"book.toml","path":"book.toml","contentType":"file"},{"name":"ferris.css","path":"ferris.css","contentType":"file"},{"name":"ferris.js","path":"ferris.js","contentType":"file"},{"name":"rust-toolchain","path":"rust-toolchain","contentType":"file"},{"name":"rustfmt.toml","path":"rustfmt.toml","contentType":"file"},{"name":"style-guide.md","path":"style-guide.md","contentType":"file"}],"totalCount":30}},"fileTreeProcessingTime":17.975037,"foldersToFetch":[],"reducedMotionEnabled":null,"repo":{"id":47854924,"defaultBranch":"main","name":"book","ownerLogin":"rust-lang","currentUserCanPush":false,"isFork":false,"isEmpty":false,"createdAt":"2015-12-11T22:49:49.000Z","ownerAvatar":"https://avatars.githubusercontent.com/u/5430905?v=4","public":true,"private":false,"isOrgOwned":true},"symbolsExpanded":false,"treeExpanded":true,"refInfo":{"name":"main","listCacheKey":"v0:1688046669.0","canEdit":false,"refType":"branch","currentOid":"72187f5cd0beaaa9c6f584156bcd88f921871e83"},"path":"src/ch20-02-multithreaded.md","currentUser":null,"blob":{"rawLines":null,"stylingDirectives":null,"csv":null,"csvError":null,"dependabotInfo":{"showConfigurationBanner":false,"configFilePath":null,"networkDependabotPath":"/rust-lang/book/network/updates","dismissConfigurationNoticePath":"/settings/dismiss-notice/dependabot_configuration_notice","configurationNoticeDismissed":null,"repoAlertsPath":"/rust-lang/book/security/dependabot","repoSecurityAndAnalysisPath":"/rust-lang/book/settings/security_analysis","repoOwnerIsOrg":true,"currentUserCanAdminRepo":false},"displayName":"ch20-02-multithreaded.md","displayUrl":"https://github.com/rust-lang/book/blob/main/src/ch20-02-multithreaded.md?raw=true","headerInfo":{"blobSize":"32.2 KB","deleteInfo":{"deleteTooltip":"You must be signed in to make or propose changes"},"editInfo":{"editTooltip":"You must be signed in to make or propose changes"},"ghDesktopPath":"https://desktop.github.com","gitLfsPath":null,"onBranch":true,"shortPath":"5a4a50a","siteNavLoginPath":"/login?return_to=https%3A%2F%2Fgithub.com%2Frust-lang%2Fbook%2Fblob%2Fmain%2Fsrc%2Fch20-02-multithreaded.md","isCSV":false,"isRichtext":true,"toc":[{"level":2,"text":"Turning Our Single-Threaded Server into a Multithreaded Server","anchor":"turning-our-single-threaded-server-into-a-multithreaded-server","htmlText":"Turning Our Single-Threaded Server into a Multithreaded Server"},{"level":3,"text":"Simulating a Slow Request in the Current Server Implementation","anchor":"simulating-a-slow-request-in-the-current-server-implementation","htmlText":"Simulating a Slow Request in the Current Server Implementation"},{"level":3,"text":"Improving Throughput with a Thread Pool","anchor":"improving-throughput-with-a-thread-pool","htmlText":"Improving Throughput with a Thread Pool"},{"level":4,"text":"Spawning a Thread for Each Request","anchor":"spawning-a-thread-for-each-request","htmlText":"Spawning a Thread for Each Request"},{"level":4,"text":"Creating a Finite Number of Threads","anchor":"creating-a-finite-number-of-threads","htmlText":"Creating a Finite Number of Threads"},{"level":4,"text":"Building ThreadPool Using Compiler Driven Development","anchor":"building-threadpool-using-compiler-driven-development","htmlText":"Building ThreadPool Using Compiler Driven Development"},{"level":4,"text":"Validating the Number of Threads in new","anchor":"validating-the-number-of-threads-in-new","htmlText":"Validating the Number of Threads in new"},{"level":4,"text":"Creating Space to Store the Threads","anchor":"creating-space-to-store-the-threads","htmlText":"Creating Space to Store the Threads"},{"level":4,"text":"A Worker Struct Responsible for Sending Code from the ThreadPool to a Thread","anchor":"a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread","htmlText":"A Worker Struct Responsible for Sending Code from the ThreadPool to a Thread"},{"level":4,"text":"Sending Requests to Threads via Channels","anchor":"sending-requests-to-threads-via-channels","htmlText":"Sending Requests to Threads via Channels"},{"level":4,"text":"Implementing the execute Method","anchor":"implementing-the-execute-method","htmlText":"Implementing the execute Method"}],"lineInfo":{"truncatedLoc":"698","truncatedSloc":"548"},"mode":"file"},"image":false,"isCodeownersFile":null,"isPlain":false,"isValidLegacyIssueTemplate":false,"issueTemplateHelpUrl":"https://docs.github.com/articles/about-issue-and-pull-request-templates","issueTemplate":null,"discussionTemplate":null,"language":"Markdown","languageID":222,"large":false,"loggedIn":false,"newDiscussionPath":"/rust-lang/book/discussions/new","newIssuePath":"/rust-lang/book/issues/new","planSupportInfo":{"repoIsFork":null,"repoOwnedByCurrentUser":null,"requestFullPath":"/rust-lang/book/blob/main/src/ch20-02-multithreaded.md","showFreeOrgGatedFeatureMessage":null,"showPlanSupportBanner":null,"upgradeDataAttributes":null,"upgradePath":null},"publishBannersInfo":{"dismissActionNoticePath":"/settings/dismiss-notice/publish_action_from_dockerfile","dismissStackNoticePath":"/settings/dismiss-notice/publish_stack_from_file","releasePath":"/rust-lang/book/releases/new?marketplace=true","showPublishActionBanner":false,"showPublishStackBanner":false},"renderImageOrRaw":false,"richText":"<article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><h2 tabindex=\"-1\" id=\"user-content-turning-our-single-threaded-server-into-a-multithreaded-server\" dir=\"auto\"><a class=\"heading-link\" href=\"#turning-our-single-threaded-server-into-a-multithreaded-server\">Turning Our Single-Threaded Server into a Multithreaded Server<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">Right now, the server will process each request in turn, meaning it won’t\nprocess a second connection until the first is finished processing. If the\nserver received more and more requests, this serial execution would be less and\nless optimal. If the server receives a request that takes a long time to\nprocess, subsequent requests will have to wait until the long request is\nfinished, even if the new requests can be processed quickly. We’ll need to fix\nthis, but first, we’ll look at the problem in action.</p>\n<h3 tabindex=\"-1\" id=\"user-content-simulating-a-slow-request-in-the-current-server-implementation\" dir=\"auto\"><a class=\"heading-link\" href=\"#simulating-a-slow-request-in-the-current-server-implementation\">Simulating a Slow Request in the Current Server Implementation<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">We’ll look at how a slow-processing request can affect other requests made to\nour current server implementation. Listing 20-10 implements handling a request\nto <em>/sleep</em> with a simulated slow response that will cause the server to sleep\nfor 5 seconds before responding.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch20-web-server/listing-20-10/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch20-web-server/listing-<span class=\"pl-c1\">20</span>-<span class=\"pl-c1\">10</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 20-10: Simulating a slow request by sleeping for\n5 seconds</span></p>\n<p dir=\"auto\">We switched from <code>if</code> to <code>match</code> now that we have three cases. We need to\nexplicitly match on a slice of <code>request_line</code> to pattern match against the\nstring literal values; <code>match</code> doesn’t do automatic referencing and\ndereferencing like the equality method does.</p>\n<p dir=\"auto\">The first arm is the same as the <code>if</code> block from Listing 20-9. The second arm\nmatches a request to <em>/sleep</em>. When that request is received, the server will\nsleep for 5 seconds before rendering the successful HTML page. The third arm is\nthe same as the <code>else</code> block from Listing 20-9.</p>\n<p dir=\"auto\">You can see how primitive our server is: real libraries would handle the\nrecognition of multiple requests in a much less verbose way!</p>\n<p dir=\"auto\">Start the server using <code>cargo run</code>. Then open two browser windows: one for\n<em><a href=\"http://127.0.0.1:7878/\" rel=\"nofollow\">http://127.0.0.1:7878/</a></em> and the other for <em><a href=\"http://127.0.0.1:7878/sleep\" rel=\"nofollow\">http://127.0.0.1:7878/sleep</a></em>. If\nyou enter the <em>/</em> URI a few times, as before, you’ll see it respond quickly.\nBut if you enter <em>/sleep</em> and then load <em>/</em>, you’ll see that <em>/</em> waits until\n<code>sleep</code> has slept for its full 5 seconds before loading.</p>\n<p dir=\"auto\">There are multiple techniques we could use to avoid requests backing up behind\na slow request; the one we’ll implement is a thread pool.</p>\n<h3 tabindex=\"-1\" id=\"user-content-improving-throughput-with-a-thread-pool\" dir=\"auto\"><a class=\"heading-link\" href=\"#improving-throughput-with-a-thread-pool\">Improving Throughput with a Thread Pool<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">A <em>thread pool</em> is a group of spawned threads that are waiting and ready to\nhandle a task. When the program receives a new task, it assigns one of the\nthreads in the pool to the task, and that thread will process the task. The\nremaining threads in the pool are available to handle any other tasks that come\nin while the first thread is processing. When the first thread is done\nprocessing its task, it’s returned to the pool of idle threads, ready to handle\na new task. A thread pool allows you to process connections concurrently,\nincreasing the throughput of your server.</p>\n<p dir=\"auto\">We’ll limit the number of threads in the pool to a small number to protect us\nfrom Denial of Service (DoS) attacks; if we had our program create a new thread\nfor each request as it came in, someone making 10 million requests to our\nserver could create havoc by using up all our server’s resources and grinding\nthe processing of requests to a halt.</p>\n<p dir=\"auto\">Rather than spawning unlimited threads, then, we’ll have a fixed number of\nthreads waiting in the pool. Requests that come in are sent to the pool for\nprocessing. The pool will maintain a queue of incoming requests. Each of the\nthreads in the pool will pop off a request from this queue, handle the request,\nand then ask the queue for another request. With this design, we can process up\nto <code>N</code> requests concurrently, where <code>N</code> is the number of threads. If each\nthread is responding to a long-running request, subsequent requests can still\nback up in the queue, but we’ve increased the number of long-running requests\nwe can handle before reaching that point.</p>\n<p dir=\"auto\">This technique is just one of many ways to improve the throughput of a web\nserver. Other options you might explore are the <em>fork/join model</em>, the\n<em>single-threaded async I/O model</em>, or the <em>multi-threaded async I/O model</em>. If\nyou’re interested in this topic, you can read more about other solutions and\ntry to implement them; with a low-level language like Rust, all of these\noptions are possible.</p>\n<p dir=\"auto\">Before we begin implementing a thread pool, let’s talk about what using the\npool should look like. When you’re trying to design code, writing the client\ninterface first can help guide your design. Write the API of the code so it’s\nstructured in the way you want to call it; then implement the functionality\nwithin that structure rather than implementing the functionality and then\ndesigning the public API.</p>\n<p dir=\"auto\">Similar to how we used test-driven development in the project in Chapter 12,\nwe’ll use compiler-driven development here. We’ll write the code that calls the\nfunctions we want, and then we’ll look at errors from the compiler to determine\nwhat we should change next to get the code to work. Before we do that, however,\nwe’ll explore the technique we’re not going to use as a starting point.</p>\n\n<p dir=\"auto\"><a id=\"user-content-code-structure-if-we-could-spawn-a-thread-for-each-request\"></a></p>\n<h4 tabindex=\"-1\" id=\"user-content-spawning-a-thread-for-each-request\" dir=\"auto\"><a class=\"heading-link\" href=\"#spawning-a-thread-for-each-request\">Spawning a Thread for Each Request<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">First, let’s explore how our code might look if it did create a new thread for\nevery connection. As mentioned earlier, this isn’t our final plan due to the\nproblems with potentially spawning an unlimited number of threads, but it is a\nstarting point to get a working multithreaded server first. Then we’ll add the\nthread pool as an improvement, and contrasting the two solutions will be\neasier. Listing 20-11 shows the changes to make to <code>main</code> to spawn a new thread\nto handle each stream within the <code>for</code> loop.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch20-web-server/listing-20-11/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch20-web-server/listing-<span class=\"pl-c1\">20</span>-<span class=\"pl-c1\">11</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 20-11: Spawning a new thread for each\nstream</span></p>\n<p dir=\"auto\">As you learned in Chapter 16, <code>thread::spawn</code> will create a new thread and then\nrun the code in the closure in the new thread. If you run this code and load\n<em>/sleep</em> in your browser, then <em>/</em> in two more browser tabs, you’ll indeed see\nthat the requests to <em>/</em> don’t have to wait for <em>/sleep</em> to finish. However, as\nwe mentioned, this will eventually overwhelm the system because you’d be making\nnew threads without any limit.</p>\n\n<p dir=\"auto\"><a id=\"user-content-creating-a-similar-interface-for-a-finite-number-of-threads\"></a></p>\n<h4 tabindex=\"-1\" id=\"user-content-creating-a-finite-number-of-threads\" dir=\"auto\"><a class=\"heading-link\" href=\"#creating-a-finite-number-of-threads\">Creating a Finite Number of Threads<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">We want our thread pool to work in a similar, familiar way so switching from\nthreads to a thread pool doesn’t require large changes to the code that uses\nour API. Listing 20-12 shows the hypothetical interface for a <code>ThreadPool</code>\nstruct we want to use instead of <code>thread::spawn</code>.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch20-web-server/listing-20-12/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch20-web-server/listing-<span class=\"pl-c1\">20</span>-<span class=\"pl-c1\">12</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 20-12: Our ideal <code>ThreadPool</code> interface</span></p>\n<p dir=\"auto\">We use <code>ThreadPool::new</code> to create a new thread pool with a configurable number\nof threads, in this case four. Then, in the <code>for</code> loop, <code>pool.execute</code> has a\nsimilar interface as <code>thread::spawn</code> in that it takes a closure the pool should\nrun for each stream. We need to implement <code>pool.execute</code> so it takes the\nclosure and gives it to a thread in the pool to run. This code won’t yet\ncompile, but we’ll try so the compiler can guide us in how to fix it.</p>\n\n<p dir=\"auto\"><a id=\"user-content-building-the-threadpool-struct-using-compiler-driven-development\"></a></p>\n<h4 tabindex=\"-1\" id=\"user-content-building-threadpool-using-compiler-driven-development\" dir=\"auto\"><a class=\"heading-link\" href=\"#building-threadpool-using-compiler-driven-development\">Building <code>ThreadPool</code> Using Compiler Driven Development<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">Make the changes in Listing 20-12 to <em>src/main.rs</em>, and then let’s use the\ncompiler errors from <code>cargo check</code> to drive our development. Here is the first\nerror we get:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch20-web-server/listing-20-12/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch20-web-server/listing-20-12/output.txt}}</span></pre></div>\n<p dir=\"auto\">Great! This error tells us we need a <code>ThreadPool</code> type or module, so we’ll\nbuild one now. Our <code>ThreadPool</code> implementation will be independent of the kind\nof work our web server is doing. So, let’s switch the <code>hello</code> crate from a\nbinary crate to a library crate to hold our <code>ThreadPool</code> implementation. After\nwe change to a library crate, we could also use the separate thread pool\nlibrary for any work we want to do using a thread pool, not just for serving\nweb requests.</p>\n<p dir=\"auto\">Create a <em>src/lib.rs</em> that contains the following, which is the simplest\ndefinition of a <code>ThreadPool</code> struct that we can have for now:</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch20-web-server/no-listing-01-define-threadpool-struct/src/lib.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch20-web-server/no-listing-<span class=\"pl-c1\">01</span>-define-threadpool-struct/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">Then edit <em>main.rs</em> file to bring <code>ThreadPool</code> into scope from the library\ncrate by adding the following code to the top of <em>src/main.rs</em>:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch20-web-server/no-listing-01-define-threadpool-struct/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch20-web-server/no-listing-<span class=\"pl-c1\">01</span>-define-threadpool-struct/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">This code still won’t work, but let’s check it again to get the next error that\nwe need to address:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch20-web-server/no-listing-01-define-threadpool-struct/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch20-web-server/no-listing-01-define-threadpool-struct/output.txt}}</span></pre></div>\n<p dir=\"auto\">This error indicates that next we need to create an associated function named\n<code>new</code> for <code>ThreadPool</code>. We also know that <code>new</code> needs to have one parameter\nthat can accept <code>4</code> as an argument and should return a <code>ThreadPool</code> instance.\nLet’s implement the simplest <code>new</code> function that will have those\ncharacteristics:</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch20-web-server/no-listing-02-impl-threadpool-new/src/lib.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch20-web-server/no-listing-<span class=\"pl-c1\">02</span>-impl-threadpool-new/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">We chose <code>usize</code> as the type of the <code>size</code> parameter, because we know that a\nnegative number of threads doesn’t make any sense. We also know we’ll use this\n4 as the number of elements in a collection of threads, which is what the\n<code>usize</code> type is for, as discussed in the <a href=\"/rust-lang/book/blob/main/src/ch03-02-data-types.html#integer-types\">“Integer Types”</a> section of Chapter 3.</p>\n<p dir=\"auto\">Let’s check the code again:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch20-web-server/no-listing-02-impl-threadpool-new/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch20-web-server/no-listing-02-impl-threadpool-new/output.txt}}</span></pre></div>\n<p dir=\"auto\">Now the error occurs because we don’t have an <code>execute</code> method on <code>ThreadPool</code>.\nRecall from the <a href=\"#creating-a-finite-number-of-threads\">“Creating a Finite Number of\nThreads”</a> section that we\ndecided our thread pool should have an interface similar to <code>thread::spawn</code>. In\naddition, we’ll implement the <code>execute</code> function so it takes the closure it’s\ngiven and gives it to an idle thread in the pool to run.</p>\n<p dir=\"auto\">We’ll define the <code>execute</code> method on <code>ThreadPool</code> to take a closure as a\nparameter. Recall from the <a href=\"/rust-lang/book/blob/main/src/ch13-01-closures.html#moving-captured-values-out-of-the-closure-and-the-fn-traits\">“Moving Captured Values Out of the Closure and the\n<code>Fn</code> Traits”</a> section in Chapter 13 that we can take\nclosures as parameters with three different traits: <code>Fn</code>, <code>FnMut</code>, and\n<code>FnOnce</code>. We need to decide which kind of closure to use here. We know we’ll\nend up doing something similar to the standard library <code>thread::spawn</code>\nimplementation, so we can look at what bounds the signature of <code>thread::spawn</code>\nhas on its parameter. The documentation shows us the following:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;\n    where\n        F: FnOnce() -&gt; T,\n        F: Send + 'static,\n        T: Send + 'static,\"><pre><span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> <span class=\"pl-en\">spawn</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">F</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">T</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">f</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">F</span><span class=\"pl-kos\">)</span> -&gt; <span class=\"pl-smi\">JoinHandle</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">&gt;</span>\n    <span class=\"pl-k\">where</span>\n        <span class=\"pl-smi\">F</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">FnOnce</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> -&gt; <span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span>\n        <span class=\"pl-smi\">F</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">Send</span> + <span class=\"pl-c1\">'</span><span class=\"pl-ent\">static</span><span class=\"pl-kos\">,</span>\n        <span class=\"pl-smi\">T</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">Send</span> + <span class=\"pl-c1\">'</span><span class=\"pl-ent\">static</span><span class=\"pl-kos\">,</span><span class=\"pl-kos\"></span></pre></div>\n<p dir=\"auto\">The <code>F</code> type parameter is the one we’re concerned with here; the <code>T</code> type\nparameter is related to the return value, and we’re not concerned with that. We\ncan see that <code>spawn</code> uses <code>FnOnce</code> as the trait bound on <code>F</code>. This is probably\nwhat we want as well, because we’ll eventually pass the argument we get in\n<code>execute</code> to <code>spawn</code>. We can be further confident that <code>FnOnce</code> is the trait we\nwant to use because the thread for running a request will only execute that\nrequest’s closure one time, which matches the <code>Once</code> in <code>FnOnce</code>.</p>\n<p dir=\"auto\">The <code>F</code> type parameter also has the trait bound <code>Send</code> and the lifetime bound\n<code>'static</code>, which are useful in our situation: we need <code>Send</code> to transfer the\nclosure from one thread to another and <code>'static</code> because we don’t know how long\nthe thread will take to execute. Let’s create an <code>execute</code> method on\n<code>ThreadPool</code> that will take a generic parameter of type <code>F</code> with these bounds:</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch20-web-server/no-listing-03-define-execute/src/lib.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch20-web-server/no-listing-<span class=\"pl-c1\">03</span>-define-execute/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">We still use the <code>()</code> after <code>FnOnce</code> because this <code>FnOnce</code> represents a closure\nthat takes no parameters and returns the unit type <code>()</code>. Just like function\ndefinitions, the return type can be omitted from the signature, but even if we\nhave no parameters, we still need the parentheses.</p>\n<p dir=\"auto\">Again, this is the simplest implementation of the <code>execute</code> method: it does\nnothing, but we’re trying only to make our code compile. Let’s check it again:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch20-web-server/no-listing-03-define-execute/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch20-web-server/no-listing-03-define-execute/output.txt}}</span></pre></div>\n<p dir=\"auto\">It compiles! But note that if you try <code>cargo run</code> and make a request in the\nbrowser, you’ll see the errors in the browser that we saw at the beginning of\nthe chapter. Our library isn’t actually calling the closure passed to <code>execute</code>\nyet!</p>\n<blockquote>\n<p dir=\"auto\">Note: A saying you might hear about languages with strict compilers, such as\nHaskell and Rust, is “if the code compiles, it works.” But this saying is not\nuniversally true. Our project compiles, but it does absolutely nothing! If we\nwere building a real, complete project, this would be a good time to start\nwriting unit tests to check that the code compiles <em>and</em> has the behavior we\nwant.</p>\n</blockquote>\n<h4 tabindex=\"-1\" id=\"user-content-validating-the-number-of-threads-in-new\" dir=\"auto\"><a class=\"heading-link\" href=\"#validating-the-number-of-threads-in-new\">Validating the Number of Threads in <code>new</code><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">We aren’t doing anything with the parameters to <code>new</code> and <code>execute</code>. Let’s\nimplement the bodies of these functions with the behavior we want. To start,\nlet’s think about <code>new</code>. Earlier we chose an unsigned type for the <code>size</code>\nparameter, because a pool with a negative number of threads makes no sense.\nHowever, a pool with zero threads also makes no sense, yet zero is a perfectly\nvalid <code>usize</code>. We’ll add code to check that <code>size</code> is greater than zero before\nwe return a <code>ThreadPool</code> instance and have the program panic if it receives a\nzero by using the <code>assert!</code> macro, as shown in Listing 20-13.</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch20-web-server/listing-20-13/src/lib.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch20-web-server/listing-<span class=\"pl-c1\">20</span>-<span class=\"pl-c1\">13</span>/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 20-13: Implementing <code>ThreadPool::new</code> to panic if\n<code>size</code> is zero</span></p>\n<p dir=\"auto\">We’ve also added some documentation for our <code>ThreadPool</code> with doc comments.\nNote that we followed good documentation practices by adding a section that\ncalls out the situations in which our function can panic, as discussed in\nChapter 14. Try running <code>cargo doc --open</code> and clicking the <code>ThreadPool</code> struct\nto see what the generated docs for <code>new</code> look like!</p>\n<p dir=\"auto\">Instead of adding the <code>assert!</code> macro as we’ve done here, we could change <code>new</code>\ninto <code>build</code> and return a <code>Result</code> like we did with <code>Config::build</code> in the I/O\nproject in Listing 12-9. But we’ve decided in this case that trying to create a\nthread pool without any threads should be an unrecoverable error. If you’re\nfeeling ambitious, try to write a function named <code>build</code> with the following\nsignature to compare with the <code>new</code> function:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"pub fn build(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {\"><pre><span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> build<span class=\"pl-kos\">(</span><span class=\"pl-s1\">size</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">usize</span><span class=\"pl-kos\">)</span> -&gt; <span class=\"pl-smi\">Result</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">ThreadPool</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">PoolCreationError</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-kos\">{</span></pre></div>\n<h4 tabindex=\"-1\" id=\"user-content-creating-space-to-store-the-threads\" dir=\"auto\"><a class=\"heading-link\" href=\"#creating-space-to-store-the-threads\">Creating Space to Store the Threads<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">Now that we have a way to know we have a valid number of threads to store in\nthe pool, we can create those threads and store them in the <code>ThreadPool</code> struct\nbefore returning the struct. But how do we “store” a thread? Let’s take another\nlook at the <code>thread::spawn</code> signature:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;\n    where\n        F: FnOnce() -&gt; T,\n        F: Send + 'static,\n        T: Send + 'static,\"><pre><span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> <span class=\"pl-en\">spawn</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">F</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">T</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">f</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">F</span><span class=\"pl-kos\">)</span> -&gt; <span class=\"pl-smi\">JoinHandle</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">&gt;</span>\n    <span class=\"pl-k\">where</span>\n        <span class=\"pl-smi\">F</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">FnOnce</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> -&gt; <span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span>\n        <span class=\"pl-smi\">F</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">Send</span> + <span class=\"pl-c1\">'</span><span class=\"pl-ent\">static</span><span class=\"pl-kos\">,</span>\n        <span class=\"pl-smi\">T</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">Send</span> + <span class=\"pl-c1\">'</span><span class=\"pl-ent\">static</span><span class=\"pl-kos\">,</span><span class=\"pl-kos\"></span></pre></div>\n<p dir=\"auto\">The <code>spawn</code> function returns a <code>JoinHandle&lt;T&gt;</code>, where <code>T</code> is the type that the\nclosure returns. Let’s try using <code>JoinHandle</code> too and see what happens. In our\ncase, the closures we’re passing to the thread pool will handle the connection\nand not return anything, so <code>T</code> will be the unit type <code>()</code>.</p>\n<p dir=\"auto\">The code in Listing 20-14 will compile but doesn’t create any threads yet.\nWe’ve changed the definition of <code>ThreadPool</code> to hold a vector of\n<code>thread::JoinHandle&lt;()&gt;</code> instances, initialized the vector with a capacity of\n<code>size</code>, set up a <code>for</code> loop that will run some code to create the threads, and\nreturned a <code>ThreadPool</code> instance containing them.</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch20-web-server/listing-20-14/src/lib.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch20-web-server/listing-<span class=\"pl-c1\">20</span>-<span class=\"pl-c1\">14</span>/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 20-14: Creating a vector for <code>ThreadPool</code> to hold\nthe threads</span></p>\n<p dir=\"auto\">We’ve brought <code>std::thread</code> into scope in the library crate, because we’re\nusing <code>thread::JoinHandle</code> as the type of the items in the vector in\n<code>ThreadPool</code>.</p>\n<p dir=\"auto\">Once a valid size is received, our <code>ThreadPool</code> creates a new vector that can\nhold <code>size</code> items. The <code>with_capacity</code> function performs the same task as\n<code>Vec::new</code> but with an important difference: it preallocates space in the\nvector. Because we know we need to store <code>size</code> elements in the vector, doing\nthis allocation up front is slightly more efficient than using <code>Vec::new</code>,\nwhich resizes itself as elements are inserted.</p>\n<p dir=\"auto\">When you run <code>cargo check</code> again, it should succeed.</p>\n<h4 tabindex=\"-1\" id=\"user-content-a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread\" dir=\"auto\"><a class=\"heading-link\" href=\"#a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread\">A <code>Worker</code> Struct Responsible for Sending Code from the <code>ThreadPool</code> to a Thread<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">We left a comment in the <code>for</code> loop in Listing 20-14 regarding the creation of\nthreads. Here, we’ll look at how we actually create threads. The standard\nlibrary provides <code>thread::spawn</code> as a way to create threads, and\n<code>thread::spawn</code> expects to get some code the thread should run as soon as the\nthread is created. However, in our case, we want to create the threads and have\nthem <em>wait</em> for code that we’ll send later. The standard library’s\nimplementation of threads doesn’t include any way to do that; we have to\nimplement it manually.</p>\n<p dir=\"auto\">We’ll implement this behavior by introducing a new data structure between the\n<code>ThreadPool</code> and the threads that will manage this new behavior. We’ll call\nthis data structure <em>Worker</em>, which is a common term in pooling\nimplementations. The Worker picks up code that needs to be run and runs the\ncode in the Worker’s thread. Think of people working in the kitchen at a\nrestaurant: the workers wait until orders come in from customers, and then\nthey’re responsible for taking those orders and fulfilling them.</p>\n<p dir=\"auto\">Instead of storing a vector of <code>JoinHandle&lt;()&gt;</code> instances in the thread pool,\nwe’ll store instances of the <code>Worker</code> struct. Each <code>Worker</code> will store a single\n<code>JoinHandle&lt;()&gt;</code> instance. Then we’ll implement a method on <code>Worker</code> that will\ntake a closure of code to run and send it to the already running thread for\nexecution. We’ll also give each worker an <code>id</code> so we can distinguish between\nthe different workers in the pool when logging or debugging.</p>\n<p dir=\"auto\">Here is the new process that will happen when we create a <code>ThreadPool</code>. We’ll\nimplement the code that sends the closure to the thread after we have <code>Worker</code>\nset up in this way:</p>\n<ol dir=\"auto\">\n<li>Define a <code>Worker</code> struct that holds an <code>id</code> and a <code>JoinHandle&lt;()&gt;</code>.</li>\n<li>Change <code>ThreadPool</code> to hold a vector of <code>Worker</code> instances.</li>\n<li>Define a <code>Worker::new</code> function that takes an <code>id</code> number and returns a\n<code>Worker</code> instance that holds the <code>id</code> and a thread spawned with an empty\nclosure.</li>\n<li>In <code>ThreadPool::new</code>, use the <code>for</code> loop counter to generate an <code>id</code>, create\na new <code>Worker</code> with that <code>id</code>, and store the worker in the vector.</li>\n</ol>\n<p dir=\"auto\">If you’re up for a challenge, try implementing these changes on your own before\nlooking at the code in Listing 20-15.</p>\n<p dir=\"auto\">Ready? Here is Listing 20-15 with one way to make the preceding modifications.</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch20-web-server/listing-20-15/src/lib.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch20-web-server/listing-<span class=\"pl-c1\">20</span>-<span class=\"pl-c1\">15</span>/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 20-15: Modifying <code>ThreadPool</code> to hold <code>Worker</code>\ninstances instead of holding threads directly</span></p>\n<p dir=\"auto\">We’ve changed the name of the field on <code>ThreadPool</code> from <code>threads</code> to <code>workers</code>\nbecause it’s now holding <code>Worker</code> instances instead of <code>JoinHandle&lt;()&gt;</code>\ninstances. We use the counter in the <code>for</code> loop as an argument to\n<code>Worker::new</code>, and we store each new <code>Worker</code> in the vector named <code>workers</code>.</p>\n<p dir=\"auto\">External code (like our server in <em>src/main.rs</em>) doesn’t need to know the\nimplementation details regarding using a <code>Worker</code> struct within <code>ThreadPool</code>,\nso we make the <code>Worker</code> struct and its <code>new</code> function private. The\n<code>Worker::new</code> function uses the <code>id</code> we give it and stores a <code>JoinHandle&lt;()&gt;</code>\ninstance that is created by spawning a new thread using an empty closure.</p>\n<blockquote>\n<p dir=\"auto\">Note: If the operating system can’t create a thread because there aren’t\nenough system resources, <code>thread::spawn</code> will panic. That will cause our\nwhole server to panic, even though the creation of some threads might\nsucceed. For simplicity’s sake, this behavior is fine, but in a production\nthread pool implementation, you’d likely want to use\n<a href=\"/rust-lang/book/blob/main/std/thread/struct.Builder.html\"><code>std::thread::Builder</code></a> and its\n<a href=\"/rust-lang/book/blob/main/std/thread/struct.Builder.html#method.spawn\"><code>spawn</code></a> method that returns <code>Result</code> instead.</p>\n</blockquote>\n<p dir=\"auto\">This code will compile and will store the number of <code>Worker</code> instances we\nspecified as an argument to <code>ThreadPool::new</code>. But we’re <em>still</em> not processing\nthe closure that we get in <code>execute</code>. Let’s look at how to do that next.</p>\n<h4 tabindex=\"-1\" id=\"user-content-sending-requests-to-threads-via-channels\" dir=\"auto\"><a class=\"heading-link\" href=\"#sending-requests-to-threads-via-channels\">Sending Requests to Threads via Channels<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">The next problem we’ll tackle is that the closures given to <code>thread::spawn</code> do\nabsolutely nothing. Currently, we get the closure we want to execute in the\n<code>execute</code> method. But we need to give <code>thread::spawn</code> a closure to run when we\ncreate each <code>Worker</code> during the creation of the <code>ThreadPool</code>.</p>\n<p dir=\"auto\">We want the <code>Worker</code> structs that we just created to fetch the code to run from\na queue held in the <code>ThreadPool</code> and send that code to its thread to run.</p>\n<p dir=\"auto\">The channels we learned about in Chapter 16—a simple way to communicate between\ntwo threads—would be perfect for this use case. We’ll use a channel to function\nas the queue of jobs, and <code>execute</code> will send a job from the <code>ThreadPool</code> to\nthe <code>Worker</code> instances, which will send the job to its thread. Here is the plan:</p>\n<ol dir=\"auto\">\n<li>The <code>ThreadPool</code> will create a channel and hold on to the sender.</li>\n<li>Each <code>Worker</code> will hold on to the receiver.</li>\n<li>We’ll create a new <code>Job</code> struct that will hold the closures we want to send\ndown the channel.</li>\n<li>The <code>execute</code> method will send the job it wants to execute through the\nsender.</li>\n<li>In its thread, the <code>Worker</code> will loop over its receiver and execute the\nclosures of any jobs it receives.</li>\n</ol>\n<p dir=\"auto\">Let’s start by creating a channel in <code>ThreadPool::new</code> and holding the sender\nin the <code>ThreadPool</code> instance, as shown in Listing 20-16. The <code>Job</code> struct\ndoesn’t hold anything for now but will be the type of item we’re sending down\nthe channel.</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch20-web-server/listing-20-16/src/lib.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch20-web-server/listing-<span class=\"pl-c1\">20</span>-<span class=\"pl-c1\">16</span>/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 20-16: Modifying <code>ThreadPool</code> to store the\nsender of a channel that transmits <code>Job</code> instances</span></p>\n<p dir=\"auto\">In <code>ThreadPool::new</code>, we create our new channel and have the pool hold the\nsender. This will successfully compile.</p>\n<p dir=\"auto\">Let’s try passing a receiver of the channel into each worker as the thread pool\ncreates the channel. We know we want to use the receiver in the thread that the\nworkers spawn, so we’ll reference the <code>receiver</code> parameter in the closure. The\ncode in Listing 20-17 won’t quite compile yet.</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch20-web-server/listing-20-17/src/lib.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch20-web-server/listing-<span class=\"pl-c1\">20</span>-<span class=\"pl-c1\">17</span>/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 20-17: Passing the receiver to the workers</span></p>\n<p dir=\"auto\">We’ve made some small and straightforward changes: we pass the receiver into\n<code>Worker::new</code>, and then we use it inside the closure.</p>\n<p dir=\"auto\">When we try to check this code, we get this error:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch20-web-server/listing-20-17/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch20-web-server/listing-20-17/output.txt}}</span></pre></div>\n<p dir=\"auto\">The code is trying to pass <code>receiver</code> to multiple <code>Worker</code> instances. This\nwon’t work, as you’ll recall from Chapter 16: the channel implementation that\nRust provides is multiple <em>producer</em>, single <em>consumer</em>. This means we can’t\njust clone the consuming end of the channel to fix this code. We also don’t\nwant to send a message multiple times to multiple consumers; we want one list\nof messages with multiple workers such that each message gets processed once.</p>\n<p dir=\"auto\">Additionally, taking a job off the channel queue involves mutating the\n<code>receiver</code>, so the threads need a safe way to share and modify <code>receiver</code>;\notherwise, we might get race conditions (as covered in Chapter 16).</p>\n<p dir=\"auto\">Recall the thread-safe smart pointers discussed in Chapter 16: to share\nownership across multiple threads and allow the threads to mutate the value, we\nneed to use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. The <code>Arc</code> type will let multiple workers own the\nreceiver, and <code>Mutex</code> will ensure that only one worker gets a job from the\nreceiver at a time. Listing 20-18 shows the changes we need to make.</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch20-web-server/listing-20-18/src/lib.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch20-web-server/listing-<span class=\"pl-c1\">20</span>-<span class=\"pl-c1\">18</span>/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 20-18: Sharing the receiver among the workers\nusing <code>Arc</code> and <code>Mutex</code></span></p>\n<p dir=\"auto\">In <code>ThreadPool::new</code>, we put the receiver in an <code>Arc</code> and a <code>Mutex</code>. For each\nnew worker, we clone the <code>Arc</code> to bump the reference count so the workers can\nshare ownership of the receiver.</p>\n<p dir=\"auto\">With these changes, the code compiles! We’re getting there!</p>\n<h4 tabindex=\"-1\" id=\"user-content-implementing-the-execute-method\" dir=\"auto\"><a class=\"heading-link\" href=\"#implementing-the-execute-method\">Implementing the <code>execute</code> Method<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">Let’s finally implement the <code>execute</code> method on <code>ThreadPool</code>. We’ll also change\n<code>Job</code> from a struct to a type alias for a trait object that holds the type of\nclosure that <code>execute</code> receives. As discussed in the <a href=\"/rust-lang/book/blob/main/src/ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases\">“Creating Type Synonyms\nwith Type Aliases”</a>\nsection of Chapter 19, type aliases allow us to make long types shorter for\nease of use. Look at Listing 20-19.</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch20-web-server/listing-20-19/src/lib.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch20-web-server/listing-<span class=\"pl-c1\">20</span>-<span class=\"pl-c1\">19</span>/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 20-19: Creating a <code>Job</code> type alias for a <code>Box</code>\nthat holds each closure and then sending the job down the channel</span></p>\n<p dir=\"auto\">After creating a new <code>Job</code> instance using the closure we get in <code>execute</code>, we\nsend that job down the sending end of the channel. We’re calling <code>unwrap</code> on\n<code>send</code> for the case that sending fails. This might happen if, for example, we\nstop all our threads from executing, meaning the receiving end has stopped\nreceiving new messages. At the moment, we can’t stop our threads from\nexecuting: our threads continue executing as long as the pool exists. The\nreason we use <code>unwrap</code> is that we know the failure case won’t happen, but the\ncompiler doesn’t know that.</p>\n<p dir=\"auto\">But we’re not quite done yet! In the worker, our closure being passed to\n<code>thread::spawn</code> still only <em>references</em> the receiving end of the channel.\nInstead, we need the closure to loop forever, asking the receiving end of the\nchannel for a job and running the job when it gets one. Let’s make the change\nshown in Listing 20-20 to <code>Worker::new</code>.</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch20-web-server/listing-20-20/src/lib.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch20-web-server/listing-<span class=\"pl-c1\">20</span>-<span class=\"pl-c1\">20</span>/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 20-20: Receiving and executing the jobs in the\nworker’s thread</span></p>\n<p dir=\"auto\">Here, we first call <code>lock</code> on the <code>receiver</code> to acquire the mutex, and then we\ncall <code>unwrap</code> to panic on any errors. Acquiring a lock might fail if the mutex\nis in a <em>poisoned</em> state, which can happen if some other thread panicked while\nholding the lock rather than releasing the lock. In this situation, calling\n<code>unwrap</code> to have this thread panic is the correct action to take. Feel free to\nchange this <code>unwrap</code> to an <code>expect</code> with an error message that is meaningful to\nyou.</p>\n<p dir=\"auto\">If we get the lock on the mutex, we call <code>recv</code> to receive a <code>Job</code> from the\nchannel. A final <code>unwrap</code> moves past any errors here as well, which might occur\nif the thread holding the sender has shut down, similar to how the <code>send</code>\nmethod returns <code>Err</code> if the receiver shuts down.</p>\n<p dir=\"auto\">The call to <code>recv</code> blocks, so if there is no job yet, the current thread will\nwait until a job becomes available. The <code>Mutex&lt;T&gt;</code> ensures that only one\n<code>Worker</code> thread at a time is trying to request a job.</p>\n<p dir=\"auto\">Our thread pool is now in a working state! Give it a <code>cargo run</code> and make some\nrequests:</p>\n\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"$ cargo run\n   Compiling hello v0.1.0 (file:///projects/hello)\nwarning: field is never read: `workers`\n --&gt; src/lib.rs:7:5\n  |\n7 |     workers: Vec&lt;Worker&gt;,\n  |     ^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(dead_code)]` on by default\n\nwarning: field is never read: `id`\n  --&gt; src/lib.rs:48:5\n   |\n48 |     id: usize,\n   |     ^^^^^^^^^\n\nwarning: field is never read: `thread`\n  --&gt; src/lib.rs:49:5\n   |\n49 |     thread: thread::JoinHandle&lt;()&gt;,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: `hello` (lib) generated 3 warnings\n    Finished dev [unoptimized + debuginfo] target(s) in 1.40s\n     Running `target/debug/hello`\nWorker 0 got a job; executing.\nWorker 2 got a job; executing.\nWorker 1 got a job; executing.\nWorker 3 got a job; executing.\nWorker 0 got a job; executing.\nWorker 2 got a job; executing.\nWorker 1 got a job; executing.\nWorker 3 got a job; executing.\nWorker 0 got a job; executing.\nWorker 2 got a job; executing.\"><pre>$ <span class=\"pl-s1\">cargo run</span>\n<span class=\"pl-c1\">   Compiling hello v0.1.0 (file:///projects/hello)</span>\n<span class=\"pl-c1\">warning: field is never read: `workers`</span>\n<span class=\"pl-c1\"> --&gt; src/lib.rs:7:5</span>\n<span class=\"pl-c1\">  |</span>\n<span class=\"pl-c1\">7 |     workers: Vec&lt;Worker&gt;,</span>\n<span class=\"pl-c1\">  |     ^^^^^^^^^^^^^^^^^^^^</span>\n<span class=\"pl-c1\">  |</span>\n<span class=\"pl-c1\">  = note: `#[warn(dead_code)]` on by default</span>\n\n<span class=\"pl-c1\">warning: field is never read: `id`</span>\n<span class=\"pl-c1\">  --&gt; src/lib.rs:48:5</span>\n<span class=\"pl-c1\">   |</span>\n<span class=\"pl-c1\">48 |     id: usize,</span>\n<span class=\"pl-c1\">   |     ^^^^^^^^^</span>\n\n<span class=\"pl-c1\">warning: field is never read: `thread`</span>\n<span class=\"pl-c1\">  --&gt; src/lib.rs:49:5</span>\n<span class=\"pl-c1\">   |</span>\n<span class=\"pl-c1\">49 |     thread: thread::JoinHandle&lt;()&gt;,</span>\n<span class=\"pl-c1\">   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>\n\n<span class=\"pl-c1\">warning: `hello` (lib) generated 3 warnings</span>\n<span class=\"pl-c1\">    Finished dev [unoptimized + debuginfo] target(s) in 1.40s</span>\n<span class=\"pl-c1\">     Running `target/debug/hello`</span>\n<span class=\"pl-c1\">Worker 0 got a job; executing.</span>\n<span class=\"pl-c1\">Worker 2 got a job; executing.</span>\n<span class=\"pl-c1\">Worker 1 got a job; executing.</span>\n<span class=\"pl-c1\">Worker 3 got a job; executing.</span>\n<span class=\"pl-c1\">Worker 0 got a job; executing.</span>\n<span class=\"pl-c1\">Worker 2 got a job; executing.</span>\n<span class=\"pl-c1\">Worker 1 got a job; executing.</span>\n<span class=\"pl-c1\">Worker 3 got a job; executing.</span>\n<span class=\"pl-c1\">Worker 0 got a job; executing.</span>\n<span class=\"pl-c1\">Worker 2 got a job; executing.</span></pre></div>\n<p dir=\"auto\">Success! We now have a thread pool that executes connections asynchronously.\nThere are never more than four threads created, so our system won’t get\noverloaded if the server receives a lot of requests. If we make a request to\n<em>/sleep</em>, the server will be able to serve other requests by having another\nthread run them.</p>\n<blockquote>\n<p dir=\"auto\">Note: if you open <em>/sleep</em> in multiple browser windows simultaneously, they\nmight load one at a time in 5 second intervals. Some web browsers execute\nmultiple instances of the same request sequentially for caching reasons. This\nlimitation is not caused by our web server.</p>\n</blockquote>\n<p dir=\"auto\">After learning about the <code>while let</code> loop in Chapter 18, you might be wondering\nwhy we didn’t write the worker thread code as shown in Listing 20-21.</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch20-web-server/listing-20-21/src/lib.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch20-web-server/listing-<span class=\"pl-c1\">20</span>-<span class=\"pl-c1\">21</span>/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 20-21: An alternative implementation of\n<code>Worker::new</code> using <code>while let</code></span></p>\n<p dir=\"auto\">This code compiles and runs but doesn’t result in the desired threading\nbehavior: a slow request will still cause other requests to wait to be\nprocessed. The reason is somewhat subtle: the <code>Mutex</code> struct has no public\n<code>unlock</code> method because the ownership of the lock is based on the lifetime of\nthe <code>MutexGuard&lt;T&gt;</code> within the <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> that the <code>lock</code>\nmethod returns. At compile time, the borrow checker can then enforce the rule\nthat a resource guarded by a <code>Mutex</code> cannot be accessed unless we hold the\nlock. However, this implementation can also result in the lock being held\nlonger than intended if we aren’t mindful of the lifetime of the\n<code>MutexGuard&lt;T&gt;</code>.</p>\n<p dir=\"auto\">The code in Listing 20-20 that uses <code>let job = receiver.lock().unwrap().recv().unwrap();</code> works because with <code>let</code>, any\ntemporary values used in the expression on the right hand side of the equals\nsign are immediately dropped when the <code>let</code> statement ends. However, <code>while let</code> (and <code>if let</code> and <code>match</code>) does not drop temporary values until the end of\nthe associated block. In Listing 20-21, the lock remains held for the duration\nof the call to <code>job()</code>, meaning other workers cannot receive jobs.</p>\n</article>","renderedFileInfo":null,"shortPath":null,"tabSize":8,"topBannersInfo":{"overridingGlobalFundingFile":false,"globalPreferredFundingPath":null,"repoOwner":"rust-lang","repoName":"book","showInvalidCitationWarning":false,"citationHelpUrl":"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/about-citation-files","showDependabotConfigurationBanner":false,"actionsOnboardingTip":null},"truncated":false,"viewable":true,"workflowRedirectUrl":null,"symbols":{"timedOut":false,"notAnalyzed":true,"symbols":[]}},"copilotInfo":null,"csrf_tokens":{"/rust-lang/book/branches":{"post":"Xa3tGs6lYcqJ8XeXQJPmhVyOjBZ6Od_m3f-OXjaWrKfxU5A1foTrEUUzIgk1xXg637NOhPI3uzsVbojIGzYO6w"},"/repos/preferences":{"post":"xoUtEgZoLi1YnDUUV1XChzyyqJRM2X320_EYcIPcJUZ9bLP-i7Ej9r1O1aMX0IvTR0fBwtDfQ7daRc9dIVhG8w"}}},"title":"book/src/ch20-02-multithreaded.md at main · rust-lang/book"}
{"payload":{"allShortcutsEnabled":false,"fileTree":{"src":{"items":[{"name":"img","path":"src/img","contentType":"directory"},{"name":"SUMMARY.md","path":"src/SUMMARY.md","contentType":"file"},{"name":"appendix-00.md","path":"src/appendix-00.md","contentType":"file"},{"name":"appendix-01-keywords.md","path":"src/appendix-01-keywords.md","contentType":"file"},{"name":"appendix-02-operators.md","path":"src/appendix-02-operators.md","contentType":"file"},{"name":"appendix-03-derivable-traits.md","path":"src/appendix-03-derivable-traits.md","contentType":"file"},{"name":"appendix-04-useful-development-tools.md","path":"src/appendix-04-useful-development-tools.md","contentType":"file"},{"name":"appendix-05-editions.md","path":"src/appendix-05-editions.md","contentType":"file"},{"name":"appendix-06-translation.md","path":"src/appendix-06-translation.md","contentType":"file"},{"name":"appendix-07-nightly-rust.md","path":"src/appendix-07-nightly-rust.md","contentType":"file"},{"name":"ch00-00-introduction.md","path":"src/ch00-00-introduction.md","contentType":"file"},{"name":"ch01-00-getting-started.md","path":"src/ch01-00-getting-started.md","contentType":"file"},{"name":"ch01-01-installation.md","path":"src/ch01-01-installation.md","contentType":"file"},{"name":"ch01-02-hello-world.md","path":"src/ch01-02-hello-world.md","contentType":"file"},{"name":"ch01-03-hello-cargo.md","path":"src/ch01-03-hello-cargo.md","contentType":"file"},{"name":"ch02-00-guessing-game-tutorial.md","path":"src/ch02-00-guessing-game-tutorial.md","contentType":"file"},{"name":"ch03-00-common-programming-concepts.md","path":"src/ch03-00-common-programming-concepts.md","contentType":"file"},{"name":"ch03-01-variables-and-mutability.md","path":"src/ch03-01-variables-and-mutability.md","contentType":"file"},{"name":"ch03-02-data-types.md","path":"src/ch03-02-data-types.md","contentType":"file"},{"name":"ch03-03-how-functions-work.md","path":"src/ch03-03-how-functions-work.md","contentType":"file"},{"name":"ch03-04-comments.md","path":"src/ch03-04-comments.md","contentType":"file"},{"name":"ch03-05-control-flow.md","path":"src/ch03-05-control-flow.md","contentType":"file"},{"name":"ch04-00-understanding-ownership.md","path":"src/ch04-00-understanding-ownership.md","contentType":"file"},{"name":"ch04-01-what-is-ownership.md","path":"src/ch04-01-what-is-ownership.md","contentType":"file"},{"name":"ch04-02-references-and-borrowing.md","path":"src/ch04-02-references-and-borrowing.md","contentType":"file"},{"name":"ch04-03-slices.md","path":"src/ch04-03-slices.md","contentType":"file"},{"name":"ch05-00-structs.md","path":"src/ch05-00-structs.md","contentType":"file"},{"name":"ch05-01-defining-structs.md","path":"src/ch05-01-defining-structs.md","contentType":"file"},{"name":"ch05-02-example-structs.md","path":"src/ch05-02-example-structs.md","contentType":"file"},{"name":"ch05-03-method-syntax.md","path":"src/ch05-03-method-syntax.md","contentType":"file"},{"name":"ch06-00-enums.md","path":"src/ch06-00-enums.md","contentType":"file"},{"name":"ch06-01-defining-an-enum.md","path":"src/ch06-01-defining-an-enum.md","contentType":"file"},{"name":"ch06-02-match.md","path":"src/ch06-02-match.md","contentType":"file"},{"name":"ch06-03-if-let.md","path":"src/ch06-03-if-let.md","contentType":"file"},{"name":"ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","path":"src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","contentType":"file"},{"name":"ch07-01-packages-and-crates.md","path":"src/ch07-01-packages-and-crates.md","contentType":"file"},{"name":"ch07-02-defining-modules-to-control-scope-and-privacy.md","path":"src/ch07-02-defining-modules-to-control-scope-and-privacy.md","contentType":"file"},{"name":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","path":"src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","contentType":"file"},{"name":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","path":"src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","contentType":"file"},{"name":"ch07-05-separating-modules-into-different-files.md","path":"src/ch07-05-separating-modules-into-different-files.md","contentType":"file"},{"name":"ch08-00-common-collections.md","path":"src/ch08-00-common-collections.md","contentType":"file"},{"name":"ch08-01-vectors.md","path":"src/ch08-01-vectors.md","contentType":"file"},{"name":"ch08-02-strings.md","path":"src/ch08-02-strings.md","contentType":"file"},{"name":"ch08-03-hash-maps.md","path":"src/ch08-03-hash-maps.md","contentType":"file"},{"name":"ch09-00-error-handling.md","path":"src/ch09-00-error-handling.md","contentType":"file"},{"name":"ch09-01-unrecoverable-errors-with-panic.md","path":"src/ch09-01-unrecoverable-errors-with-panic.md","contentType":"file"},{"name":"ch09-02-recoverable-errors-with-result.md","path":"src/ch09-02-recoverable-errors-with-result.md","contentType":"file"},{"name":"ch09-03-to-panic-or-not-to-panic.md","path":"src/ch09-03-to-panic-or-not-to-panic.md","contentType":"file"},{"name":"ch10-00-generics.md","path":"src/ch10-00-generics.md","contentType":"file"},{"name":"ch10-01-syntax.md","path":"src/ch10-01-syntax.md","contentType":"file"},{"name":"ch10-02-traits.md","path":"src/ch10-02-traits.md","contentType":"file"},{"name":"ch10-03-lifetime-syntax.md","path":"src/ch10-03-lifetime-syntax.md","contentType":"file"},{"name":"ch11-00-testing.md","path":"src/ch11-00-testing.md","contentType":"file"},{"name":"ch11-01-writing-tests.md","path":"src/ch11-01-writing-tests.md","contentType":"file"},{"name":"ch11-02-running-tests.md","path":"src/ch11-02-running-tests.md","contentType":"file"},{"name":"ch11-03-test-organization.md","path":"src/ch11-03-test-organization.md","contentType":"file"},{"name":"ch12-00-an-io-project.md","path":"src/ch12-00-an-io-project.md","contentType":"file"},{"name":"ch12-01-accepting-command-line-arguments.md","path":"src/ch12-01-accepting-command-line-arguments.md","contentType":"file"},{"name":"ch12-02-reading-a-file.md","path":"src/ch12-02-reading-a-file.md","contentType":"file"},{"name":"ch12-03-improving-error-handling-and-modularity.md","path":"src/ch12-03-improving-error-handling-and-modularity.md","contentType":"file"},{"name":"ch12-04-testing-the-librarys-functionality.md","path":"src/ch12-04-testing-the-librarys-functionality.md","contentType":"file"},{"name":"ch12-05-working-with-environment-variables.md","path":"src/ch12-05-working-with-environment-variables.md","contentType":"file"},{"name":"ch12-06-writing-to-stderr-instead-of-stdout.md","path":"src/ch12-06-writing-to-stderr-instead-of-stdout.md","contentType":"file"},{"name":"ch13-00-functional-features.md","path":"src/ch13-00-functional-features.md","contentType":"file"},{"name":"ch13-01-closures.md","path":"src/ch13-01-closures.md","contentType":"file"},{"name":"ch13-02-iterators.md","path":"src/ch13-02-iterators.md","contentType":"file"},{"name":"ch13-03-improving-our-io-project.md","path":"src/ch13-03-improving-our-io-project.md","contentType":"file"},{"name":"ch13-04-performance.md","path":"src/ch13-04-performance.md","contentType":"file"},{"name":"ch14-00-more-about-cargo.md","path":"src/ch14-00-more-about-cargo.md","contentType":"file"},{"name":"ch14-01-release-profiles.md","path":"src/ch14-01-release-profiles.md","contentType":"file"},{"name":"ch14-02-publishing-to-crates-io.md","path":"src/ch14-02-publishing-to-crates-io.md","contentType":"file"},{"name":"ch14-03-cargo-workspaces.md","path":"src/ch14-03-cargo-workspaces.md","contentType":"file"},{"name":"ch14-04-installing-binaries.md","path":"src/ch14-04-installing-binaries.md","contentType":"file"},{"name":"ch14-05-extending-cargo.md","path":"src/ch14-05-extending-cargo.md","contentType":"file"},{"name":"ch15-00-smart-pointers.md","path":"src/ch15-00-smart-pointers.md","contentType":"file"},{"name":"ch15-01-box.md","path":"src/ch15-01-box.md","contentType":"file"},{"name":"ch15-02-deref.md","path":"src/ch15-02-deref.md","contentType":"file"},{"name":"ch15-03-drop.md","path":"src/ch15-03-drop.md","contentType":"file"},{"name":"ch15-04-rc.md","path":"src/ch15-04-rc.md","contentType":"file"},{"name":"ch15-05-interior-mutability.md","path":"src/ch15-05-interior-mutability.md","contentType":"file"},{"name":"ch15-06-reference-cycles.md","path":"src/ch15-06-reference-cycles.md","contentType":"file"},{"name":"ch16-00-concurrency.md","path":"src/ch16-00-concurrency.md","contentType":"file"},{"name":"ch16-01-threads.md","path":"src/ch16-01-threads.md","contentType":"file"},{"name":"ch16-02-message-passing.md","path":"src/ch16-02-message-passing.md","contentType":"file"},{"name":"ch16-03-shared-state.md","path":"src/ch16-03-shared-state.md","contentType":"file"},{"name":"ch16-04-extensible-concurrency-sync-and-send.md","path":"src/ch16-04-extensible-concurrency-sync-and-send.md","contentType":"file"},{"name":"ch17-00-oop.md","path":"src/ch17-00-oop.md","contentType":"file"},{"name":"ch17-01-what-is-oo.md","path":"src/ch17-01-what-is-oo.md","contentType":"file"},{"name":"ch17-02-trait-objects.md","path":"src/ch17-02-trait-objects.md","contentType":"file"},{"name":"ch17-03-oo-design-patterns.md","path":"src/ch17-03-oo-design-patterns.md","contentType":"file"},{"name":"ch18-00-patterns.md","path":"src/ch18-00-patterns.md","contentType":"file"},{"name":"ch18-01-all-the-places-for-patterns.md","path":"src/ch18-01-all-the-places-for-patterns.md","contentType":"file"},{"name":"ch18-02-refutability.md","path":"src/ch18-02-refutability.md","contentType":"file"},{"name":"ch18-03-pattern-syntax.md","path":"src/ch18-03-pattern-syntax.md","contentType":"file"},{"name":"ch19-00-advanced-features.md","path":"src/ch19-00-advanced-features.md","contentType":"file"},{"name":"ch19-01-unsafe-rust.md","path":"src/ch19-01-unsafe-rust.md","contentType":"file"},{"name":"ch19-03-advanced-traits.md","path":"src/ch19-03-advanced-traits.md","contentType":"file"},{"name":"ch19-04-advanced-types.md","path":"src/ch19-04-advanced-types.md","contentType":"file"},{"name":"ch19-05-advanced-functions-and-closures.md","path":"src/ch19-05-advanced-functions-and-closures.md","contentType":"file"},{"name":"ch19-06-macros.md","path":"src/ch19-06-macros.md","contentType":"file"},{"name":"ch20-00-final-project-a-web-server.md","path":"src/ch20-00-final-project-a-web-server.md","contentType":"file"},{"name":"ch20-01-single-threaded.md","path":"src/ch20-01-single-threaded.md","contentType":"file"},{"name":"ch20-02-multithreaded.md","path":"src/ch20-02-multithreaded.md","contentType":"file"},{"name":"ch20-03-graceful-shutdown-and-cleanup.md","path":"src/ch20-03-graceful-shutdown-and-cleanup.md","contentType":"file"},{"name":"foreword.md","path":"src/foreword.md","contentType":"file"},{"name":"title-page.md","path":"src/title-page.md","contentType":"file"}],"totalCount":106},"":{"items":[{"name":".cargo","path":".cargo","contentType":"directory"},{"name":".github","path":".github","contentType":"directory"},{"name":"2018-edition","path":"2018-edition","contentType":"directory"},{"name":"ci","path":"ci","contentType":"directory"},{"name":"dot","path":"dot","contentType":"directory"},{"name":"first-edition","path":"first-edition","contentType":"directory"},{"name":"listings","path":"listings","contentType":"directory"},{"name":"nostarch","path":"nostarch","contentType":"directory"},{"name":"redirects","path":"redirects","contentType":"directory"},{"name":"second-edition","path":"second-edition","contentType":"directory"},{"name":"src","path":"src","contentType":"directory"},{"name":"theme","path":"theme","contentType":"directory"},{"name":"tools","path":"tools","contentType":"directory"},{"name":".gitattributes","path":".gitattributes","contentType":"file"},{"name":".gitignore","path":".gitignore","contentType":"file"},{"name":"ADMIN_TASKS.md","path":"ADMIN_TASKS.md","contentType":"file"},{"name":"CONTRIBUTING.md","path":"CONTRIBUTING.md","contentType":"file"},{"name":"COPYRIGHT","path":"COPYRIGHT","contentType":"file"},{"name":"Cargo.lock","path":"Cargo.lock","contentType":"file"},{"name":"Cargo.toml","path":"Cargo.toml","contentType":"file"},{"name":"LICENSE-APACHE","path":"LICENSE-APACHE","contentType":"file"},{"name":"LICENSE-MIT","path":"LICENSE-MIT","contentType":"file"},{"name":"README.md","path":"README.md","contentType":"file"},{"name":"TODO.md","path":"TODO.md","contentType":"file"},{"name":"book.toml","path":"book.toml","contentType":"file"},{"name":"ferris.css","path":"ferris.css","contentType":"file"},{"name":"ferris.js","path":"ferris.js","contentType":"file"},{"name":"rust-toolchain","path":"rust-toolchain","contentType":"file"},{"name":"rustfmt.toml","path":"rustfmt.toml","contentType":"file"},{"name":"style-guide.md","path":"style-guide.md","contentType":"file"}],"totalCount":30}},"fileTreeProcessingTime":15.056233,"foldersToFetch":[],"reducedMotionEnabled":null,"repo":{"id":47854924,"defaultBranch":"main","name":"book","ownerLogin":"rust-lang","currentUserCanPush":false,"isFork":false,"isEmpty":false,"createdAt":"2015-12-11T22:49:49.000Z","ownerAvatar":"https://avatars.githubusercontent.com/u/5430905?v=4","public":true,"private":false,"isOrgOwned":true},"symbolsExpanded":false,"treeExpanded":true,"refInfo":{"name":"main","listCacheKey":"v0:1688046669.0","canEdit":false,"refType":"branch","currentOid":"72187f5cd0beaaa9c6f584156bcd88f921871e83"},"path":"src/ch15-01-box.md","currentUser":null,"blob":{"rawLines":null,"stylingDirectives":null,"csv":null,"csvError":null,"dependabotInfo":{"showConfigurationBanner":false,"configFilePath":null,"networkDependabotPath":"/rust-lang/book/network/updates","dismissConfigurationNoticePath":"/settings/dismiss-notice/dependabot_configuration_notice","configurationNoticeDismissed":null,"repoAlertsPath":"/rust-lang/book/security/dependabot","repoSecurityAndAnalysisPath":"/rust-lang/book/settings/security_analysis","repoOwnerIsOrg":true,"currentUserCanAdminRepo":false},"displayName":"ch15-01-box.md","displayUrl":"https://github.com/rust-lang/book/blob/main/src/ch15-01-box.md?raw=true","headerInfo":{"blobSize":"12.1 KB","deleteInfo":{"deleteTooltip":"You must be signed in to make or propose changes"},"editInfo":{"editTooltip":"You must be signed in to make or propose changes"},"ghDesktopPath":"https://desktop.github.com","gitLfsPath":null,"onBranch":true,"shortPath":"8380625","siteNavLoginPath":"/login?return_to=https%3A%2F%2Fgithub.com%2Frust-lang%2Fbook%2Fblob%2Fmain%2Fsrc%2Fch15-01-box.md","isCSV":false,"isRichtext":true,"toc":[{"level":2,"text":"Using Box<T> to Point to Data on the Heap","anchor":"using-boxt-to-point-to-data-on-the-heap","htmlText":"Using Box&lt;T&gt; to Point to Data on the Heap"},{"level":3,"text":"Using a Box<T> to Store Data on the Heap","anchor":"using-a-boxt-to-store-data-on-the-heap","htmlText":"Using a Box&lt;T&gt; to Store Data on the Heap"},{"level":3,"text":"Enabling Recursive Types with Boxes","anchor":"enabling-recursive-types-with-boxes","htmlText":"Enabling Recursive Types with Boxes"},{"level":4,"text":"More Information About the Cons List","anchor":"more-information-about-the-cons-list","htmlText":"More Information About the Cons List"},{"level":4,"text":"Computing the Size of a Non-Recursive Type","anchor":"computing-the-size-of-a-non-recursive-type","htmlText":"Computing the Size of a Non-Recursive Type"},{"level":4,"text":"Using Box<T> to Get a Recursive Type with a Known Size","anchor":"using-boxt-to-get-a-recursive-type-with-a-known-size","htmlText":"Using Box&lt;T&gt; to Get a Recursive Type with a Known Size"}],"lineInfo":{"truncatedLoc":"255","truncatedSloc":"197"},"mode":"file"},"image":false,"isCodeownersFile":null,"isPlain":false,"isValidLegacyIssueTemplate":false,"issueTemplateHelpUrl":"https://docs.github.com/articles/about-issue-and-pull-request-templates","issueTemplate":null,"discussionTemplate":null,"language":"Markdown","languageID":222,"large":false,"loggedIn":false,"newDiscussionPath":"/rust-lang/book/discussions/new","newIssuePath":"/rust-lang/book/issues/new","planSupportInfo":{"repoIsFork":null,"repoOwnedByCurrentUser":null,"requestFullPath":"/rust-lang/book/blob/main/src/ch15-01-box.md","showFreeOrgGatedFeatureMessage":null,"showPlanSupportBanner":null,"upgradeDataAttributes":null,"upgradePath":null},"publishBannersInfo":{"dismissActionNoticePath":"/settings/dismiss-notice/publish_action_from_dockerfile","dismissStackNoticePath":"/settings/dismiss-notice/publish_stack_from_file","releasePath":"/rust-lang/book/releases/new?marketplace=true","showPublishActionBanner":false,"showPublishStackBanner":false},"renderImageOrRaw":false,"richText":"<article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><h2 tabindex=\"-1\" id=\"user-content-using-boxt-to-point-to-data-on-the-heap\" dir=\"auto\"><a class=\"heading-link\" href=\"#using-boxt-to-point-to-data-on-the-heap\">Using <code>Box&lt;T&gt;</code> to Point to Data on the Heap<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">The most straightforward smart pointer is a <em>box</em>, whose type is written\n<code>Box&lt;T&gt;</code>. Boxes allow you to store data on the heap rather than the stack. What\nremains on the stack is the pointer to the heap data. Refer to Chapter 4 to\nreview the difference between the stack and the heap.</p>\n<p dir=\"auto\">Boxes don’t have performance overhead, other than storing their data on the\nheap instead of on the stack. But they don’t have many extra capabilities\neither. You’ll use them most often in these situations:</p>\n<ul dir=\"auto\">\n<li>When you have a type whose size can’t be known at compile time and you want\nto use a value of that type in a context that requires an exact size</li>\n<li>When you have a large amount of data and you want to transfer ownership but\nensure the data won’t be copied when you do so</li>\n<li>When you want to own a value and you care only that it’s a type that\nimplements a particular trait rather than being of a specific type</li>\n</ul>\n<p dir=\"auto\">We’ll demonstrate the first situation in the <a href=\"#enabling-recursive-types-with-boxes\">“Enabling Recursive Types with\nBoxes”</a> section. In the\nsecond case, transferring ownership of a large amount of data can take a long\ntime because the data is copied around on the stack. To improve performance in\nthis situation, we can store the large amount of data on the heap in a box.\nThen, only the small amount of pointer data is copied around on the stack,\nwhile the data it references stays in one place on the heap. The third case is\nknown as a <em>trait object</em>, and Chapter 17 devotes an entire section, <a href=\"/rust-lang/book/blob/main/src/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\">“Using\nTrait Objects That Allow for Values of Different Types,”</a> just to that topic. So what you learn here you’ll apply again in\nChapter 17!</p>\n<h3 tabindex=\"-1\" id=\"user-content-using-a-boxt-to-store-data-on-the-heap\" dir=\"auto\"><a class=\"heading-link\" href=\"#using-a-boxt-to-store-data-on-the-heap\">Using a <code>Box&lt;T&gt;</code> to Store Data on the Heap<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">Before we discuss the heap storage use case for <code>Box&lt;T&gt;</code>, we’ll cover the\nsyntax and how to interact with values stored within a <code>Box&lt;T&gt;</code>.</p>\n<p dir=\"auto\">Listing 15-1 shows how to use a box to store an <code>i32</code> value on the heap:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-01/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">01</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-1: Storing an <code>i32</code> value on the heap using a\nbox</span></p>\n<p dir=\"auto\">We define the variable <code>b</code> to have the value of a <code>Box</code> that points to the\nvalue <code>5</code>, which is allocated on the heap. This program will print <code>b = 5</code>; in\nthis case, we can access the data in the box similar to how we would if this\ndata were on the stack. Just like any owned value, when a box goes out of\nscope, as <code>b</code> does at the end of <code>main</code>, it will be deallocated. The\ndeallocation happens both for the box (stored on the stack) and the data it\npoints to (stored on the heap).</p>\n<p dir=\"auto\">Putting a single value on the heap isn’t very useful, so you won’t use boxes by\nthemselves in this way very often. Having values like a single <code>i32</code> on the\nstack, where they’re stored by default, is more appropriate in the majority of\nsituations. Let’s look at a case where boxes allow us to define types that we\nwouldn’t be allowed to if we didn’t have boxes.</p>\n<h3 tabindex=\"-1\" id=\"user-content-enabling-recursive-types-with-boxes\" dir=\"auto\"><a class=\"heading-link\" href=\"#enabling-recursive-types-with-boxes\">Enabling Recursive Types with Boxes<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">A value of <em>recursive type</em> can have another value of the same type as part of\nitself. Recursive types pose an issue because at compile time Rust needs to\nknow how much space a type takes up. However, the nesting of values of\nrecursive types could theoretically continue infinitely, so Rust can’t know how\nmuch space the value needs. Because boxes have a known size, we can enable\nrecursive types by inserting a box in the recursive type definition.</p>\n<p dir=\"auto\">As an example of a recursive type, let’s explore the <em>cons list</em>. This is a data\ntype commonly found in functional programming languages. The cons list type\nwe’ll define is straightforward except for the recursion; therefore, the\nconcepts in the example we’ll work with will be useful any time you get into\nmore complex situations involving recursive types.</p>\n<h4 tabindex=\"-1\" id=\"user-content-more-information-about-the-cons-list\" dir=\"auto\"><a class=\"heading-link\" href=\"#more-information-about-the-cons-list\">More Information About the Cons List<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">A <em>cons list</em> is a data structure that comes from the Lisp programming language\nand its dialects and is made up of nested pairs, and is the Lisp version of a\nlinked list. Its name comes from the <code>cons</code> function (short for “construct\nfunction”) in Lisp that constructs a new pair from its two arguments. By\ncalling <code>cons</code> on a pair consisting of a value and another pair, we can\nconstruct cons lists made up of recursive pairs.</p>\n<p dir=\"auto\">For example, here’s a pseudocode representation of a cons list containing the\nlist 1, 2, 3 with each pair in parentheses:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"(1, (2, (3, Nil)))\"><pre lang=\"text\" class=\"notranslate\"><code>(1, (2, (3, Nil)))\n</code></pre></div>\n<p dir=\"auto\">Each item in a cons list contains two elements: the value of the current item\nand the next item. The last item in the list contains only a value called <code>Nil</code>\nwithout a next item. A cons list is produced by recursively calling the <code>cons</code>\nfunction. The canonical name to denote the base case of the recursion is <code>Nil</code>.\nNote that this is not the same as the “null” or “nil” concept in Chapter 6,\nwhich is an invalid or absent value.</p>\n<p dir=\"auto\">The cons list isn’t a commonly used data structure in Rust. Most of the time\nwhen you have a list of items in Rust, <code>Vec&lt;T&gt;</code> is a better choice to use.\nOther, more complex recursive data types <em>are</em> useful in various situations,\nbut by starting with the cons list in this chapter, we can explore how boxes\nlet us define a recursive data type without much distraction.</p>\n<p dir=\"auto\">Listing 15-2 contains an enum definition for a cons list. Note that this code\nwon’t compile yet because the <code>List</code> type doesn’t have a known size, which\nwe’ll demonstrate.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-02/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">02</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-2: The first attempt at defining an enum to\nrepresent a cons list data structure of <code>i32</code> values</span></p>\n<blockquote>\n<p dir=\"auto\">Note: We’re implementing a cons list that holds only <code>i32</code> values for the\npurposes of this example. We could have implemented it using generics, as we\ndiscussed in Chapter 10, to define a cons list type that could store values of\nany type.</p>\n</blockquote>\n<p dir=\"auto\">Using the <code>List</code> type to store the list <code>1, 2, 3</code> would look like the code in\nListing 15-3:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-03/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">03</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-3: Using the <code>List</code> enum to store the list <code>1, 2, 3</code></span></p>\n<p dir=\"auto\">The first <code>Cons</code> value holds <code>1</code> and another <code>List</code> value. This <code>List</code> value is\nanother <code>Cons</code> value that holds <code>2</code> and another <code>List</code> value. This <code>List</code> value\nis one more <code>Cons</code> value that holds <code>3</code> and a <code>List</code> value, which is finally\n<code>Nil</code>, the non-recursive variant that signals the end of the list.</p>\n<p dir=\"auto\">If we try to compile the code in Listing 15-3, we get the error shown in\nListing 15-4:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch15-smart-pointers/listing-15-03/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch15-smart-pointers/listing-15-03/output.txt}}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-4: The error we get when attempting to define\na recursive enum</span></p>\n<p dir=\"auto\">The error shows this type “has infinite size.” The reason is that we’ve defined\n<code>List</code> with a variant that is recursive: it holds another value of itself\ndirectly. As a result, Rust can’t figure out how much space it needs to store a\n<code>List</code> value. Let’s break down why we get this error. First, we’ll look at how\nRust decides how much space it needs to store a value of a non-recursive type.</p>\n<h4 tabindex=\"-1\" id=\"user-content-computing-the-size-of-a-non-recursive-type\" dir=\"auto\"><a class=\"heading-link\" href=\"#computing-the-size-of-a-non-recursive-type\">Computing the Size of a Non-Recursive Type<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">Recall the <code>Message</code> enum we defined in Listing 6-2 when we discussed enum\ndefinitions in Chapter 6:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-02/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-<span class=\"pl-c1\">06</span>-<span class=\"pl-c1\">02</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">To determine how much space to allocate for a <code>Message</code> value, Rust goes\nthrough each of the variants to see which variant needs the most space. Rust\nsees that <code>Message::Quit</code> doesn’t need any space, <code>Message::Move</code> needs enough\nspace to store two <code>i32</code> values, and so forth. Because only one variant will be\nused, the most space a <code>Message</code> value will need is the space it would take to\nstore the largest of its variants.</p>\n<p dir=\"auto\">Contrast this with what happens when Rust tries to determine how much space a\nrecursive type like the <code>List</code> enum in Listing 15-2 needs. The compiler starts\nby looking at the <code>Cons</code> variant, which holds a value of type <code>i32</code> and a value\nof type <code>List</code>. Therefore, <code>Cons</code> needs an amount of space equal to the size of\nan <code>i32</code> plus the size of a <code>List</code>. To figure out how much memory the <code>List</code>\ntype needs, the compiler looks at the variants, starting with the <code>Cons</code>\nvariant. The <code>Cons</code> variant holds a value of type <code>i32</code> and a value of type\n<code>List</code>, and this process continues infinitely, as shown in Figure 15-1.</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/rust-lang/book/blob/main/src/img/trpl15-01.svg\"><img alt=\"An infinite Cons list\" src=\"/rust-lang/book/raw/main/src/img/trpl15-01.svg\" style=\"width: 50%; max-width: 100%;\"></a></p>\n<p dir=\"auto\"><span>Figure 15-1: An infinite <code>List</code> consisting of infinite\n<code>Cons</code> variants</span></p>\n<h4 tabindex=\"-1\" id=\"user-content-using-boxt-to-get-a-recursive-type-with-a-known-size\" dir=\"auto\"><a class=\"heading-link\" href=\"#using-boxt-to-get-a-recursive-type-with-a-known-size\">Using <code>Box&lt;T&gt;</code> to Get a Recursive Type with a Known Size<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">Because Rust can’t figure out how much space to allocate for recursively\ndefined types, the compiler gives an error with this helpful suggestion:</p>\n\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable\n  |\n2 |     Cons(i32, Box&lt;List&gt;),\n  |               ++++    +\"><pre lang=\"text\" class=\"notranslate\"><code>help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable\n  |\n2 |     Cons(i32, Box&lt;List&gt;),\n  |               ++++    +\n</code></pre></div>\n<p dir=\"auto\">In this suggestion, “indirection” means that instead of storing a value\ndirectly, we should change the data structure to store the value indirectly by\nstoring a pointer to the value instead.</p>\n<p dir=\"auto\">Because a <code>Box&lt;T&gt;</code> is a pointer, Rust always knows how much space a <code>Box&lt;T&gt;</code>\nneeds: a pointer’s size doesn’t change based on the amount of data it’s\npointing to. This means we can put a <code>Box&lt;T&gt;</code> inside the <code>Cons</code> variant instead\nof another <code>List</code> value directly. The <code>Box&lt;T&gt;</code> will point to the next <code>List</code>\nvalue that will be on the heap rather than inside the <code>Cons</code> variant.\nConceptually, we still have a list, created with lists holding other lists, but\nthis implementation is now more like placing the items next to one another\nrather than inside one another.</p>\n<p dir=\"auto\">We can change the definition of the <code>List</code> enum in Listing 15-2 and the usage\nof the <code>List</code> in Listing 15-3 to the code in Listing 15-5, which will compile:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-05/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">05</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-5: Definition of <code>List</code> that uses <code>Box&lt;T&gt;</code> in\norder to have a known size</span></p>\n<p dir=\"auto\">The <code>Cons</code> variant needs the size of an <code>i32</code> plus the space to store the\nbox’s pointer data. The <code>Nil</code> variant stores no values, so it needs less space\nthan the <code>Cons</code> variant. We now know that any <code>List</code> value will take up the\nsize of an <code>i32</code> plus the size of a box’s pointer data. By using a box, we’ve\nbroken the infinite, recursive chain, so the compiler can figure out the size\nit needs to store a <code>List</code> value. Figure 15-2 shows what the <code>Cons</code> variant\nlooks like now.</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/rust-lang/book/blob/main/src/img/trpl15-02.svg\"><img alt=\"A finite Cons list\" src=\"/rust-lang/book/raw/main/src/img/trpl15-02.svg\" style=\"max-width: 100%;\"></a></p>\n<p dir=\"auto\"><span>Figure 15-2: A <code>List</code> that is not infinitely sized\nbecause <code>Cons</code> holds a <code>Box</code></span></p>\n<p dir=\"auto\">Boxes provide only the indirection and heap allocation; they don’t have any\nother special capabilities, like those we’ll see with the other smart pointer\ntypes. They also don’t have the performance overhead that these special\ncapabilities incur, so they can be useful in cases like the cons list where the\nindirection is the only feature we need. We’ll look at more use cases for boxes\nin Chapter 17, too.</p>\n<p dir=\"auto\">The <code>Box&lt;T&gt;</code> type is a smart pointer because it implements the <code>Deref</code> trait,\nwhich allows <code>Box&lt;T&gt;</code> values to be treated like references. When a <code>Box&lt;T&gt;</code>\nvalue goes out of scope, the heap data that the box is pointing to is cleaned\nup as well because of the <code>Drop</code> trait implementation. These two traits will be\neven more important to the functionality provided by the other smart pointer\ntypes we’ll discuss in the rest of this chapter. Let’s explore these two traits\nin more detail.</p>\n</article>","renderedFileInfo":null,"shortPath":null,"tabSize":8,"topBannersInfo":{"overridingGlobalFundingFile":false,"globalPreferredFundingPath":null,"repoOwner":"rust-lang","repoName":"book","showInvalidCitationWarning":false,"citationHelpUrl":"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/about-citation-files","showDependabotConfigurationBanner":false,"actionsOnboardingTip":null},"truncated":false,"viewable":true,"workflowRedirectUrl":null,"symbols":{"timedOut":false,"notAnalyzed":true,"symbols":[]}},"copilotInfo":null,"csrf_tokens":{"/rust-lang/book/branches":{"post":"K44TG0DWMHtf6O9cLHJph0bl8iJIxNkOOd7vhAzywj-_UdILkv98Lv7Ic1pa4Sim3XFDBIqc8Zdq-T_IjaOtgA"},"/repos/preferences":{"post":"uYJlENfoykmoYB8N5AbknwmWOCDZbyWTj3_Sv-okjS6omJnSaoTpaYGEBJ1PWPXPeokrK9v4qbL2XLDkWIcVdQ"}}},"title":"book/src/ch15-01-box.md at main · rust-lang/book"}
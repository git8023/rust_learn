{"payload":{"allShortcutsEnabled":false,"fileTree":{"src":{"items":[{"name":"img","path":"src/img","contentType":"directory"},{"name":"SUMMARY.md","path":"src/SUMMARY.md","contentType":"file"},{"name":"appendix-00.md","path":"src/appendix-00.md","contentType":"file"},{"name":"appendix-01-keywords.md","path":"src/appendix-01-keywords.md","contentType":"file"},{"name":"appendix-02-operators.md","path":"src/appendix-02-operators.md","contentType":"file"},{"name":"appendix-03-derivable-traits.md","path":"src/appendix-03-derivable-traits.md","contentType":"file"},{"name":"appendix-04-useful-development-tools.md","path":"src/appendix-04-useful-development-tools.md","contentType":"file"},{"name":"appendix-05-editions.md","path":"src/appendix-05-editions.md","contentType":"file"},{"name":"appendix-06-translation.md","path":"src/appendix-06-translation.md","contentType":"file"},{"name":"appendix-07-nightly-rust.md","path":"src/appendix-07-nightly-rust.md","contentType":"file"},{"name":"ch00-00-introduction.md","path":"src/ch00-00-introduction.md","contentType":"file"},{"name":"ch01-00-getting-started.md","path":"src/ch01-00-getting-started.md","contentType":"file"},{"name":"ch01-01-installation.md","path":"src/ch01-01-installation.md","contentType":"file"},{"name":"ch01-02-hello-world.md","path":"src/ch01-02-hello-world.md","contentType":"file"},{"name":"ch01-03-hello-cargo.md","path":"src/ch01-03-hello-cargo.md","contentType":"file"},{"name":"ch02-00-guessing-game-tutorial.md","path":"src/ch02-00-guessing-game-tutorial.md","contentType":"file"},{"name":"ch03-00-common-programming-concepts.md","path":"src/ch03-00-common-programming-concepts.md","contentType":"file"},{"name":"ch03-01-variables-and-mutability.md","path":"src/ch03-01-variables-and-mutability.md","contentType":"file"},{"name":"ch03-02-data-types.md","path":"src/ch03-02-data-types.md","contentType":"file"},{"name":"ch03-03-how-functions-work.md","path":"src/ch03-03-how-functions-work.md","contentType":"file"},{"name":"ch03-04-comments.md","path":"src/ch03-04-comments.md","contentType":"file"},{"name":"ch03-05-control-flow.md","path":"src/ch03-05-control-flow.md","contentType":"file"},{"name":"ch04-00-understanding-ownership.md","path":"src/ch04-00-understanding-ownership.md","contentType":"file"},{"name":"ch04-01-what-is-ownership.md","path":"src/ch04-01-what-is-ownership.md","contentType":"file"},{"name":"ch04-02-references-and-borrowing.md","path":"src/ch04-02-references-and-borrowing.md","contentType":"file"},{"name":"ch04-03-slices.md","path":"src/ch04-03-slices.md","contentType":"file"},{"name":"ch05-00-structs.md","path":"src/ch05-00-structs.md","contentType":"file"},{"name":"ch05-01-defining-structs.md","path":"src/ch05-01-defining-structs.md","contentType":"file"},{"name":"ch05-02-example-structs.md","path":"src/ch05-02-example-structs.md","contentType":"file"},{"name":"ch05-03-method-syntax.md","path":"src/ch05-03-method-syntax.md","contentType":"file"},{"name":"ch06-00-enums.md","path":"src/ch06-00-enums.md","contentType":"file"},{"name":"ch06-01-defining-an-enum.md","path":"src/ch06-01-defining-an-enum.md","contentType":"file"},{"name":"ch06-02-match.md","path":"src/ch06-02-match.md","contentType":"file"},{"name":"ch06-03-if-let.md","path":"src/ch06-03-if-let.md","contentType":"file"},{"name":"ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","path":"src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","contentType":"file"},{"name":"ch07-01-packages-and-crates.md","path":"src/ch07-01-packages-and-crates.md","contentType":"file"},{"name":"ch07-02-defining-modules-to-control-scope-and-privacy.md","path":"src/ch07-02-defining-modules-to-control-scope-and-privacy.md","contentType":"file"},{"name":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","path":"src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","contentType":"file"},{"name":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","path":"src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","contentType":"file"},{"name":"ch07-05-separating-modules-into-different-files.md","path":"src/ch07-05-separating-modules-into-different-files.md","contentType":"file"},{"name":"ch08-00-common-collections.md","path":"src/ch08-00-common-collections.md","contentType":"file"},{"name":"ch08-01-vectors.md","path":"src/ch08-01-vectors.md","contentType":"file"},{"name":"ch08-02-strings.md","path":"src/ch08-02-strings.md","contentType":"file"},{"name":"ch08-03-hash-maps.md","path":"src/ch08-03-hash-maps.md","contentType":"file"},{"name":"ch09-00-error-handling.md","path":"src/ch09-00-error-handling.md","contentType":"file"},{"name":"ch09-01-unrecoverable-errors-with-panic.md","path":"src/ch09-01-unrecoverable-errors-with-panic.md","contentType":"file"},{"name":"ch09-02-recoverable-errors-with-result.md","path":"src/ch09-02-recoverable-errors-with-result.md","contentType":"file"},{"name":"ch09-03-to-panic-or-not-to-panic.md","path":"src/ch09-03-to-panic-or-not-to-panic.md","contentType":"file"},{"name":"ch10-00-generics.md","path":"src/ch10-00-generics.md","contentType":"file"},{"name":"ch10-01-syntax.md","path":"src/ch10-01-syntax.md","contentType":"file"},{"name":"ch10-02-traits.md","path":"src/ch10-02-traits.md","contentType":"file"},{"name":"ch10-03-lifetime-syntax.md","path":"src/ch10-03-lifetime-syntax.md","contentType":"file"},{"name":"ch11-00-testing.md","path":"src/ch11-00-testing.md","contentType":"file"},{"name":"ch11-01-writing-tests.md","path":"src/ch11-01-writing-tests.md","contentType":"file"},{"name":"ch11-02-running-tests.md","path":"src/ch11-02-running-tests.md","contentType":"file"},{"name":"ch11-03-test-organization.md","path":"src/ch11-03-test-organization.md","contentType":"file"},{"name":"ch12-00-an-io-project.md","path":"src/ch12-00-an-io-project.md","contentType":"file"},{"name":"ch12-01-accepting-command-line-arguments.md","path":"src/ch12-01-accepting-command-line-arguments.md","contentType":"file"},{"name":"ch12-02-reading-a-file.md","path":"src/ch12-02-reading-a-file.md","contentType":"file"},{"name":"ch12-03-improving-error-handling-and-modularity.md","path":"src/ch12-03-improving-error-handling-and-modularity.md","contentType":"file"},{"name":"ch12-04-testing-the-librarys-functionality.md","path":"src/ch12-04-testing-the-librarys-functionality.md","contentType":"file"},{"name":"ch12-05-working-with-environment-variables.md","path":"src/ch12-05-working-with-environment-variables.md","contentType":"file"},{"name":"ch12-06-writing-to-stderr-instead-of-stdout.md","path":"src/ch12-06-writing-to-stderr-instead-of-stdout.md","contentType":"file"},{"name":"ch13-00-functional-features.md","path":"src/ch13-00-functional-features.md","contentType":"file"},{"name":"ch13-01-closures.md","path":"src/ch13-01-closures.md","contentType":"file"},{"name":"ch13-02-iterators.md","path":"src/ch13-02-iterators.md","contentType":"file"},{"name":"ch13-03-improving-our-io-project.md","path":"src/ch13-03-improving-our-io-project.md","contentType":"file"},{"name":"ch13-04-performance.md","path":"src/ch13-04-performance.md","contentType":"file"},{"name":"ch14-00-more-about-cargo.md","path":"src/ch14-00-more-about-cargo.md","contentType":"file"},{"name":"ch14-01-release-profiles.md","path":"src/ch14-01-release-profiles.md","contentType":"file"},{"name":"ch14-02-publishing-to-crates-io.md","path":"src/ch14-02-publishing-to-crates-io.md","contentType":"file"},{"name":"ch14-03-cargo-workspaces.md","path":"src/ch14-03-cargo-workspaces.md","contentType":"file"},{"name":"ch14-04-installing-binaries.md","path":"src/ch14-04-installing-binaries.md","contentType":"file"},{"name":"ch14-05-extending-cargo.md","path":"src/ch14-05-extending-cargo.md","contentType":"file"},{"name":"ch15-00-smart-pointers.md","path":"src/ch15-00-smart-pointers.md","contentType":"file"},{"name":"ch15-01-box.md","path":"src/ch15-01-box.md","contentType":"file"},{"name":"ch15-02-deref.md","path":"src/ch15-02-deref.md","contentType":"file"},{"name":"ch15-03-drop.md","path":"src/ch15-03-drop.md","contentType":"file"},{"name":"ch15-04-rc.md","path":"src/ch15-04-rc.md","contentType":"file"},{"name":"ch15-05-interior-mutability.md","path":"src/ch15-05-interior-mutability.md","contentType":"file"},{"name":"ch15-06-reference-cycles.md","path":"src/ch15-06-reference-cycles.md","contentType":"file"},{"name":"ch16-00-concurrency.md","path":"src/ch16-00-concurrency.md","contentType":"file"},{"name":"ch16-01-threads.md","path":"src/ch16-01-threads.md","contentType":"file"},{"name":"ch16-02-message-passing.md","path":"src/ch16-02-message-passing.md","contentType":"file"},{"name":"ch16-03-shared-state.md","path":"src/ch16-03-shared-state.md","contentType":"file"},{"name":"ch16-04-extensible-concurrency-sync-and-send.md","path":"src/ch16-04-extensible-concurrency-sync-and-send.md","contentType":"file"},{"name":"ch17-00-oop.md","path":"src/ch17-00-oop.md","contentType":"file"},{"name":"ch17-01-what-is-oo.md","path":"src/ch17-01-what-is-oo.md","contentType":"file"},{"name":"ch17-02-trait-objects.md","path":"src/ch17-02-trait-objects.md","contentType":"file"},{"name":"ch17-03-oo-design-patterns.md","path":"src/ch17-03-oo-design-patterns.md","contentType":"file"},{"name":"ch18-00-patterns.md","path":"src/ch18-00-patterns.md","contentType":"file"},{"name":"ch18-01-all-the-places-for-patterns.md","path":"src/ch18-01-all-the-places-for-patterns.md","contentType":"file"},{"name":"ch18-02-refutability.md","path":"src/ch18-02-refutability.md","contentType":"file"},{"name":"ch18-03-pattern-syntax.md","path":"src/ch18-03-pattern-syntax.md","contentType":"file"},{"name":"ch19-00-advanced-features.md","path":"src/ch19-00-advanced-features.md","contentType":"file"},{"name":"ch19-01-unsafe-rust.md","path":"src/ch19-01-unsafe-rust.md","contentType":"file"},{"name":"ch19-03-advanced-traits.md","path":"src/ch19-03-advanced-traits.md","contentType":"file"},{"name":"ch19-04-advanced-types.md","path":"src/ch19-04-advanced-types.md","contentType":"file"},{"name":"ch19-05-advanced-functions-and-closures.md","path":"src/ch19-05-advanced-functions-and-closures.md","contentType":"file"},{"name":"ch19-06-macros.md","path":"src/ch19-06-macros.md","contentType":"file"},{"name":"ch20-00-final-project-a-web-server.md","path":"src/ch20-00-final-project-a-web-server.md","contentType":"file"},{"name":"ch20-01-single-threaded.md","path":"src/ch20-01-single-threaded.md","contentType":"file"},{"name":"ch20-02-multithreaded.md","path":"src/ch20-02-multithreaded.md","contentType":"file"},{"name":"ch20-03-graceful-shutdown-and-cleanup.md","path":"src/ch20-03-graceful-shutdown-and-cleanup.md","contentType":"file"},{"name":"foreword.md","path":"src/foreword.md","contentType":"file"},{"name":"title-page.md","path":"src/title-page.md","contentType":"file"}],"totalCount":106},"":{"items":[{"name":".cargo","path":".cargo","contentType":"directory"},{"name":".github","path":".github","contentType":"directory"},{"name":"2018-edition","path":"2018-edition","contentType":"directory"},{"name":"ci","path":"ci","contentType":"directory"},{"name":"dot","path":"dot","contentType":"directory"},{"name":"first-edition","path":"first-edition","contentType":"directory"},{"name":"listings","path":"listings","contentType":"directory"},{"name":"nostarch","path":"nostarch","contentType":"directory"},{"name":"redirects","path":"redirects","contentType":"directory"},{"name":"second-edition","path":"second-edition","contentType":"directory"},{"name":"src","path":"src","contentType":"directory"},{"name":"theme","path":"theme","contentType":"directory"},{"name":"tools","path":"tools","contentType":"directory"},{"name":".gitattributes","path":".gitattributes","contentType":"file"},{"name":".gitignore","path":".gitignore","contentType":"file"},{"name":"ADMIN_TASKS.md","path":"ADMIN_TASKS.md","contentType":"file"},{"name":"CONTRIBUTING.md","path":"CONTRIBUTING.md","contentType":"file"},{"name":"COPYRIGHT","path":"COPYRIGHT","contentType":"file"},{"name":"Cargo.lock","path":"Cargo.lock","contentType":"file"},{"name":"Cargo.toml","path":"Cargo.toml","contentType":"file"},{"name":"LICENSE-APACHE","path":"LICENSE-APACHE","contentType":"file"},{"name":"LICENSE-MIT","path":"LICENSE-MIT","contentType":"file"},{"name":"README.md","path":"README.md","contentType":"file"},{"name":"TODO.md","path":"TODO.md","contentType":"file"},{"name":"book.toml","path":"book.toml","contentType":"file"},{"name":"ferris.css","path":"ferris.css","contentType":"file"},{"name":"ferris.js","path":"ferris.js","contentType":"file"},{"name":"rust-toolchain","path":"rust-toolchain","contentType":"file"},{"name":"rustfmt.toml","path":"rustfmt.toml","contentType":"file"},{"name":"style-guide.md","path":"style-guide.md","contentType":"file"}],"totalCount":30}},"fileTreeProcessingTime":17.83892,"foldersToFetch":[],"reducedMotionEnabled":null,"repo":{"id":47854924,"defaultBranch":"main","name":"book","ownerLogin":"rust-lang","currentUserCanPush":false,"isFork":false,"isEmpty":false,"createdAt":"2015-12-11T22:49:49.000Z","ownerAvatar":"https://avatars.githubusercontent.com/u/5430905?v=4","public":true,"private":false,"isOrgOwned":true},"symbolsExpanded":false,"treeExpanded":true,"refInfo":{"name":"main","listCacheKey":"v0:1688046669.0","canEdit":false,"refType":"branch","currentOid":"72187f5cd0beaaa9c6f584156bcd88f921871e83"},"path":"src/ch08-02-strings.md","currentUser":null,"blob":{"rawLines":null,"stylingDirectives":null,"csv":null,"csvError":null,"dependabotInfo":{"showConfigurationBanner":false,"configFilePath":null,"networkDependabotPath":"/rust-lang/book/network/updates","dismissConfigurationNoticePath":"/settings/dismiss-notice/dependabot_configuration_notice","configurationNoticeDismissed":null,"repoAlertsPath":"/rust-lang/book/security/dependabot","repoSecurityAndAnalysisPath":"/rust-lang/book/settings/security_analysis","repoOwnerIsOrg":true,"currentUserCanAdminRepo":false},"displayName":"ch08-02-strings.md","displayUrl":"https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md?raw=true","headerInfo":{"blobSize":"16.6 KB","deleteInfo":{"deleteTooltip":"You must be signed in to make or propose changes"},"editInfo":{"editTooltip":"You must be signed in to make or propose changes"},"ghDesktopPath":"https://desktop.github.com","gitLfsPath":null,"onBranch":true,"shortPath":"f38803e","siteNavLoginPath":"/login?return_to=https%3A%2F%2Fgithub.com%2Frust-lang%2Fbook%2Fblob%2Fmain%2Fsrc%2Fch08-02-strings.md","isCSV":false,"isRichtext":true,"toc":[{"level":2,"text":"Storing UTF-8 Encoded Text with Strings","anchor":"storing-utf-8-encoded-text-with-strings","htmlText":"Storing UTF-8 Encoded Text with Strings"},{"level":3,"text":"What Is a String?","anchor":"what-is-a-string","htmlText":"What Is a String?"},{"level":3,"text":"Creating a New String","anchor":"creating-a-new-string","htmlText":"Creating a New String"},{"level":3,"text":"Updating a String","anchor":"updating-a-string","htmlText":"Updating a String"},{"level":4,"text":"Appending to a String with push_str and push","anchor":"appending-to-a-string-with-push_str-and-push","htmlText":"Appending to a String with push_str and push"},{"level":4,"text":"Concatenation with the + Operator or the format! Macro","anchor":"concatenation-with-the--operator-or-the-format-macro","htmlText":"Concatenation with the + Operator or the format! Macro"},{"level":3,"text":"Indexing into Strings","anchor":"indexing-into-strings","htmlText":"Indexing into Strings"},{"level":4,"text":"Internal Representation","anchor":"internal-representation","htmlText":"Internal Representation"},{"level":4,"text":"Bytes and Scalar Values and Grapheme Clusters! Oh My!","anchor":"bytes-and-scalar-values-and-grapheme-clusters-oh-my","htmlText":"Bytes and Scalar Values and Grapheme Clusters! Oh My!"},{"level":3,"text":"Slicing Strings","anchor":"slicing-strings","htmlText":"Slicing Strings"},{"level":3,"text":"Methods for Iterating Over Strings","anchor":"methods-for-iterating-over-strings","htmlText":"Methods for Iterating Over Strings"},{"level":3,"text":"Strings Are Not So Simple","anchor":"strings-are-not-so-simple","htmlText":"Strings Are Not So Simple"}],"lineInfo":{"truncatedLoc":"412","truncatedSloc":"312"},"mode":"file"},"image":false,"isCodeownersFile":null,"isPlain":false,"isValidLegacyIssueTemplate":false,"issueTemplateHelpUrl":"https://docs.github.com/articles/about-issue-and-pull-request-templates","issueTemplate":null,"discussionTemplate":null,"language":"Markdown","languageID":222,"large":false,"loggedIn":false,"newDiscussionPath":"/rust-lang/book/discussions/new","newIssuePath":"/rust-lang/book/issues/new","planSupportInfo":{"repoIsFork":null,"repoOwnedByCurrentUser":null,"requestFullPath":"/rust-lang/book/blob/main/src/ch08-02-strings.md","showFreeOrgGatedFeatureMessage":null,"showPlanSupportBanner":null,"upgradeDataAttributes":null,"upgradePath":null},"publishBannersInfo":{"dismissActionNoticePath":"/settings/dismiss-notice/publish_action_from_dockerfile","dismissStackNoticePath":"/settings/dismiss-notice/publish_stack_from_file","releasePath":"/rust-lang/book/releases/new?marketplace=true","showPublishActionBanner":false,"showPublishStackBanner":false},"renderImageOrRaw":false,"richText":"<article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><h2 tabindex=\"-1\" id=\"user-content-storing-utf-8-encoded-text-with-strings\" dir=\"auto\"><a class=\"heading-link\" href=\"#storing-utf-8-encoded-text-with-strings\">Storing UTF-8 Encoded Text with Strings<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">We talked about strings in Chapter 4, but we’ll look at them in more depth now.\nNew Rustaceans commonly get stuck on strings for a combination of three\nreasons: Rust’s propensity for exposing possible errors, strings being a more\ncomplicated data structure than many programmers give them credit for, and\nUTF-8. These factors combine in a way that can seem difficult when you’re\ncoming from other programming languages.</p>\n<p dir=\"auto\">We discuss strings in the context of collections because strings are\nimplemented as a collection of bytes, plus some methods to provide useful\nfunctionality when those bytes are interpreted as text. In this section, we’ll\ntalk about the operations on <code>String</code> that every collection type has, such as\ncreating, updating, and reading. We’ll also discuss the ways in which <code>String</code>\nis different from the other collections, namely how indexing into a <code>String</code> is\ncomplicated by the differences between how people and computers interpret\n<code>String</code> data.</p>\n<h3 tabindex=\"-1\" id=\"user-content-what-is-a-string\" dir=\"auto\"><a class=\"heading-link\" href=\"#what-is-a-string\">What Is a String?<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">We’ll first define what we mean by the term <em>string</em>. Rust has only one string\ntype in the core language, which is the string slice <code>str</code> that is usually seen\nin its borrowed form <code>&amp;str</code>. In Chapter 4, we talked about <em>string slices</em>,\nwhich are references to some UTF-8 encoded string data stored elsewhere. String\nliterals, for example, are stored in the program’s binary and are therefore\nstring slices.</p>\n<p dir=\"auto\">The <code>String</code> type, which is provided by Rust’s standard library rather than\ncoded into the core language, is a growable, mutable, owned, UTF-8 encoded\nstring type. When Rustaceans refer to “strings” in Rust, they might be\nreferring to either the <code>String</code> or the string slice <code>&amp;str</code> types, not just one\nof those types. Although this section is largely about <code>String</code>, both types are\nused heavily in Rust’s standard library, and both <code>String</code> and string slices\nare UTF-8 encoded.</p>\n<h3 tabindex=\"-1\" id=\"user-content-creating-a-new-string\" dir=\"auto\"><a class=\"heading-link\" href=\"#creating-a-new-string\">Creating a New String<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">Many of the same operations available with <code>Vec&lt;T&gt;</code> are available with <code>String</code>\nas well, because <code>String</code> is actually implemented as a wrapper around a vector\nof bytes with some extra guarantees, restrictions, and capabilities. An example\nof a function that works the same way with <code>Vec&lt;T&gt;</code> and <code>String</code> is the <code>new</code>\nfunction to create an instance, shown in Listing 8-11.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch08-common-collections/listing-08-11/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch08-common-collections/listing-<span class=\"pl-c1\">08</span>-<span class=\"pl-c1\">11</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 8-11: Creating a new, empty <code>String</code></span></p>\n<p dir=\"auto\">This line creates a new empty string called <code>s</code>, which we can then load data\ninto. Often, we’ll have some initial data that we want to start the string\nwith. For that, we use the <code>to_string</code> method, which is available on any type\nthat implements the <code>Display</code> trait, as string literals do. Listing 8-12 shows\ntwo examples.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch08-common-collections/listing-08-12/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch08-common-collections/listing-<span class=\"pl-c1\">08</span>-<span class=\"pl-c1\">12</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 8-12: Using the <code>to_string</code> method to create a\n<code>String</code> from a string literal</span></p>\n<p dir=\"auto\">This code creates a string containing <code>initial contents</code>.</p>\n<p dir=\"auto\">We can also use the function <code>String::from</code> to create a <code>String</code> from a string\nliteral. The code in Listing 8-13 is equivalent to the code from Listing 8-12\nthat uses <code>to_string</code>.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch08-common-collections/listing-08-13/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch08-common-collections/listing-<span class=\"pl-c1\">08</span>-<span class=\"pl-c1\">13</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 8-13: Using the <code>String::from</code> function to create\na <code>String</code> from a string literal</span></p>\n<p dir=\"auto\">Because strings are used for so many things, we can use many different generic\nAPIs for strings, providing us with a lot of options. Some of them can seem\nredundant, but they all have their place! In this case, <code>String::from</code> and\n<code>to_string</code> do the same thing, so which you choose is a matter of style and\nreadability.</p>\n<p dir=\"auto\">Remember that strings are UTF-8 encoded, so we can include any properly encoded\ndata in them, as shown in Listing 8-14.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch08-common-collections/listing-<span class=\"pl-c1\">08</span>-<span class=\"pl-c1\">14</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 8-14: Storing greetings in different languages in\nstrings</span></p>\n<p dir=\"auto\">All of these are valid <code>String</code> values.</p>\n<h3 tabindex=\"-1\" id=\"user-content-updating-a-string\" dir=\"auto\"><a class=\"heading-link\" href=\"#updating-a-string\">Updating a String<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">A <code>String</code> can grow in size and its contents can change, just like the contents\nof a <code>Vec&lt;T&gt;</code>, if you push more data into it. In addition, you can conveniently\nuse the <code>+</code> operator or the <code>format!</code> macro to concatenate <code>String</code> values.</p>\n<h4 tabindex=\"-1\" id=\"user-content-appending-to-a-string-with-push_str-and-push\" dir=\"auto\"><a class=\"heading-link\" href=\"#appending-to-a-string-with-push_str-and-push\">Appending to a String with <code>push_str</code> and <code>push</code><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">We can grow a <code>String</code> by using the <code>push_str</code> method to append a string slice,\nas shown in Listing 8-15.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch08-common-collections/listing-08-15/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch08-common-collections/listing-<span class=\"pl-c1\">08</span>-<span class=\"pl-c1\">15</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 8-15: Appending a string slice to a <code>String</code>\nusing the <code>push_str</code> method</span></p>\n<p dir=\"auto\">After these two lines, <code>s</code> will contain <code>foobar</code>. The <code>push_str</code> method takes a\nstring slice because we don’t necessarily want to take ownership of the\nparameter. For example, in the code in Listing 8-16, we want to be able to use\n<code>s2</code> after appending its contents to <code>s1</code>.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch08-common-collections/listing-08-16/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch08-common-collections/listing-<span class=\"pl-c1\">08</span>-<span class=\"pl-c1\">16</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 8-16: Using a string slice after appending its\ncontents to a <code>String</code></span></p>\n<p dir=\"auto\">If the <code>push_str</code> method took ownership of <code>s2</code>, we wouldn’t be able to print\nits value on the last line. However, this code works as we’d expect!</p>\n<p dir=\"auto\">The <code>push</code> method takes a single character as a parameter and adds it to the\n<code>String</code>. Listing 8-17 adds the letter “l” to a <code>String</code> using the <code>push</code>\nmethod.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch08-common-collections/listing-08-17/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch08-common-collections/listing-<span class=\"pl-c1\">08</span>-<span class=\"pl-c1\">17</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 8-17: Adding one character to a <code>String</code> value\nusing <code>push</code></span></p>\n<p dir=\"auto\">As a result, <code>s</code> will contain <code>lol</code>.</p>\n<h4 tabindex=\"-1\" id=\"user-content-concatenation-with-the--operator-or-the-format-macro\" dir=\"auto\"><a class=\"heading-link\" href=\"#concatenation-with-the--operator-or-the-format-macro\">Concatenation with the <code>+</code> Operator or the <code>format!</code> Macro<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">Often, you’ll want to combine two existing strings. One way to do so is to use\nthe <code>+</code> operator, as shown in Listing 8-18.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch08-common-collections/listing-08-18/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch08-common-collections/listing-<span class=\"pl-c1\">08</span>-<span class=\"pl-c1\">18</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 8-18: Using the <code>+</code> operator to combine two\n<code>String</code> values into a new <code>String</code> value</span></p>\n<p dir=\"auto\">The string <code>s3</code> will contain <code>Hello, world!</code>. The reason <code>s1</code> is no longer\nvalid after the addition, and the reason we used a reference to <code>s2</code>, has to do\nwith the signature of the method that’s called when we use the <code>+</code> operator.\nThe <code>+</code> operator uses the <code>add</code> method, whose signature looks something like\nthis:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"fn add(self, s: &amp;str) -&gt; String {\"><pre><span class=\"pl-k\">fn</span> add<span class=\"pl-kos\">(</span><span class=\"pl-smi\">self</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">s</span><span class=\"pl-kos\">:</span> <span class=\"pl-c1\">&amp;</span><span class=\"pl-smi\">str</span><span class=\"pl-kos\">)</span> -&gt; <span class=\"pl-smi\">String</span> <span class=\"pl-kos\">{</span></pre></div>\n<p dir=\"auto\">In the standard library, you'll see <code>add</code> defined using generics and associated\ntypes. Here, we’ve substituted in concrete types, which is what happens when we\ncall this method with <code>String</code> values. We’ll discuss generics in Chapter 10.\nThis signature gives us the clues we need to understand the tricky bits of the\n<code>+</code> operator.</p>\n<p dir=\"auto\">First, <code>s2</code> has an <code>&amp;</code>, meaning that we’re adding a <em>reference</em> of the second\nstring to the first string. This is because of the <code>s</code> parameter in the <code>add</code>\nfunction: we can only add a <code>&amp;str</code> to a <code>String</code>; we can’t add two <code>String</code>\nvalues together. But wait—the type of <code>&amp;s2</code> is <code>&amp;String</code>, not <code>&amp;str</code>, as\nspecified in the second parameter to <code>add</code>. So why does Listing 8-18 compile?</p>\n<p dir=\"auto\">The reason we’re able to use <code>&amp;s2</code> in the call to <code>add</code> is that the compiler\ncan <em>coerce</em> the <code>&amp;String</code> argument into a <code>&amp;str</code>. When we call the <code>add</code>\nmethod, Rust uses a <em>deref coercion</em>, which here turns <code>&amp;s2</code> into <code>&amp;s2[..]</code>.\nWe’ll discuss deref coercion in more depth in Chapter 15. Because <code>add</code> does\nnot take ownership of the <code>s</code> parameter, <code>s2</code> will still be a valid <code>String</code>\nafter this operation.</p>\n<p dir=\"auto\">Second, we can see in the signature that <code>add</code> takes ownership of <code>self</code>,\nbecause <code>self</code> does <em>not</em> have an <code>&amp;</code>. This means <code>s1</code> in Listing 8-18 will be\nmoved into the <code>add</code> call and will no longer be valid after that. So although\n<code>let s3 = s1 + &amp;s2;</code> looks like it will copy both strings and create a new one,\nthis statement actually takes ownership of <code>s1</code>, appends a copy of the contents\nof <code>s2</code>, and then returns ownership of the result. In other words, it looks\nlike it’s making a lot of copies but isn’t; the implementation is more\nefficient than copying.</p>\n<p dir=\"auto\">If we need to concatenate multiple strings, the behavior of the <code>+</code> operator\ngets unwieldy:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch08-common-collections/no-listing-01-concat-multiple-strings/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch08-common-collections/no-listing-<span class=\"pl-c1\">01</span>-concat-multiple-strings/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">At this point, <code>s</code> will be <code>tic-tac-toe</code>. With all of the <code>+</code> and <code>\"</code>\ncharacters, it’s difficult to see what’s going on. For more complicated string\ncombining, we can instead use the <code>format!</code> macro:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch08-common-collections/no-listing-02-format/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch08-common-collections/no-listing-<span class=\"pl-c1\">02</span>-format/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">This code also sets <code>s</code> to <code>tic-tac-toe</code>. The <code>format!</code> macro works like\n<code>println!</code>, but instead of printing the output to the screen, it returns a\n<code>String</code> with the contents. The version of the code using <code>format!</code> is much\neasier to read, and the code generated by the <code>format!</code> macro uses references\nso that this call doesn’t take ownership of any of its parameters.</p>\n<h3 tabindex=\"-1\" id=\"user-content-indexing-into-strings\" dir=\"auto\"><a class=\"heading-link\" href=\"#indexing-into-strings\">Indexing into Strings<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">In many other programming languages, accessing individual characters in a\nstring by referencing them by index is a valid and common operation. However,\nif you try to access parts of a <code>String</code> using indexing syntax in Rust, you’ll\nget an error. Consider the invalid code in Listing 8-19.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch08-common-collections/listing-08-19/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch08-common-collections/listing-<span class=\"pl-c1\">08</span>-<span class=\"pl-c1\">19</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 8-19: Attempting to use indexing syntax with a\nString</span></p>\n<p dir=\"auto\">This code will result in the following error:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch08-common-collections/listing-08-19/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch08-common-collections/listing-08-19/output.txt}}</span></pre></div>\n<p dir=\"auto\">The error and the note tell the story: Rust strings don’t support indexing. But\nwhy not? To answer that question, we need to discuss how Rust stores strings in\nmemory.</p>\n<h4 tabindex=\"-1\" id=\"user-content-internal-representation\" dir=\"auto\"><a class=\"heading-link\" href=\"#internal-representation\">Internal Representation<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">A <code>String</code> is a wrapper over a <code>Vec&lt;u8&gt;</code>. Let’s look at some of our properly\nencoded UTF-8 example strings from Listing 8-14. First, this one:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:spanish}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch08-common-collections/listing-<span class=\"pl-c1\">08</span>-<span class=\"pl-c1\">14</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>spanish<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">In this case, <code>len</code> will be 4, which means the vector storing the string “Hola”\nis 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. The\nfollowing line, however, may surprise you. (Note that this string begins with\nthe capital Cyrillic letter Ze, not the number 3.)</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:russian}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch08-common-collections/listing-<span class=\"pl-c1\">08</span>-<span class=\"pl-c1\">14</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>russian<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">Asked how long the string is, you might say 12. In fact, Rust’s answer is 24:\nthat’s the number of bytes it takes to encode “Здравствуйте” in UTF-8, because\neach Unicode scalar value in that string takes 2 bytes of storage. Therefore,\nan index into the string’s bytes will not always correlate to a valid Unicode\nscalar value. To demonstrate, consider this invalid Rust code:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"let hello = &quot;Здравствуйте&quot;;\nlet answer = &amp;hello[0];\"><pre><span class=\"pl-k\">let</span> hello = <span class=\"pl-s\">\"Здравствуйте\"</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> answer = <span class=\"pl-c1\">&amp;</span>hello<span class=\"pl-kos\">[</span><span class=\"pl-c1\">0</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">You already know that <code>answer</code> will not be <code>З</code>, the first letter. When encoded\nin UTF-8, the first byte of <code>З</code> is <code>208</code> and the second is <code>151</code>, so it would\nseem that <code>answer</code> should in fact be <code>208</code>, but <code>208</code> is not a valid character\non its own. Returning <code>208</code> is likely not what a user would want if they asked\nfor the first letter of this string; however, that’s the only data that Rust\nhas at byte index 0. Users generally don’t want the byte value returned, even\nif the string contains only Latin letters: if <code>&amp;\"hello\"[0]</code> were valid code\nthat returned the byte value, it would return <code>104</code>, not <code>h</code>.</p>\n<p dir=\"auto\">The answer, then, is that to avoid returning an unexpected value and causing\nbugs that might not be discovered immediately, Rust doesn’t compile this code\nat all and prevents misunderstandings early in the development process.</p>\n<h4 tabindex=\"-1\" id=\"user-content-bytes-and-scalar-values-and-grapheme-clusters-oh-my\" dir=\"auto\"><a class=\"heading-link\" href=\"#bytes-and-scalar-values-and-grapheme-clusters-oh-my\">Bytes and Scalar Values and Grapheme Clusters! Oh My!<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">Another point about UTF-8 is that there are actually three relevant ways to\nlook at strings from Rust’s perspective: as bytes, scalar values, and grapheme\nclusters (the closest thing to what we would call <em>letters</em>).</p>\n<p dir=\"auto\">If we look at the Hindi word “नमस्ते” written in the Devanagari script, it is\nstored as a vector of <code>u8</code> values that looks like this:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,\n224, 165, 135]\"><pre lang=\"text\" class=\"notranslate\"><code>[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,\n224, 165, 135]\n</code></pre></div>\n<p dir=\"auto\">That’s 18 bytes and is how computers ultimately store this data. If we look at\nthem as Unicode scalar values, which are what Rust’s <code>char</code> type is, those\nbytes look like this:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"['न', 'म', 'स', '्', 'त', 'े']\"><pre lang=\"text\" class=\"notranslate\"><code>['न', 'म', 'स', '्', 'त', 'े']\n</code></pre></div>\n<p dir=\"auto\">There are six <code>char</code> values here, but the fourth and sixth are not letters:\nthey’re diacritics that don’t make sense on their own. Finally, if we look at\nthem as grapheme clusters, we’d get what a person would call the four letters\nthat make up the Hindi word:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]\"><pre lang=\"text\" class=\"notranslate\"><code>[\"न\", \"म\", \"स्\", \"ते\"]\n</code></pre></div>\n<p dir=\"auto\">Rust provides different ways of interpreting the raw string data that computers\nstore so that each program can choose the interpretation it needs, no matter\nwhat human language the data is in.</p>\n<p dir=\"auto\">A final reason Rust doesn’t allow us to index into a <code>String</code> to get a\ncharacter is that indexing operations are expected to always take constant time\n(O(1)). But it isn’t possible to guarantee that performance with a <code>String</code>,\nbecause Rust would have to walk through the contents from the beginning to the\nindex to determine how many valid characters there were.</p>\n<h3 tabindex=\"-1\" id=\"user-content-slicing-strings\" dir=\"auto\"><a class=\"heading-link\" href=\"#slicing-strings\">Slicing Strings<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">Indexing into a string is often a bad idea because it’s not clear what the\nreturn type of the string-indexing operation should be: a byte value, a\ncharacter, a grapheme cluster, or a string slice. If you really need to use\nindices to create string slices, therefore, Rust asks you to be more specific.</p>\n<p dir=\"auto\">Rather than indexing using <code>[]</code> with a single number, you can use <code>[]</code> with a\nrange to create a string slice containing particular bytes:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"let hello = &quot;Здравствуйте&quot;;\n\nlet s = &amp;hello[0..4];\"><pre><span class=\"pl-k\">let</span> hello = <span class=\"pl-s\">\"Здравствуйте\"</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">let</span> s = <span class=\"pl-c1\">&amp;</span>hello<span class=\"pl-kos\">[</span><span class=\"pl-c1\">0</span>..<span class=\"pl-c1\">4</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">Here, <code>s</code> will be a <code>&amp;str</code> that contains the first 4 bytes of the string.\nEarlier, we mentioned that each of these characters was 2 bytes, which means\n<code>s</code> will be <code>Зд</code>.</p>\n<p dir=\"auto\">If we were to try to slice only part of a character’s bytes with something like\n<code>&amp;hello[0..1]</code>, Rust would panic at runtime in the same way as if an invalid\nindex were accessed in a vector:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch08-common-collections/output-only-01-not-char-boundary/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch08-common-collections/output-only-01-not-char-boundary/output.txt}}</span></pre></div>\n<p dir=\"auto\">You should use ranges to create string slices with caution, because doing so\ncan crash your program.</p>\n<h3 tabindex=\"-1\" id=\"user-content-methods-for-iterating-over-strings\" dir=\"auto\"><a class=\"heading-link\" href=\"#methods-for-iterating-over-strings\">Methods for Iterating Over Strings<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">The best way to operate on pieces of strings is to be explicit about whether\nyou want characters or bytes. For individual Unicode scalar values, use the\n<code>chars</code> method. Calling <code>chars</code> on “Зд” separates out and returns two values\nof type <code>char</code>, and you can iterate over the result to access each element:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"for c in &quot;Зд&quot;.chars() {\n    println!(&quot;{c}&quot;);\n}\"><pre><span class=\"pl-k\">for</span> c <span class=\"pl-k\">in</span> <span class=\"pl-s\">\"Зд\"</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">chars</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-en\">println</span><span class=\"pl-en\">!</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"{c}\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">This code will print the following:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"З\nд\"><pre lang=\"text\" class=\"notranslate\"><code>З\nд\n</code></pre></div>\n<p dir=\"auto\">Alternatively, the <code>bytes</code> method returns each raw byte, which might be\nappropriate for your domain:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"for b in &quot;Зд&quot;.bytes() {\n    println!(&quot;{b}&quot;);\n}\"><pre><span class=\"pl-k\">for</span> b <span class=\"pl-k\">in</span> <span class=\"pl-s\">\"Зд\"</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">bytes</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-en\">println</span><span class=\"pl-en\">!</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"{b}\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">This code will print the four bytes that make up this string:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"208\n151\n208\n180\"><pre lang=\"text\" class=\"notranslate\"><code>208\n151\n208\n180\n</code></pre></div>\n<p dir=\"auto\">But be sure to remember that valid Unicode scalar values may be made up of more\nthan 1 byte.</p>\n<p dir=\"auto\">Getting grapheme clusters from strings as with the Devanagari script is\ncomplex, so this functionality is not provided by the standard library. Crates\nare available on <a href=\"https://crates.io/\" rel=\"nofollow\">crates.io</a> if this is the\nfunctionality you need.</p>\n<h3 tabindex=\"-1\" id=\"user-content-strings-are-not-so-simple\" dir=\"auto\"><a class=\"heading-link\" href=\"#strings-are-not-so-simple\">Strings Are Not So Simple<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">To summarize, strings are complicated. Different programming languages make\ndifferent choices about how to present this complexity to the programmer. Rust\nhas chosen to make the correct handling of <code>String</code> data the default behavior\nfor all Rust programs, which means programmers have to put more thought into\nhandling UTF-8 data upfront. This trade-off exposes more of the complexity of\nstrings than is apparent in other programming languages, but it prevents you\nfrom having to handle errors involving non-ASCII characters later in your\ndevelopment life cycle.</p>\n<p dir=\"auto\">The good news is that the standard library offers a lot of functionality built\noff the <code>String</code> and <code>&amp;str</code> types to help handle these complex situations\ncorrectly. Be sure to check out the documentation for useful methods like\n<code>contains</code> for searching in a string and <code>replace</code> for substituting parts of a\nstring with another string.</p>\n<p dir=\"auto\">Let’s switch to something a bit less complex: hash maps!</p>\n</article>","renderedFileInfo":null,"shortPath":null,"tabSize":8,"topBannersInfo":{"overridingGlobalFundingFile":false,"globalPreferredFundingPath":null,"repoOwner":"rust-lang","repoName":"book","showInvalidCitationWarning":false,"citationHelpUrl":"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/about-citation-files","showDependabotConfigurationBanner":false,"actionsOnboardingTip":null},"truncated":false,"viewable":true,"workflowRedirectUrl":null,"symbols":{"timedOut":false,"notAnalyzed":true,"symbols":[]}},"copilotInfo":null,"csrf_tokens":{"/rust-lang/book/branches":{"post":"8ZYCLzH5CGv7nSzugC3-1Nt69teru8VoKZZHAgnPgmMdWh20CLXHGbL3gqVXxUsF-TEamYnPCGBtxtwKowUy1Q"},"/repos/preferences":{"post":"zrkygzSMi5ppePSaLFWoR8BHEPxHNOm4NJ_56kRVGDnjtQOvp8_9xsjd5rKTU4tGlKy3lf9s9c40gFLqM7J-kA"}}},"title":"book/src/ch08-02-strings.md at main · rust-lang/book"}
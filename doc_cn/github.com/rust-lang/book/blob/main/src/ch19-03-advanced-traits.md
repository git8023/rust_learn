{"payload":{"allShortcutsEnabled":false,"fileTree":{"src":{"items":[{"name":"img","path":"src/img","contentType":"directory"},{"name":"SUMMARY.md","path":"src/SUMMARY.md","contentType":"file"},{"name":"appendix-00.md","path":"src/appendix-00.md","contentType":"file"},{"name":"appendix-01-keywords.md","path":"src/appendix-01-keywords.md","contentType":"file"},{"name":"appendix-02-operators.md","path":"src/appendix-02-operators.md","contentType":"file"},{"name":"appendix-03-derivable-traits.md","path":"src/appendix-03-derivable-traits.md","contentType":"file"},{"name":"appendix-04-useful-development-tools.md","path":"src/appendix-04-useful-development-tools.md","contentType":"file"},{"name":"appendix-05-editions.md","path":"src/appendix-05-editions.md","contentType":"file"},{"name":"appendix-06-translation.md","path":"src/appendix-06-translation.md","contentType":"file"},{"name":"appendix-07-nightly-rust.md","path":"src/appendix-07-nightly-rust.md","contentType":"file"},{"name":"ch00-00-introduction.md","path":"src/ch00-00-introduction.md","contentType":"file"},{"name":"ch01-00-getting-started.md","path":"src/ch01-00-getting-started.md","contentType":"file"},{"name":"ch01-01-installation.md","path":"src/ch01-01-installation.md","contentType":"file"},{"name":"ch01-02-hello-world.md","path":"src/ch01-02-hello-world.md","contentType":"file"},{"name":"ch01-03-hello-cargo.md","path":"src/ch01-03-hello-cargo.md","contentType":"file"},{"name":"ch02-00-guessing-game-tutorial.md","path":"src/ch02-00-guessing-game-tutorial.md","contentType":"file"},{"name":"ch03-00-common-programming-concepts.md","path":"src/ch03-00-common-programming-concepts.md","contentType":"file"},{"name":"ch03-01-variables-and-mutability.md","path":"src/ch03-01-variables-and-mutability.md","contentType":"file"},{"name":"ch03-02-data-types.md","path":"src/ch03-02-data-types.md","contentType":"file"},{"name":"ch03-03-how-functions-work.md","path":"src/ch03-03-how-functions-work.md","contentType":"file"},{"name":"ch03-04-comments.md","path":"src/ch03-04-comments.md","contentType":"file"},{"name":"ch03-05-control-flow.md","path":"src/ch03-05-control-flow.md","contentType":"file"},{"name":"ch04-00-understanding-ownership.md","path":"src/ch04-00-understanding-ownership.md","contentType":"file"},{"name":"ch04-01-what-is-ownership.md","path":"src/ch04-01-what-is-ownership.md","contentType":"file"},{"name":"ch04-02-references-and-borrowing.md","path":"src/ch04-02-references-and-borrowing.md","contentType":"file"},{"name":"ch04-03-slices.md","path":"src/ch04-03-slices.md","contentType":"file"},{"name":"ch05-00-structs.md","path":"src/ch05-00-structs.md","contentType":"file"},{"name":"ch05-01-defining-structs.md","path":"src/ch05-01-defining-structs.md","contentType":"file"},{"name":"ch05-02-example-structs.md","path":"src/ch05-02-example-structs.md","contentType":"file"},{"name":"ch05-03-method-syntax.md","path":"src/ch05-03-method-syntax.md","contentType":"file"},{"name":"ch06-00-enums.md","path":"src/ch06-00-enums.md","contentType":"file"},{"name":"ch06-01-defining-an-enum.md","path":"src/ch06-01-defining-an-enum.md","contentType":"file"},{"name":"ch06-02-match.md","path":"src/ch06-02-match.md","contentType":"file"},{"name":"ch06-03-if-let.md","path":"src/ch06-03-if-let.md","contentType":"file"},{"name":"ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","path":"src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","contentType":"file"},{"name":"ch07-01-packages-and-crates.md","path":"src/ch07-01-packages-and-crates.md","contentType":"file"},{"name":"ch07-02-defining-modules-to-control-scope-and-privacy.md","path":"src/ch07-02-defining-modules-to-control-scope-and-privacy.md","contentType":"file"},{"name":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","path":"src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","contentType":"file"},{"name":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","path":"src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","contentType":"file"},{"name":"ch07-05-separating-modules-into-different-files.md","path":"src/ch07-05-separating-modules-into-different-files.md","contentType":"file"},{"name":"ch08-00-common-collections.md","path":"src/ch08-00-common-collections.md","contentType":"file"},{"name":"ch08-01-vectors.md","path":"src/ch08-01-vectors.md","contentType":"file"},{"name":"ch08-02-strings.md","path":"src/ch08-02-strings.md","contentType":"file"},{"name":"ch08-03-hash-maps.md","path":"src/ch08-03-hash-maps.md","contentType":"file"},{"name":"ch09-00-error-handling.md","path":"src/ch09-00-error-handling.md","contentType":"file"},{"name":"ch09-01-unrecoverable-errors-with-panic.md","path":"src/ch09-01-unrecoverable-errors-with-panic.md","contentType":"file"},{"name":"ch09-02-recoverable-errors-with-result.md","path":"src/ch09-02-recoverable-errors-with-result.md","contentType":"file"},{"name":"ch09-03-to-panic-or-not-to-panic.md","path":"src/ch09-03-to-panic-or-not-to-panic.md","contentType":"file"},{"name":"ch10-00-generics.md","path":"src/ch10-00-generics.md","contentType":"file"},{"name":"ch10-01-syntax.md","path":"src/ch10-01-syntax.md","contentType":"file"},{"name":"ch10-02-traits.md","path":"src/ch10-02-traits.md","contentType":"file"},{"name":"ch10-03-lifetime-syntax.md","path":"src/ch10-03-lifetime-syntax.md","contentType":"file"},{"name":"ch11-00-testing.md","path":"src/ch11-00-testing.md","contentType":"file"},{"name":"ch11-01-writing-tests.md","path":"src/ch11-01-writing-tests.md","contentType":"file"},{"name":"ch11-02-running-tests.md","path":"src/ch11-02-running-tests.md","contentType":"file"},{"name":"ch11-03-test-organization.md","path":"src/ch11-03-test-organization.md","contentType":"file"},{"name":"ch12-00-an-io-project.md","path":"src/ch12-00-an-io-project.md","contentType":"file"},{"name":"ch12-01-accepting-command-line-arguments.md","path":"src/ch12-01-accepting-command-line-arguments.md","contentType":"file"},{"name":"ch12-02-reading-a-file.md","path":"src/ch12-02-reading-a-file.md","contentType":"file"},{"name":"ch12-03-improving-error-handling-and-modularity.md","path":"src/ch12-03-improving-error-handling-and-modularity.md","contentType":"file"},{"name":"ch12-04-testing-the-librarys-functionality.md","path":"src/ch12-04-testing-the-librarys-functionality.md","contentType":"file"},{"name":"ch12-05-working-with-environment-variables.md","path":"src/ch12-05-working-with-environment-variables.md","contentType":"file"},{"name":"ch12-06-writing-to-stderr-instead-of-stdout.md","path":"src/ch12-06-writing-to-stderr-instead-of-stdout.md","contentType":"file"},{"name":"ch13-00-functional-features.md","path":"src/ch13-00-functional-features.md","contentType":"file"},{"name":"ch13-01-closures.md","path":"src/ch13-01-closures.md","contentType":"file"},{"name":"ch13-02-iterators.md","path":"src/ch13-02-iterators.md","contentType":"file"},{"name":"ch13-03-improving-our-io-project.md","path":"src/ch13-03-improving-our-io-project.md","contentType":"file"},{"name":"ch13-04-performance.md","path":"src/ch13-04-performance.md","contentType":"file"},{"name":"ch14-00-more-about-cargo.md","path":"src/ch14-00-more-about-cargo.md","contentType":"file"},{"name":"ch14-01-release-profiles.md","path":"src/ch14-01-release-profiles.md","contentType":"file"},{"name":"ch14-02-publishing-to-crates-io.md","path":"src/ch14-02-publishing-to-crates-io.md","contentType":"file"},{"name":"ch14-03-cargo-workspaces.md","path":"src/ch14-03-cargo-workspaces.md","contentType":"file"},{"name":"ch14-04-installing-binaries.md","path":"src/ch14-04-installing-binaries.md","contentType":"file"},{"name":"ch14-05-extending-cargo.md","path":"src/ch14-05-extending-cargo.md","contentType":"file"},{"name":"ch15-00-smart-pointers.md","path":"src/ch15-00-smart-pointers.md","contentType":"file"},{"name":"ch15-01-box.md","path":"src/ch15-01-box.md","contentType":"file"},{"name":"ch15-02-deref.md","path":"src/ch15-02-deref.md","contentType":"file"},{"name":"ch15-03-drop.md","path":"src/ch15-03-drop.md","contentType":"file"},{"name":"ch15-04-rc.md","path":"src/ch15-04-rc.md","contentType":"file"},{"name":"ch15-05-interior-mutability.md","path":"src/ch15-05-interior-mutability.md","contentType":"file"},{"name":"ch15-06-reference-cycles.md","path":"src/ch15-06-reference-cycles.md","contentType":"file"},{"name":"ch16-00-concurrency.md","path":"src/ch16-00-concurrency.md","contentType":"file"},{"name":"ch16-01-threads.md","path":"src/ch16-01-threads.md","contentType":"file"},{"name":"ch16-02-message-passing.md","path":"src/ch16-02-message-passing.md","contentType":"file"},{"name":"ch16-03-shared-state.md","path":"src/ch16-03-shared-state.md","contentType":"file"},{"name":"ch16-04-extensible-concurrency-sync-and-send.md","path":"src/ch16-04-extensible-concurrency-sync-and-send.md","contentType":"file"},{"name":"ch17-00-oop.md","path":"src/ch17-00-oop.md","contentType":"file"},{"name":"ch17-01-what-is-oo.md","path":"src/ch17-01-what-is-oo.md","contentType":"file"},{"name":"ch17-02-trait-objects.md","path":"src/ch17-02-trait-objects.md","contentType":"file"},{"name":"ch17-03-oo-design-patterns.md","path":"src/ch17-03-oo-design-patterns.md","contentType":"file"},{"name":"ch18-00-patterns.md","path":"src/ch18-00-patterns.md","contentType":"file"},{"name":"ch18-01-all-the-places-for-patterns.md","path":"src/ch18-01-all-the-places-for-patterns.md","contentType":"file"},{"name":"ch18-02-refutability.md","path":"src/ch18-02-refutability.md","contentType":"file"},{"name":"ch18-03-pattern-syntax.md","path":"src/ch18-03-pattern-syntax.md","contentType":"file"},{"name":"ch19-00-advanced-features.md","path":"src/ch19-00-advanced-features.md","contentType":"file"},{"name":"ch19-01-unsafe-rust.md","path":"src/ch19-01-unsafe-rust.md","contentType":"file"},{"name":"ch19-03-advanced-traits.md","path":"src/ch19-03-advanced-traits.md","contentType":"file"},{"name":"ch19-04-advanced-types.md","path":"src/ch19-04-advanced-types.md","contentType":"file"},{"name":"ch19-05-advanced-functions-and-closures.md","path":"src/ch19-05-advanced-functions-and-closures.md","contentType":"file"},{"name":"ch19-06-macros.md","path":"src/ch19-06-macros.md","contentType":"file"},{"name":"ch20-00-final-project-a-web-server.md","path":"src/ch20-00-final-project-a-web-server.md","contentType":"file"},{"name":"ch20-01-single-threaded.md","path":"src/ch20-01-single-threaded.md","contentType":"file"},{"name":"ch20-02-multithreaded.md","path":"src/ch20-02-multithreaded.md","contentType":"file"},{"name":"ch20-03-graceful-shutdown-and-cleanup.md","path":"src/ch20-03-graceful-shutdown-and-cleanup.md","contentType":"file"},{"name":"foreword.md","path":"src/foreword.md","contentType":"file"},{"name":"title-page.md","path":"src/title-page.md","contentType":"file"}],"totalCount":106},"":{"items":[{"name":".cargo","path":".cargo","contentType":"directory"},{"name":".github","path":".github","contentType":"directory"},{"name":"2018-edition","path":"2018-edition","contentType":"directory"},{"name":"ci","path":"ci","contentType":"directory"},{"name":"dot","path":"dot","contentType":"directory"},{"name":"first-edition","path":"first-edition","contentType":"directory"},{"name":"listings","path":"listings","contentType":"directory"},{"name":"nostarch","path":"nostarch","contentType":"directory"},{"name":"redirects","path":"redirects","contentType":"directory"},{"name":"second-edition","path":"second-edition","contentType":"directory"},{"name":"src","path":"src","contentType":"directory"},{"name":"theme","path":"theme","contentType":"directory"},{"name":"tools","path":"tools","contentType":"directory"},{"name":".gitattributes","path":".gitattributes","contentType":"file"},{"name":".gitignore","path":".gitignore","contentType":"file"},{"name":"ADMIN_TASKS.md","path":"ADMIN_TASKS.md","contentType":"file"},{"name":"CONTRIBUTING.md","path":"CONTRIBUTING.md","contentType":"file"},{"name":"COPYRIGHT","path":"COPYRIGHT","contentType":"file"},{"name":"Cargo.lock","path":"Cargo.lock","contentType":"file"},{"name":"Cargo.toml","path":"Cargo.toml","contentType":"file"},{"name":"LICENSE-APACHE","path":"LICENSE-APACHE","contentType":"file"},{"name":"LICENSE-MIT","path":"LICENSE-MIT","contentType":"file"},{"name":"README.md","path":"README.md","contentType":"file"},{"name":"TODO.md","path":"TODO.md","contentType":"file"},{"name":"book.toml","path":"book.toml","contentType":"file"},{"name":"ferris.css","path":"ferris.css","contentType":"file"},{"name":"ferris.js","path":"ferris.js","contentType":"file"},{"name":"rust-toolchain","path":"rust-toolchain","contentType":"file"},{"name":"rustfmt.toml","path":"rustfmt.toml","contentType":"file"},{"name":"style-guide.md","path":"style-guide.md","contentType":"file"}],"totalCount":30}},"fileTreeProcessingTime":18.238454,"foldersToFetch":[],"reducedMotionEnabled":null,"repo":{"id":47854924,"defaultBranch":"main","name":"book","ownerLogin":"rust-lang","currentUserCanPush":false,"isFork":false,"isEmpty":false,"createdAt":"2015-12-11T22:49:49.000Z","ownerAvatar":"https://avatars.githubusercontent.com/u/5430905?v=4","public":true,"private":false,"isOrgOwned":true},"symbolsExpanded":false,"treeExpanded":true,"refInfo":{"name":"main","listCacheKey":"v0:1688046669.0","canEdit":false,"refType":"branch","currentOid":"72187f5cd0beaaa9c6f584156bcd88f921871e83"},"path":"src/ch19-03-advanced-traits.md","currentUser":null,"blob":{"rawLines":null,"stylingDirectives":null,"csv":null,"csvError":null,"dependabotInfo":{"showConfigurationBanner":false,"configFilePath":null,"networkDependabotPath":"/rust-lang/book/network/updates","dismissConfigurationNoticePath":"/settings/dismiss-notice/dependabot_configuration_notice","configurationNoticeDismissed":null,"repoAlertsPath":"/rust-lang/book/security/dependabot","repoSecurityAndAnalysisPath":"/rust-lang/book/settings/security_analysis","repoOwnerIsOrg":true,"currentUserCanAdminRepo":false},"displayName":"ch19-03-advanced-traits.md","displayUrl":"https://github.com/rust-lang/book/blob/main/src/ch19-03-advanced-traits.md?raw=true","headerInfo":{"blobSize":"21.2 KB","deleteInfo":{"deleteTooltip":"You must be signed in to make or propose changes"},"editInfo":{"editTooltip":"You must be signed in to make or propose changes"},"ghDesktopPath":"https://desktop.github.com","gitLfsPath":null,"onBranch":true,"shortPath":"6fd3e09","siteNavLoginPath":"/login?return_to=https%3A%2F%2Fgithub.com%2Frust-lang%2Fbook%2Fblob%2Fmain%2Fsrc%2Fch19-03-advanced-traits.md","isCSV":false,"isRichtext":true,"toc":[{"level":2,"text":"Advanced Traits","anchor":"advanced-traits","htmlText":"Advanced Traits"},{"level":3,"text":"Specifying Placeholder Types in Trait Definitions with Associated Types","anchor":"specifying-placeholder-types-in-trait-definitions-with-associated-types","htmlText":"Specifying Placeholder Types in Trait Definitions with Associated Types"},{"level":3,"text":"Default Generic Type Parameters and Operator Overloading","anchor":"default-generic-type-parameters-and-operator-overloading","htmlText":"Default Generic Type Parameters and Operator Overloading"},{"level":3,"text":"Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name","anchor":"fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name","htmlText":"Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name"},{"level":3,"text":"Using Supertraits to Require One Trait’s Functionality Within Another Trait","anchor":"using-supertraits-to-require-one-traits-functionality-within-another-trait","htmlText":"Using Supertraits to Require One Trait’s Functionality Within Another Trait"},{"level":3,"text":"Using the Newtype Pattern to Implement External Traits on External Types","anchor":"using-the-newtype-pattern-to-implement-external-traits-on-external-types","htmlText":"Using the Newtype Pattern to Implement External Traits on External Types"}],"lineInfo":{"truncatedLoc":"468","truncatedSloc":"360"},"mode":"file"},"image":false,"isCodeownersFile":null,"isPlain":false,"isValidLegacyIssueTemplate":false,"issueTemplateHelpUrl":"https://docs.github.com/articles/about-issue-and-pull-request-templates","issueTemplate":null,"discussionTemplate":null,"language":"Markdown","languageID":222,"large":false,"loggedIn":false,"newDiscussionPath":"/rust-lang/book/discussions/new","newIssuePath":"/rust-lang/book/issues/new","planSupportInfo":{"repoIsFork":null,"repoOwnedByCurrentUser":null,"requestFullPath":"/rust-lang/book/blob/main/src/ch19-03-advanced-traits.md","showFreeOrgGatedFeatureMessage":null,"showPlanSupportBanner":null,"upgradeDataAttributes":null,"upgradePath":null},"publishBannersInfo":{"dismissActionNoticePath":"/settings/dismiss-notice/publish_action_from_dockerfile","dismissStackNoticePath":"/settings/dismiss-notice/publish_stack_from_file","releasePath":"/rust-lang/book/releases/new?marketplace=true","showPublishActionBanner":false,"showPublishStackBanner":false},"renderImageOrRaw":false,"richText":"<article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><h2 tabindex=\"-1\" id=\"user-content-advanced-traits\" dir=\"auto\"><a class=\"heading-link\" href=\"#advanced-traits\">Advanced Traits<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">We first covered traits in the <a href=\"/rust-lang/book/blob/main/src/ch10-02-traits.html#traits-defining-shared-behavior\">“Traits: Defining Shared\nBehavior”</a> section of Chapter\n10, but we didn’t discuss the more advanced details. Now that you know more\nabout Rust, we can get into the nitty-gritty.</p>\n<h3 tabindex=\"-1\" id=\"user-content-specifying-placeholder-types-in-trait-definitions-with-associated-types\" dir=\"auto\"><a class=\"heading-link\" href=\"#specifying-placeholder-types-in-trait-definitions-with-associated-types\">Specifying Placeholder Types in Trait Definitions with Associated Types<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\"><em>Associated types</em> connect a type placeholder with a trait such that the trait\nmethod definitions can use these placeholder types in their signatures. The\nimplementor of a trait will specify the concrete type to be used instead of the\nplaceholder type for the particular implementation. That way, we can define a\ntrait that uses some types without needing to know exactly what those types are\nuntil the trait is implemented.</p>\n<p dir=\"auto\">We’ve described most of the advanced features in this chapter as being rarely\nneeded. Associated types are somewhere in the middle: they’re used more rarely\nthan features explained in the rest of the book but more commonly than many of\nthe other features discussed in this chapter.</p>\n<p dir=\"auto\">One example of a trait with an associated type is the <code>Iterator</code> trait that the\nstandard library provides. The associated type is named <code>Item</code> and stands in\nfor the type of the values the type implementing the <code>Iterator</code> trait is\niterating over. The definition of the <code>Iterator</code> trait is as shown in Listing\n19-12.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-12/src/lib.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">12</span>/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-12: The definition of the <code>Iterator</code> trait\nthat has an associated type <code>Item</code></span></p>\n<p dir=\"auto\">The type <code>Item</code> is a placeholder, and the <code>next</code> method’s definition shows that\nit will return values of type <code>Option&lt;Self::Item&gt;</code>. Implementors of the\n<code>Iterator</code> trait will specify the concrete type for <code>Item</code>, and the <code>next</code>\nmethod will return an <code>Option</code> containing a value of that concrete type.</p>\n<p dir=\"auto\">Associated types might seem like a similar concept to generics, in that the\nlatter allow us to define a function without specifying what types it can\nhandle. To examine the difference between the two concepts, we’ll look at an\nimplementation of the <code>Iterator</code> trait on a type named <code>Counter</code> that specifies\nthe <code>Item</code> type is <code>u32</code>:</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-22-iterator-on-counter/src/lib.rs:ch19}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/no-listing-<span class=\"pl-c1\">22</span>-iterator-on-counter/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>ch19<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">This syntax seems comparable to that of generics. So why not just define the\n<code>Iterator</code> trait with generics, as shown in Listing 19-13?</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-13/src/lib.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">13</span>/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-13: A hypothetical definition of the\n<code>Iterator</code> trait using generics</span></p>\n<p dir=\"auto\">The difference is that when using generics, as in Listing 19-13, we must\nannotate the types in each implementation; because we can also implement\n<code>Iterator&lt;String&gt; for Counter</code> or any other type, we could have multiple\nimplementations of <code>Iterator</code> for <code>Counter</code>. In other words, when a trait has a\ngeneric parameter, it can be implemented for a type multiple times, changing\nthe concrete types of the generic type parameters each time. When we use the\n<code>next</code> method on <code>Counter</code>, we would have to provide type annotations to\nindicate which implementation of <code>Iterator</code> we want to use.</p>\n<p dir=\"auto\">With associated types, we don’t need to annotate types because we can’t\nimplement a trait on a type multiple times. In Listing 19-12 with the\ndefinition that uses associated types, we can only choose what the type of\n<code>Item</code> will be once, because there can only be one <code>impl Iterator for Counter</code>.\nWe don’t have to specify that we want an iterator of <code>u32</code> values everywhere\nthat we call <code>next</code> on <code>Counter</code>.</p>\n<p dir=\"auto\">Associated types also become part of the trait’s contract: implementors of the\ntrait must provide a type to stand in for the associated type placeholder.\nAssociated types often have a name that describes how the type will be used,\nand documenting the associated type in the API documentation is good practice.</p>\n<h3 tabindex=\"-1\" id=\"user-content-default-generic-type-parameters-and-operator-overloading\" dir=\"auto\"><a class=\"heading-link\" href=\"#default-generic-type-parameters-and-operator-overloading\">Default Generic Type Parameters and Operator Overloading<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">When we use generic type parameters, we can specify a default concrete type for\nthe generic type. This eliminates the need for implementors of the trait to\nspecify a concrete type if the default type works. You specify a default type\nwhen declaring a generic type with the <code>&lt;PlaceholderType=ConcreteType&gt;</code> syntax.</p>\n<p dir=\"auto\">A great example of a situation where this technique is useful is with <em>operator\noverloading</em>, in which you customize the behavior of an operator (such as <code>+</code>)\nin particular situations.</p>\n<p dir=\"auto\">Rust doesn’t allow you to create your own operators or overload arbitrary\noperators. But you can overload the operations and corresponding traits listed\nin <code>std::ops</code> by implementing the traits associated with the operator. For\nexample, in Listing 19-14 we overload the <code>+</code> operator to add two <code>Point</code>\ninstances together. We do this by implementing the <code>Add</code> trait on a <code>Point</code>\nstruct:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-14/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">14</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-14: Implementing the <code>Add</code> trait to overload\nthe <code>+</code> operator for <code>Point</code> instances</span></p>\n<p dir=\"auto\">The <code>add</code> method adds the <code>x</code> values of two <code>Point</code> instances and the <code>y</code>\nvalues of two <code>Point</code> instances to create a new <code>Point</code>. The <code>Add</code> trait has an\nassociated type named <code>Output</code> that determines the type returned from the <code>add</code>\nmethod.</p>\n<p dir=\"auto\">The default generic type in this code is within the <code>Add</code> trait. Here is its\ndefinition:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"trait Add&lt;Rhs=Self&gt; {\n    type Output;\n\n    fn add(self, rhs: Rhs) -&gt; Self::Output;\n}\"><pre><span class=\"pl-k\">trait</span> <span class=\"pl-smi\">Add</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Rhs</span>=<span class=\"pl-smi\">Self</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Output</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-k\">fn</span> <span class=\"pl-en\">add</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">self</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">rhs</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">Rhs</span><span class=\"pl-kos\">)</span> -&gt; <span class=\"pl-smi\">Self</span><span class=\"pl-kos\">::</span><span class=\"pl-smi\">Output</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">This code should look generally familiar: a trait with one method and an\nassociated type. The new part is <code>Rhs=Self</code>: this syntax is called <em>default\ntype parameters</em>. The <code>Rhs</code> generic type parameter (short for “right hand\nside”) defines the type of the <code>rhs</code> parameter in the <code>add</code> method. If we don’t\nspecify a concrete type for <code>Rhs</code> when we implement the <code>Add</code> trait, the type\nof <code>Rhs</code> will default to <code>Self</code>, which will be the type we’re implementing\n<code>Add</code> on.</p>\n<p dir=\"auto\">When we implemented <code>Add</code> for <code>Point</code>, we used the default for <code>Rhs</code> because we\nwanted to add two <code>Point</code> instances. Let’s look at an example of implementing\nthe <code>Add</code> trait where we want to customize the <code>Rhs</code> type rather than using the\ndefault.</p>\n<p dir=\"auto\">We have two structs, <code>Millimeters</code> and <code>Meters</code>, holding values in different\nunits. This thin wrapping of an existing type in another struct is known as the\n<em>newtype pattern</em>, which we describe in more detail in the <a href=\"/rust-lang/book/blob/main/src/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types\">“Using the Newtype\nPattern to Implement External Traits on External Types”</a> section. We want to add values in millimeters to values in meters and have\nthe implementation of <code>Add</code> do the conversion correctly. We can implement <code>Add</code>\nfor <code>Millimeters</code> with <code>Meters</code> as the <code>Rhs</code>, as shown in Listing 19-15.</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-15/src/lib.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">15</span>/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-15: Implementing the <code>Add</code> trait on\n<code>Millimeters</code> to add <code>Millimeters</code> to <code>Meters</code></span></p>\n<p dir=\"auto\">To add <code>Millimeters</code> and <code>Meters</code>, we specify <code>impl Add&lt;Meters&gt;</code> to set the\nvalue of the <code>Rhs</code> type parameter instead of using the default of <code>Self</code>.</p>\n<p dir=\"auto\">You’ll use default type parameters in two main ways:</p>\n<ul dir=\"auto\">\n<li>To extend a type without breaking existing code</li>\n<li>To allow customization in specific cases most users won’t need</li>\n</ul>\n<p dir=\"auto\">The standard library’s <code>Add</code> trait is an example of the second purpose:\nusually, you’ll add two like types, but the <code>Add</code> trait provides the ability to\ncustomize beyond that. Using a default type parameter in the <code>Add</code> trait\ndefinition means you don’t have to specify the extra parameter most of the\ntime. In other words, a bit of implementation boilerplate isn’t needed, making\nit easier to use the trait.</p>\n<p dir=\"auto\">The first purpose is similar to the second but in reverse: if you want to add a\ntype parameter to an existing trait, you can give it a default to allow\nextension of the functionality of the trait without breaking the existing\nimplementation code.</p>\n<h3 tabindex=\"-1\" id=\"user-content-fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name\" dir=\"auto\"><a class=\"heading-link\" href=\"#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name\">Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">Nothing in Rust prevents a trait from having a method with the same name as\nanother trait’s method, nor does Rust prevent you from implementing both traits\non one type. It’s also possible to implement a method directly on the type with\nthe same name as methods from traits.</p>\n<p dir=\"auto\">When calling methods with the same name, you’ll need to tell Rust which one you\nwant to use. Consider the code in Listing 19-16 where we’ve defined two traits,\n<code>Pilot</code> and <code>Wizard</code>, that both have a method called <code>fly</code>. We then implement\nboth traits on a type <code>Human</code> that already has a method named <code>fly</code> implemented\non it. Each <code>fly</code> method does something different.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-16/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">16</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-16: Two traits are defined to have a <code>fly</code>\nmethod and are implemented on the <code>Human</code> type, and a <code>fly</code> method is\nimplemented on <code>Human</code> directly</span></p>\n<p dir=\"auto\">When we call <code>fly</code> on an instance of <code>Human</code>, the compiler defaults to calling\nthe method that is directly implemented on the type, as shown in Listing 19-17.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-17/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">17</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-17: Calling <code>fly</code> on an instance of\n<code>Human</code></span></p>\n<p dir=\"auto\">Running this code will print <code>*waving arms furiously*</code>, showing that Rust\ncalled the <code>fly</code> method implemented on <code>Human</code> directly.</p>\n<p dir=\"auto\">To call the <code>fly</code> methods from either the <code>Pilot</code> trait or the <code>Wizard</code> trait,\nwe need to use more explicit syntax to specify which <code>fly</code> method we mean.\nListing 19-18 demonstrates this syntax.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-18/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">18</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-18: Specifying which trait’s <code>fly</code> method we\nwant to call</span></p>\n<p dir=\"auto\">Specifying the trait name before the method name clarifies to Rust which\nimplementation of <code>fly</code> we want to call. We could also write\n<code>Human::fly(&amp;person)</code>, which is equivalent to the <code>person.fly()</code> that we used\nin Listing 19-18, but this is a bit longer to write if we don’t need to\ndisambiguate.</p>\n<p dir=\"auto\">Running this code prints the following:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch19-advanced-features/listing-19-18/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch19-advanced-features/listing-19-18/output.txt}}</span></pre></div>\n<p dir=\"auto\">Because the <code>fly</code> method takes a <code>self</code> parameter, if we had two <em>types</em> that\nboth implement one <em>trait</em>, Rust could figure out which implementation of a\ntrait to use based on the type of <code>self</code>.</p>\n<p dir=\"auto\">However, associated functions that are not methods don’t have a <code>self</code>\nparameter. When there are multiple types or traits that define non-method\nfunctions with the same function name, Rust doesn't always know which type you\nmean unless you use <em>fully qualified syntax</em>. For example, in Listing 19-19 we\ncreate a trait for an animal shelter that wants to name all baby dogs <em>Spot</em>.\nWe make an <code>Animal</code> trait with an associated non-method function <code>baby_name</code>.\nThe <code>Animal</code> trait is implemented for the struct <code>Dog</code>, on which we also\nprovide an associated non-method function <code>baby_name</code> directly.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-19/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">19</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-19: A trait with an associated function and a\ntype with an associated function of the same name that also implements the\ntrait</span></p>\n<p dir=\"auto\">We implement the code for naming all puppies Spot in the <code>baby_name</code> associated\nfunction that is defined on <code>Dog</code>. The <code>Dog</code> type also implements the trait\n<code>Animal</code>, which describes characteristics that all animals have. Baby dogs are\ncalled puppies, and that is expressed in the implementation of the <code>Animal</code>\ntrait on <code>Dog</code> in the <code>baby_name</code> function associated with the <code>Animal</code> trait.</p>\n<p dir=\"auto\">In <code>main</code>, we call the <code>Dog::baby_name</code> function, which calls the associated\nfunction defined on <code>Dog</code> directly. This code prints the following:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch19-advanced-features/listing-19-19/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch19-advanced-features/listing-19-19/output.txt}}</span></pre></div>\n<p dir=\"auto\">This output isn’t what we wanted. We want to call the <code>baby_name</code> function that\nis part of the <code>Animal</code> trait that we implemented on <code>Dog</code> so the code prints\n<code>A baby dog is called a puppy</code>. The technique of specifying the trait name that\nwe used in Listing 19-18 doesn’t help here; if we change <code>main</code> to the code in\nListing 19-20, we’ll get a compilation error.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-20/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">20</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-20: Attempting to call the <code>baby_name</code>\nfunction from the <code>Animal</code> trait, but Rust doesn’t know which implementation to\nuse</span></p>\n<p dir=\"auto\">Because <code>Animal::baby_name</code> doesn’t have a <code>self</code> parameter, and there could be\nother types that implement the <code>Animal</code> trait, Rust can’t figure out which\nimplementation of <code>Animal::baby_name</code> we want. We’ll get this compiler error:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch19-advanced-features/listing-19-20/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch19-advanced-features/listing-19-20/output.txt}}</span></pre></div>\n<p dir=\"auto\">To disambiguate and tell Rust that we want to use the implementation of\n<code>Animal</code> for <code>Dog</code> as opposed to the implementation of <code>Animal</code> for some other\ntype, we need to use fully qualified syntax. Listing 19-21 demonstrates how to\nuse fully qualified syntax.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-21/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">21</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-21: Using fully qualified syntax to specify\nthat we want to call the <code>baby_name</code> function from the <code>Animal</code> trait as\nimplemented on <code>Dog</code></span></p>\n<p dir=\"auto\">We’re providing Rust with a type annotation within the angle brackets, which\nindicates we want to call the <code>baby_name</code> method from the <code>Animal</code> trait as\nimplemented on <code>Dog</code> by saying that we want to treat the <code>Dog</code> type as an\n<code>Animal</code> for this function call. This code will now print what we want:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch19-advanced-features/listing-19-21/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch19-advanced-features/listing-19-21/output.txt}}</span></pre></div>\n<p dir=\"auto\">In general, fully qualified syntax is defined as follows:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);\"><pre>&lt;<span class=\"pl-smi\">Type</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Trait</span>&gt;<span class=\"pl-kos\">::</span><span class=\"pl-en\">function</span><span class=\"pl-kos\">(</span>receiver_if_method<span class=\"pl-kos\">,</span> next_arg<span class=\"pl-kos\">,</span> ..<span class=\"pl-kos\">.</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">For associated functions that aren’t methods, there would not be a <code>receiver</code>:\nthere would only be the list of other arguments. You could use fully qualified\nsyntax everywhere that you call functions or methods. However, you’re allowed\nto omit any part of this syntax that Rust can figure out from other information\nin the program. You only need to use this more verbose syntax in cases where\nthere are multiple implementations that use the same name and Rust needs help\nto identify which implementation you want to call.</p>\n<h3 tabindex=\"-1\" id=\"user-content-using-supertraits-to-require-one-traits-functionality-within-another-trait\" dir=\"auto\"><a class=\"heading-link\" href=\"#using-supertraits-to-require-one-traits-functionality-within-another-trait\">Using Supertraits to Require One Trait’s Functionality Within Another Trait<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">Sometimes, you might write a trait definition that depends on another trait:\nfor a type to implement the first trait, you want to require that type to also\nimplement the second trait. You would do this so that your trait definition can\nmake use of the associated items of the second trait. The trait your trait\ndefinition is relying on is called a <em>supertrait</em> of your trait.</p>\n<p dir=\"auto\">For example, let’s say we want to make an <code>OutlinePrint</code> trait with an\n<code>outline_print</code> method that will print a given value formatted so that it's\nframed in asterisks. That is, given a <code>Point</code> struct that implements the\nstandard library trait <code>Display</code> to result in <code>(x, y)</code>, when we call\n<code>outline_print</code> on a <code>Point</code> instance that has <code>1</code> for <code>x</code> and <code>3</code> for <code>y</code>, it\nshould print the following:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"**********\n*        *\n* (1, 3) *\n*        *\n**********\"><pre lang=\"text\" class=\"notranslate\"><code>**********\n*        *\n* (1, 3) *\n*        *\n**********\n</code></pre></div>\n<p dir=\"auto\">In the implementation of the <code>outline_print</code> method, we want to use the\n<code>Display</code> trait’s functionality. Therefore, we need to specify that the\n<code>OutlinePrint</code> trait will work only for types that also implement <code>Display</code> and\nprovide the functionality that <code>OutlinePrint</code> needs. We can do that in the\ntrait definition by specifying <code>OutlinePrint: Display</code>. This technique is\nsimilar to adding a trait bound to the trait. Listing 19-22 shows an\nimplementation of the <code>OutlinePrint</code> trait.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-22/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">22</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-22: Implementing the <code>OutlinePrint</code> trait that\nrequires the functionality from <code>Display</code></span></p>\n<p dir=\"auto\">Because we’ve specified that <code>OutlinePrint</code> requires the <code>Display</code> trait, we\ncan use the <code>to_string</code> function that is automatically implemented for any type\nthat implements <code>Display</code>. If we tried to use <code>to_string</code> without adding a\ncolon and specifying the <code>Display</code> trait after the trait name, we’d get an\nerror saying that no method named <code>to_string</code> was found for the type <code>&amp;Self</code> in\nthe current scope.</p>\n<p dir=\"auto\">Let’s see what happens when we try to implement <code>OutlinePrint</code> on a type that\ndoesn’t implement <code>Display</code>, such as the <code>Point</code> struct:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/no-listing-<span class=\"pl-c1\">02</span>-impl-outlineprint-<span class=\"pl-k\">for</span>-point/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">We get an error saying that <code>Display</code> is required but not implemented:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/output.txt}}</span></pre></div>\n<p dir=\"auto\">To fix this, we implement <code>Display</code> on <code>Point</code> and satisfy the constraint that\n<code>OutlinePrint</code> requires, like so:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-03-impl-display-for-point/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/no-listing-<span class=\"pl-c1\">03</span>-impl-display-<span class=\"pl-k\">for</span>-point/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">Then implementing the <code>OutlinePrint</code> trait on <code>Point</code> will compile\nsuccessfully, and we can call <code>outline_print</code> on a <code>Point</code> instance to display\nit within an outline of asterisks.</p>\n<h3 tabindex=\"-1\" id=\"user-content-using-the-newtype-pattern-to-implement-external-traits-on-external-types\" dir=\"auto\"><a class=\"heading-link\" href=\"#using-the-newtype-pattern-to-implement-external-traits-on-external-types\">Using the Newtype Pattern to Implement External Traits on External Types<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">In Chapter 10 in the <a href=\"/rust-lang/book/blob/main/src/ch10-02-traits.html#implementing-a-trait-on-a-type\">“Implementing a Trait on a\nType”</a> section, we mentioned the\norphan rule that states we’re only allowed to implement a trait on a type if\neither the trait or the type are local to our crate. It’s possible to get\naround this restriction using the <em>newtype pattern</em>, which involves creating a\nnew type in a tuple struct. (We covered tuple structs in the <a href=\"/rust-lang/book/blob/main/src/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types\">“Using Tuple\nStructs without Named Fields to Create Different Types”</a> section of Chapter 5.) The tuple struct will have one field and be a\nthin wrapper around the type we want to implement a trait for. Then the wrapper\ntype is local to our crate, and we can implement the trait on the wrapper.\n<em>Newtype</em> is a term that originates from the Haskell programming language.\nThere is no runtime performance penalty for using this pattern, and the wrapper\ntype is elided at compile time.</p>\n<p dir=\"auto\">As an example, let’s say we want to implement <code>Display</code> on <code>Vec&lt;T&gt;</code>, which the\norphan rule prevents us from doing directly because the <code>Display</code> trait and the\n<code>Vec&lt;T&gt;</code> type are defined outside our crate. We can make a <code>Wrapper</code> struct\nthat holds an instance of <code>Vec&lt;T&gt;</code>; then we can implement <code>Display</code> on\n<code>Wrapper</code> and use the <code>Vec&lt;T&gt;</code> value, as shown in Listing 19-23.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-23/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">23</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-23: Creating a <code>Wrapper</code> type around\n<code>Vec&lt;String&gt;</code> to implement <code>Display</code></span></p>\n<p dir=\"auto\">The implementation of <code>Display</code> uses <code>self.0</code> to access the inner <code>Vec&lt;T&gt;</code>,\nbecause <code>Wrapper</code> is a tuple struct and <code>Vec&lt;T&gt;</code> is the item at index 0 in the\ntuple. Then we can use the functionality of the <code>Display</code> type on <code>Wrapper</code>.</p>\n<p dir=\"auto\">The downside of using this technique is that <code>Wrapper</code> is a new type, so it\ndoesn’t have the methods of the value it’s holding. We would have to implement\nall the methods of <code>Vec&lt;T&gt;</code> directly on <code>Wrapper</code> such that the methods\ndelegate to <code>self.0</code>, which would allow us to treat <code>Wrapper</code> exactly like a\n<code>Vec&lt;T&gt;</code>. If we wanted the new type to have every method the inner type has,\nimplementing the <code>Deref</code> trait (discussed in Chapter 15 in the <a href=\"/rust-lang/book/blob/main/src/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait\">“Treating Smart\nPointers Like Regular References with the <code>Deref</code>\nTrait”</a> section) on the <code>Wrapper</code> to return\nthe inner type would be a solution. If we don’t want the <code>Wrapper</code> type to have\nall the methods of the inner type—for example, to restrict the <code>Wrapper</code> type’s\nbehavior—we would have to implement just the methods we do want manually.</p>\n<p dir=\"auto\">This newtype pattern is also useful even when traits are not involved. Let’s\nswitch focus and look at some advanced ways to interact with Rust’s type system.</p>\n</article>","renderedFileInfo":null,"shortPath":null,"tabSize":8,"topBannersInfo":{"overridingGlobalFundingFile":false,"globalPreferredFundingPath":null,"repoOwner":"rust-lang","repoName":"book","showInvalidCitationWarning":false,"citationHelpUrl":"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/about-citation-files","showDependabotConfigurationBanner":false,"actionsOnboardingTip":null},"truncated":false,"viewable":true,"workflowRedirectUrl":null,"symbols":{"timedOut":false,"notAnalyzed":true,"symbols":[]}},"copilotInfo":null,"csrf_tokens":{"/rust-lang/book/branches":{"post":"Ew66-DALYwE5NtkuDh7l8-pJY0yJsibYxaoAssk1EpGJLeHpJufnCeD_1E1VMoKCrS_pqmA-6Zc_jvf-OUn8ow"},"/repos/preferences":{"post":"3XwqjiMv2tOezJoKwPgPr1HnMrdYt9eCao4_7gB6lLkPHDQ9OUO7umclK3_eThYtvHM5pt6zkNXXZGhZ_gLewg"}}},"title":"book/src/ch19-03-advanced-traits.md at main · rust-lang/book"}
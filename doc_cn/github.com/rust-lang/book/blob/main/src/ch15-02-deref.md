{"payload":{"allShortcutsEnabled":false,"fileTree":{"src":{"items":[{"name":"img","path":"src/img","contentType":"directory"},{"name":"SUMMARY.md","path":"src/SUMMARY.md","contentType":"file"},{"name":"appendix-00.md","path":"src/appendix-00.md","contentType":"file"},{"name":"appendix-01-keywords.md","path":"src/appendix-01-keywords.md","contentType":"file"},{"name":"appendix-02-operators.md","path":"src/appendix-02-operators.md","contentType":"file"},{"name":"appendix-03-derivable-traits.md","path":"src/appendix-03-derivable-traits.md","contentType":"file"},{"name":"appendix-04-useful-development-tools.md","path":"src/appendix-04-useful-development-tools.md","contentType":"file"},{"name":"appendix-05-editions.md","path":"src/appendix-05-editions.md","contentType":"file"},{"name":"appendix-06-translation.md","path":"src/appendix-06-translation.md","contentType":"file"},{"name":"appendix-07-nightly-rust.md","path":"src/appendix-07-nightly-rust.md","contentType":"file"},{"name":"ch00-00-introduction.md","path":"src/ch00-00-introduction.md","contentType":"file"},{"name":"ch01-00-getting-started.md","path":"src/ch01-00-getting-started.md","contentType":"file"},{"name":"ch01-01-installation.md","path":"src/ch01-01-installation.md","contentType":"file"},{"name":"ch01-02-hello-world.md","path":"src/ch01-02-hello-world.md","contentType":"file"},{"name":"ch01-03-hello-cargo.md","path":"src/ch01-03-hello-cargo.md","contentType":"file"},{"name":"ch02-00-guessing-game-tutorial.md","path":"src/ch02-00-guessing-game-tutorial.md","contentType":"file"},{"name":"ch03-00-common-programming-concepts.md","path":"src/ch03-00-common-programming-concepts.md","contentType":"file"},{"name":"ch03-01-variables-and-mutability.md","path":"src/ch03-01-variables-and-mutability.md","contentType":"file"},{"name":"ch03-02-data-types.md","path":"src/ch03-02-data-types.md","contentType":"file"},{"name":"ch03-03-how-functions-work.md","path":"src/ch03-03-how-functions-work.md","contentType":"file"},{"name":"ch03-04-comments.md","path":"src/ch03-04-comments.md","contentType":"file"},{"name":"ch03-05-control-flow.md","path":"src/ch03-05-control-flow.md","contentType":"file"},{"name":"ch04-00-understanding-ownership.md","path":"src/ch04-00-understanding-ownership.md","contentType":"file"},{"name":"ch04-01-what-is-ownership.md","path":"src/ch04-01-what-is-ownership.md","contentType":"file"},{"name":"ch04-02-references-and-borrowing.md","path":"src/ch04-02-references-and-borrowing.md","contentType":"file"},{"name":"ch04-03-slices.md","path":"src/ch04-03-slices.md","contentType":"file"},{"name":"ch05-00-structs.md","path":"src/ch05-00-structs.md","contentType":"file"},{"name":"ch05-01-defining-structs.md","path":"src/ch05-01-defining-structs.md","contentType":"file"},{"name":"ch05-02-example-structs.md","path":"src/ch05-02-example-structs.md","contentType":"file"},{"name":"ch05-03-method-syntax.md","path":"src/ch05-03-method-syntax.md","contentType":"file"},{"name":"ch06-00-enums.md","path":"src/ch06-00-enums.md","contentType":"file"},{"name":"ch06-01-defining-an-enum.md","path":"src/ch06-01-defining-an-enum.md","contentType":"file"},{"name":"ch06-02-match.md","path":"src/ch06-02-match.md","contentType":"file"},{"name":"ch06-03-if-let.md","path":"src/ch06-03-if-let.md","contentType":"file"},{"name":"ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","path":"src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","contentType":"file"},{"name":"ch07-01-packages-and-crates.md","path":"src/ch07-01-packages-and-crates.md","contentType":"file"},{"name":"ch07-02-defining-modules-to-control-scope-and-privacy.md","path":"src/ch07-02-defining-modules-to-control-scope-and-privacy.md","contentType":"file"},{"name":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","path":"src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","contentType":"file"},{"name":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","path":"src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","contentType":"file"},{"name":"ch07-05-separating-modules-into-different-files.md","path":"src/ch07-05-separating-modules-into-different-files.md","contentType":"file"},{"name":"ch08-00-common-collections.md","path":"src/ch08-00-common-collections.md","contentType":"file"},{"name":"ch08-01-vectors.md","path":"src/ch08-01-vectors.md","contentType":"file"},{"name":"ch08-02-strings.md","path":"src/ch08-02-strings.md","contentType":"file"},{"name":"ch08-03-hash-maps.md","path":"src/ch08-03-hash-maps.md","contentType":"file"},{"name":"ch09-00-error-handling.md","path":"src/ch09-00-error-handling.md","contentType":"file"},{"name":"ch09-01-unrecoverable-errors-with-panic.md","path":"src/ch09-01-unrecoverable-errors-with-panic.md","contentType":"file"},{"name":"ch09-02-recoverable-errors-with-result.md","path":"src/ch09-02-recoverable-errors-with-result.md","contentType":"file"},{"name":"ch09-03-to-panic-or-not-to-panic.md","path":"src/ch09-03-to-panic-or-not-to-panic.md","contentType":"file"},{"name":"ch10-00-generics.md","path":"src/ch10-00-generics.md","contentType":"file"},{"name":"ch10-01-syntax.md","path":"src/ch10-01-syntax.md","contentType":"file"},{"name":"ch10-02-traits.md","path":"src/ch10-02-traits.md","contentType":"file"},{"name":"ch10-03-lifetime-syntax.md","path":"src/ch10-03-lifetime-syntax.md","contentType":"file"},{"name":"ch11-00-testing.md","path":"src/ch11-00-testing.md","contentType":"file"},{"name":"ch11-01-writing-tests.md","path":"src/ch11-01-writing-tests.md","contentType":"file"},{"name":"ch11-02-running-tests.md","path":"src/ch11-02-running-tests.md","contentType":"file"},{"name":"ch11-03-test-organization.md","path":"src/ch11-03-test-organization.md","contentType":"file"},{"name":"ch12-00-an-io-project.md","path":"src/ch12-00-an-io-project.md","contentType":"file"},{"name":"ch12-01-accepting-command-line-arguments.md","path":"src/ch12-01-accepting-command-line-arguments.md","contentType":"file"},{"name":"ch12-02-reading-a-file.md","path":"src/ch12-02-reading-a-file.md","contentType":"file"},{"name":"ch12-03-improving-error-handling-and-modularity.md","path":"src/ch12-03-improving-error-handling-and-modularity.md","contentType":"file"},{"name":"ch12-04-testing-the-librarys-functionality.md","path":"src/ch12-04-testing-the-librarys-functionality.md","contentType":"file"},{"name":"ch12-05-working-with-environment-variables.md","path":"src/ch12-05-working-with-environment-variables.md","contentType":"file"},{"name":"ch12-06-writing-to-stderr-instead-of-stdout.md","path":"src/ch12-06-writing-to-stderr-instead-of-stdout.md","contentType":"file"},{"name":"ch13-00-functional-features.md","path":"src/ch13-00-functional-features.md","contentType":"file"},{"name":"ch13-01-closures.md","path":"src/ch13-01-closures.md","contentType":"file"},{"name":"ch13-02-iterators.md","path":"src/ch13-02-iterators.md","contentType":"file"},{"name":"ch13-03-improving-our-io-project.md","path":"src/ch13-03-improving-our-io-project.md","contentType":"file"},{"name":"ch13-04-performance.md","path":"src/ch13-04-performance.md","contentType":"file"},{"name":"ch14-00-more-about-cargo.md","path":"src/ch14-00-more-about-cargo.md","contentType":"file"},{"name":"ch14-01-release-profiles.md","path":"src/ch14-01-release-profiles.md","contentType":"file"},{"name":"ch14-02-publishing-to-crates-io.md","path":"src/ch14-02-publishing-to-crates-io.md","contentType":"file"},{"name":"ch14-03-cargo-workspaces.md","path":"src/ch14-03-cargo-workspaces.md","contentType":"file"},{"name":"ch14-04-installing-binaries.md","path":"src/ch14-04-installing-binaries.md","contentType":"file"},{"name":"ch14-05-extending-cargo.md","path":"src/ch14-05-extending-cargo.md","contentType":"file"},{"name":"ch15-00-smart-pointers.md","path":"src/ch15-00-smart-pointers.md","contentType":"file"},{"name":"ch15-01-box.md","path":"src/ch15-01-box.md","contentType":"file"},{"name":"ch15-02-deref.md","path":"src/ch15-02-deref.md","contentType":"file"},{"name":"ch15-03-drop.md","path":"src/ch15-03-drop.md","contentType":"file"},{"name":"ch15-04-rc.md","path":"src/ch15-04-rc.md","contentType":"file"},{"name":"ch15-05-interior-mutability.md","path":"src/ch15-05-interior-mutability.md","contentType":"file"},{"name":"ch15-06-reference-cycles.md","path":"src/ch15-06-reference-cycles.md","contentType":"file"},{"name":"ch16-00-concurrency.md","path":"src/ch16-00-concurrency.md","contentType":"file"},{"name":"ch16-01-threads.md","path":"src/ch16-01-threads.md","contentType":"file"},{"name":"ch16-02-message-passing.md","path":"src/ch16-02-message-passing.md","contentType":"file"},{"name":"ch16-03-shared-state.md","path":"src/ch16-03-shared-state.md","contentType":"file"},{"name":"ch16-04-extensible-concurrency-sync-and-send.md","path":"src/ch16-04-extensible-concurrency-sync-and-send.md","contentType":"file"},{"name":"ch17-00-oop.md","path":"src/ch17-00-oop.md","contentType":"file"},{"name":"ch17-01-what-is-oo.md","path":"src/ch17-01-what-is-oo.md","contentType":"file"},{"name":"ch17-02-trait-objects.md","path":"src/ch17-02-trait-objects.md","contentType":"file"},{"name":"ch17-03-oo-design-patterns.md","path":"src/ch17-03-oo-design-patterns.md","contentType":"file"},{"name":"ch18-00-patterns.md","path":"src/ch18-00-patterns.md","contentType":"file"},{"name":"ch18-01-all-the-places-for-patterns.md","path":"src/ch18-01-all-the-places-for-patterns.md","contentType":"file"},{"name":"ch18-02-refutability.md","path":"src/ch18-02-refutability.md","contentType":"file"},{"name":"ch18-03-pattern-syntax.md","path":"src/ch18-03-pattern-syntax.md","contentType":"file"},{"name":"ch19-00-advanced-features.md","path":"src/ch19-00-advanced-features.md","contentType":"file"},{"name":"ch19-01-unsafe-rust.md","path":"src/ch19-01-unsafe-rust.md","contentType":"file"},{"name":"ch19-03-advanced-traits.md","path":"src/ch19-03-advanced-traits.md","contentType":"file"},{"name":"ch19-04-advanced-types.md","path":"src/ch19-04-advanced-types.md","contentType":"file"},{"name":"ch19-05-advanced-functions-and-closures.md","path":"src/ch19-05-advanced-functions-and-closures.md","contentType":"file"},{"name":"ch19-06-macros.md","path":"src/ch19-06-macros.md","contentType":"file"},{"name":"ch20-00-final-project-a-web-server.md","path":"src/ch20-00-final-project-a-web-server.md","contentType":"file"},{"name":"ch20-01-single-threaded.md","path":"src/ch20-01-single-threaded.md","contentType":"file"},{"name":"ch20-02-multithreaded.md","path":"src/ch20-02-multithreaded.md","contentType":"file"},{"name":"ch20-03-graceful-shutdown-and-cleanup.md","path":"src/ch20-03-graceful-shutdown-and-cleanup.md","contentType":"file"},{"name":"foreword.md","path":"src/foreword.md","contentType":"file"},{"name":"title-page.md","path":"src/title-page.md","contentType":"file"}],"totalCount":106},"":{"items":[{"name":".cargo","path":".cargo","contentType":"directory"},{"name":".github","path":".github","contentType":"directory"},{"name":"2018-edition","path":"2018-edition","contentType":"directory"},{"name":"ci","path":"ci","contentType":"directory"},{"name":"dot","path":"dot","contentType":"directory"},{"name":"first-edition","path":"first-edition","contentType":"directory"},{"name":"listings","path":"listings","contentType":"directory"},{"name":"nostarch","path":"nostarch","contentType":"directory"},{"name":"redirects","path":"redirects","contentType":"directory"},{"name":"second-edition","path":"second-edition","contentType":"directory"},{"name":"src","path":"src","contentType":"directory"},{"name":"theme","path":"theme","contentType":"directory"},{"name":"tools","path":"tools","contentType":"directory"},{"name":".gitattributes","path":".gitattributes","contentType":"file"},{"name":".gitignore","path":".gitignore","contentType":"file"},{"name":"ADMIN_TASKS.md","path":"ADMIN_TASKS.md","contentType":"file"},{"name":"CONTRIBUTING.md","path":"CONTRIBUTING.md","contentType":"file"},{"name":"COPYRIGHT","path":"COPYRIGHT","contentType":"file"},{"name":"Cargo.lock","path":"Cargo.lock","contentType":"file"},{"name":"Cargo.toml","path":"Cargo.toml","contentType":"file"},{"name":"LICENSE-APACHE","path":"LICENSE-APACHE","contentType":"file"},{"name":"LICENSE-MIT","path":"LICENSE-MIT","contentType":"file"},{"name":"README.md","path":"README.md","contentType":"file"},{"name":"TODO.md","path":"TODO.md","contentType":"file"},{"name":"book.toml","path":"book.toml","contentType":"file"},{"name":"ferris.css","path":"ferris.css","contentType":"file"},{"name":"ferris.js","path":"ferris.js","contentType":"file"},{"name":"rust-toolchain","path":"rust-toolchain","contentType":"file"},{"name":"rustfmt.toml","path":"rustfmt.toml","contentType":"file"},{"name":"style-guide.md","path":"style-guide.md","contentType":"file"}],"totalCount":30}},"fileTreeProcessingTime":18.056310999999997,"foldersToFetch":[],"reducedMotionEnabled":null,"repo":{"id":47854924,"defaultBranch":"main","name":"book","ownerLogin":"rust-lang","currentUserCanPush":false,"isFork":false,"isEmpty":false,"createdAt":"2015-12-11T22:49:49.000Z","ownerAvatar":"https://avatars.githubusercontent.com/u/5430905?v=4","public":true,"private":false,"isOrgOwned":true},"symbolsExpanded":false,"treeExpanded":true,"refInfo":{"name":"main","listCacheKey":"v0:1688046669.0","canEdit":false,"refType":"branch","currentOid":"72187f5cd0beaaa9c6f584156bcd88f921871e83"},"path":"src/ch15-02-deref.md","currentUser":null,"blob":{"rawLines":null,"stylingDirectives":null,"csv":null,"csvError":null,"dependabotInfo":{"showConfigurationBanner":false,"configFilePath":null,"networkDependabotPath":"/rust-lang/book/network/updates","dismissConfigurationNoticePath":"/settings/dismiss-notice/dependabot_configuration_notice","configurationNoticeDismissed":null,"repoAlertsPath":"/rust-lang/book/security/dependabot","repoSecurityAndAnalysisPath":"/rust-lang/book/settings/security_analysis","repoOwnerIsOrg":true,"currentUserCanAdminRepo":false},"displayName":"ch15-02-deref.md","displayUrl":"https://github.com/rust-lang/book/blob/main/src/ch15-02-deref.md?raw=true","headerInfo":{"blobSize":"13.8 KB","deleteInfo":{"deleteTooltip":"You must be signed in to make or propose changes"},"editInfo":{"editTooltip":"You must be signed in to make or propose changes"},"ghDesktopPath":"https://desktop.github.com","gitLfsPath":null,"onBranch":true,"shortPath":"23c9fe8","siteNavLoginPath":"/login?return_to=https%3A%2F%2Fgithub.com%2Frust-lang%2Fbook%2Fblob%2Fmain%2Fsrc%2Fch15-02-deref.md","isCSV":false,"isRichtext":true,"toc":[{"level":2,"text":"Treating Smart Pointers Like Regular References with the Deref Trait","anchor":"treating-smart-pointers-like-regular-references-with-the-deref-trait","htmlText":"Treating Smart Pointers Like Regular References with the Deref Trait"},{"level":3,"text":"Following the Pointer to the Value","anchor":"following-the-pointer-to-the-value","htmlText":"Following the Pointer to the Value"},{"level":3,"text":"Using Box<T> Like a Reference","anchor":"using-boxt-like-a-reference","htmlText":"Using Box&lt;T&gt; Like a Reference"},{"level":3,"text":"Defining Our Own Smart Pointer","anchor":"defining-our-own-smart-pointer","htmlText":"Defining Our Own Smart Pointer"},{"level":3,"text":"Treating a Type Like a Reference by Implementing the Deref Trait","anchor":"treating-a-type-like-a-reference-by-implementing-the-deref-trait","htmlText":"Treating a Type Like a Reference by Implementing the Deref Trait"},{"level":3,"text":"Implicit Deref Coercions with Functions and Methods","anchor":"implicit-deref-coercions-with-functions-and-methods","htmlText":"Implicit Deref Coercions with Functions and Methods"},{"level":3,"text":"How Deref Coercion Interacts with Mutability","anchor":"how-deref-coercion-interacts-with-mutability","htmlText":"How Deref Coercion Interacts with Mutability"}],"lineInfo":{"truncatedLoc":"299","truncatedSloc":"228"},"mode":"file"},"image":false,"isCodeownersFile":null,"isPlain":false,"isValidLegacyIssueTemplate":false,"issueTemplateHelpUrl":"https://docs.github.com/articles/about-issue-and-pull-request-templates","issueTemplate":null,"discussionTemplate":null,"language":"Markdown","languageID":222,"large":false,"loggedIn":false,"newDiscussionPath":"/rust-lang/book/discussions/new","newIssuePath":"/rust-lang/book/issues/new","planSupportInfo":{"repoIsFork":null,"repoOwnedByCurrentUser":null,"requestFullPath":"/rust-lang/book/blob/main/src/ch15-02-deref.md","showFreeOrgGatedFeatureMessage":null,"showPlanSupportBanner":null,"upgradeDataAttributes":null,"upgradePath":null},"publishBannersInfo":{"dismissActionNoticePath":"/settings/dismiss-notice/publish_action_from_dockerfile","dismissStackNoticePath":"/settings/dismiss-notice/publish_stack_from_file","releasePath":"/rust-lang/book/releases/new?marketplace=true","showPublishActionBanner":false,"showPublishStackBanner":false},"renderImageOrRaw":false,"richText":"<article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><h2 tabindex=\"-1\" id=\"user-content-treating-smart-pointers-like-regular-references-with-the-deref-trait\" dir=\"auto\"><a class=\"heading-link\" href=\"#treating-smart-pointers-like-regular-references-with-the-deref-trait\">Treating Smart Pointers Like Regular References with the <code>Deref</code> Trait<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">Implementing the <code>Deref</code> trait allows you to customize the behavior of the\n<em>dereference operator</em> <code>*</code> (not to be confused with the multiplication or glob\noperator). By implementing <code>Deref</code> in such a way that a smart pointer can be\ntreated like a regular reference, you can write code that operates on\nreferences and use that code with smart pointers too.</p>\n<p dir=\"auto\">Let’s first look at how the dereference operator works with regular references.\nThen we’ll try to define a custom type that behaves like <code>Box&lt;T&gt;</code>, and see why\nthe dereference operator doesn’t work like a reference on our newly defined\ntype. We’ll explore how implementing the <code>Deref</code> trait makes it possible for\nsmart pointers to work in ways similar to references. Then we’ll look at\nRust’s <em>deref coercion</em> feature and how it lets us work with either references\nor smart pointers.</p>\n<blockquote>\n<p dir=\"auto\">Note: there’s one big difference between the <code>MyBox&lt;T&gt;</code> type we’re about to\nbuild and the real <code>Box&lt;T&gt;</code>: our version will not store its data on the heap.\nWe are focusing this example on <code>Deref</code>, so where the data is actually stored\nis less important than the pointer-like behavior.</p>\n</blockquote>\n\n<p dir=\"auto\"><a id=\"user-content-following-the-pointer-to-the-value-with-the-dereference-operator\"></a></p>\n<h3 tabindex=\"-1\" id=\"user-content-following-the-pointer-to-the-value\" dir=\"auto\"><a class=\"heading-link\" href=\"#following-the-pointer-to-the-value\">Following the Pointer to the Value<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">A regular reference is a type of pointer, and one way to think of a pointer is\nas an arrow to a value stored somewhere else. In Listing 15-6, we create a\nreference to an <code>i32</code> value and then use the dereference operator to follow the\nreference to the value:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-06/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">06</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-6: Using the dereference operator to follow a\nreference to an <code>i32</code> value</span></p>\n<p dir=\"auto\">The variable <code>x</code> holds an <code>i32</code> value <code>5</code>. We set <code>y</code> equal to a reference to\n<code>x</code>. We can assert that <code>x</code> is equal to <code>5</code>. However, if we want to make an\nassertion about the value in <code>y</code>, we have to use <code>*y</code> to follow the reference\nto the value it’s pointing to (hence <em>dereference</em>) so the compiler can compare\nthe actual value. Once we dereference <code>y</code>, we have access to the integer value\n<code>y</code> is pointing to that we can compare with <code>5</code>.</p>\n<p dir=\"auto\">If we tried to write <code>assert_eq!(5, y);</code> instead, we would get this compilation\nerror:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch15-smart-pointers/output-only-01-comparing-to-reference/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch15-smart-pointers/output-only-01-comparing-to-reference/output.txt}}</span></pre></div>\n<p dir=\"auto\">Comparing a number and a reference to a number isn’t allowed because they’re\ndifferent types. We must use the dereference operator to follow the reference\nto the value it’s pointing to.</p>\n<h3 tabindex=\"-1\" id=\"user-content-using-boxt-like-a-reference\" dir=\"auto\"><a class=\"heading-link\" href=\"#using-boxt-like-a-reference\">Using <code>Box&lt;T&gt;</code> Like a Reference<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">We can rewrite the code in Listing 15-6 to use a <code>Box&lt;T&gt;</code> instead of a\nreference; the dereference operator used on the <code>Box&lt;T&gt;</code> in Listing 15-7\nfunctions in the same way as the dereference operator used on the reference in\nListing 15-6:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-07/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">07</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-7: Using the dereference operator on a\n<code>Box&lt;i32&gt;</code></span></p>\n<p dir=\"auto\">The main difference between Listing 15-7 and Listing 15-6 is that here we set\n<code>y</code> to be an instance of a <code>Box&lt;T&gt;</code> pointing to a copied value of <code>x</code> rather\nthan a reference pointing to the value of <code>x</code>. In the last assertion, we can\nuse the dereference operator to follow the pointer of the <code>Box&lt;T&gt;</code> in the same\nway that we did when <code>y</code> was a reference. Next, we’ll explore what is special\nabout <code>Box&lt;T&gt;</code> that enables us to use the dereference operator by defining our\nown type.</p>\n<h3 tabindex=\"-1\" id=\"user-content-defining-our-own-smart-pointer\" dir=\"auto\"><a class=\"heading-link\" href=\"#defining-our-own-smart-pointer\">Defining Our Own Smart Pointer<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">Let’s build a smart pointer similar to the <code>Box&lt;T&gt;</code> type provided by the\nstandard library to experience how smart pointers behave differently from\nreferences by default. Then we’ll look at how to add the ability to use the\ndereference operator.</p>\n<p dir=\"auto\">The <code>Box&lt;T&gt;</code> type is ultimately defined as a tuple struct with one element, so\nListing 15-8 defines a <code>MyBox&lt;T&gt;</code> type in the same way. We’ll also define a\n<code>new</code> function to match the <code>new</code> function defined on <code>Box&lt;T&gt;</code>.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-08/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">08</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-8: Defining a <code>MyBox&lt;T&gt;</code> type</span></p>\n<p dir=\"auto\">We define a struct named <code>MyBox</code> and declare a generic parameter <code>T</code>, because\nwe want our type to hold values of any type. The <code>MyBox</code> type is a tuple struct\nwith one element of type <code>T</code>. The <code>MyBox::new</code> function takes one parameter of\ntype <code>T</code> and returns a <code>MyBox</code> instance that holds the value passed in.</p>\n<p dir=\"auto\">Let’s try adding the <code>main</code> function in Listing 15-7 to Listing 15-8 and\nchanging it to use the <code>MyBox&lt;T&gt;</code> type we’ve defined instead of <code>Box&lt;T&gt;</code>. The\ncode in Listing 15-9 won’t compile because Rust doesn’t know how to dereference\n<code>MyBox</code>.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-09/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">09</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-9: Attempting to use <code>MyBox&lt;T&gt;</code> in the same\nway we used references and <code>Box&lt;T&gt;</code></span></p>\n<p dir=\"auto\">Here’s the resulting compilation error:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch15-smart-pointers/listing-15-09/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch15-smart-pointers/listing-15-09/output.txt}}</span></pre></div>\n<p dir=\"auto\">Our <code>MyBox&lt;T&gt;</code> type can’t be dereferenced because we haven’t implemented that\nability on our type. To enable dereferencing with the <code>*</code> operator, we\nimplement the <code>Deref</code> trait.</p>\n<h3 tabindex=\"-1\" id=\"user-content-treating-a-type-like-a-reference-by-implementing-the-deref-trait\" dir=\"auto\"><a class=\"heading-link\" href=\"#treating-a-type-like-a-reference-by-implementing-the-deref-trait\">Treating a Type Like a Reference by Implementing the <code>Deref</code> Trait<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">As discussed in the <a href=\"/rust-lang/book/blob/main/src/ch10-02-traits.html#implementing-a-trait-on-a-type\">“Implementing a Trait on a Type”</a> section of Chapter 10, to implement a trait, we need to provide\nimplementations for the trait’s required methods. The <code>Deref</code> trait, provided\nby the standard library, requires us to implement one method named <code>deref</code> that\nborrows <code>self</code> and returns a reference to the inner data. Listing 15-10\ncontains an implementation of <code>Deref</code> to add to the definition of <code>MyBox</code>:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-10/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">10</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-10: Implementing <code>Deref</code> on <code>MyBox&lt;T&gt;</code></span></p>\n<p dir=\"auto\">The <code>type Target = T;</code> syntax defines an associated type for the <code>Deref</code>\ntrait to use. Associated types are a slightly different way of declaring a\ngeneric parameter, but you don’t need to worry about them for now; we’ll cover\nthem in more detail in Chapter 19.</p>\n<p dir=\"auto\">We fill in the body of the <code>deref</code> method with <code>&amp;self.0</code> so <code>deref</code> returns a\nreference to the value we want to access with the <code>*</code> operator; recall from the\n<a href=\"/rust-lang/book/blob/main/src/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types\">“Using Tuple Structs without Named Fields to Create Different\nTypes”</a> section of Chapter 5 that <code>.0</code> accesses\nthe first value in a tuple struct. The <code>main</code> function in Listing 15-9 that\ncalls <code>*</code> on the <code>MyBox&lt;T&gt;</code> value now compiles, and the assertions pass!</p>\n<p dir=\"auto\">Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references.\nThe <code>deref</code> method gives the compiler the ability to take a value of any type\nthat implements <code>Deref</code> and call the <code>deref</code> method to get a <code>&amp;</code> reference that\nit knows how to dereference.</p>\n<p dir=\"auto\">When we entered <code>*y</code> in Listing 15-9, behind the scenes Rust actually ran this\ncode:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"*(y.deref())\"><pre><span class=\"pl-c1\">*</span><span class=\"pl-kos\">(</span>y<span class=\"pl-kos\">.</span><span class=\"pl-en\">deref</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">Rust substitutes the <code>*</code> operator with a call to the <code>deref</code> method and then a\nplain dereference so we don’t have to think about whether or not we need to\ncall the <code>deref</code> method. This Rust feature lets us write code that functions\nidentically whether we have a regular reference or a type that implements\n<code>Deref</code>.</p>\n<p dir=\"auto\">The reason the <code>deref</code> method returns a reference to a value, and that the\nplain dereference outside the parentheses in <code>*(y.deref())</code> is still necessary,\nis to do with the ownership system. If the <code>deref</code> method returned the value\ndirectly instead of a reference to the value, the value would be moved out of\n<code>self</code>. We don’t want to take ownership of the inner value inside <code>MyBox&lt;T&gt;</code> in\nthis case or in most cases where we use the dereference operator.</p>\n<p dir=\"auto\">Note that the <code>*</code> operator is replaced with a call to the <code>deref</code> method and\nthen a call to the <code>*</code> operator just once, each time we use a <code>*</code> in our code.\nBecause the substitution of the <code>*</code> operator does not recurse infinitely, we\nend up with data of type <code>i32</code>, which matches the <code>5</code> in <code>assert_eq!</code> in\nListing 15-9.</p>\n<h3 tabindex=\"-1\" id=\"user-content-implicit-deref-coercions-with-functions-and-methods\" dir=\"auto\"><a class=\"heading-link\" href=\"#implicit-deref-coercions-with-functions-and-methods\">Implicit Deref Coercions with Functions and Methods<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\"><em>Deref coercion</em> converts a reference to a type that implements the <code>Deref</code>\ntrait into a reference to another type. For example, deref coercion can convert\n<code>&amp;String</code> to <code>&amp;str</code> because <code>String</code> implements the <code>Deref</code> trait such that it\nreturns <code>&amp;str</code>. Deref coercion is a convenience Rust performs on arguments to\nfunctions and methods, and works only on types that implement the <code>Deref</code>\ntrait. It happens automatically when we pass a reference to a particular type’s\nvalue as an argument to a function or method that doesn’t match the parameter\ntype in the function or method definition. A sequence of calls to the <code>deref</code>\nmethod converts the type we provided into the type the parameter needs.</p>\n<p dir=\"auto\">Deref coercion was added to Rust so that programmers writing function and\nmethod calls don’t need to add as many explicit references and dereferences\nwith <code>&amp;</code> and <code>*</code>. The deref coercion feature also lets us write more code that\ncan work for either references or smart pointers.</p>\n<p dir=\"auto\">To see deref coercion in action, let’s use the <code>MyBox&lt;T&gt;</code> type we defined in\nListing 15-8 as well as the implementation of <code>Deref</code> that we added in Listing\n15-10. Listing 15-11 shows the definition of a function that has a string slice\nparameter:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-11/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">11</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-11: A <code>hello</code> function that has the parameter\n<code>name</code> of type <code>&amp;str</code></span></p>\n<p dir=\"auto\">We can call the <code>hello</code> function with a string slice as an argument, such as\n<code>hello(\"Rust\");</code> for example. Deref coercion makes it possible to call <code>hello</code>\nwith a reference to a value of type <code>MyBox&lt;String&gt;</code>, as shown in Listing 15-12:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-12/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">12</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-12: Calling <code>hello</code> with a reference to a\n<code>MyBox&lt;String&gt;</code> value, which works because of deref coercion</span></p>\n<p dir=\"auto\">Here we’re calling the <code>hello</code> function with the argument <code>&amp;m</code>, which is a\nreference to a <code>MyBox&lt;String&gt;</code> value. Because we implemented the <code>Deref</code> trait\non <code>MyBox&lt;T&gt;</code> in Listing 15-10, Rust can turn <code>&amp;MyBox&lt;String&gt;</code> into <code>&amp;String</code>\nby calling <code>deref</code>. The standard library provides an implementation of <code>Deref</code>\non <code>String</code> that returns a string slice, and this is in the API documentation\nfor <code>Deref</code>. Rust calls <code>deref</code> again to turn the <code>&amp;String</code> into <code>&amp;str</code>, which\nmatches the <code>hello</code> function’s definition.</p>\n<p dir=\"auto\">If Rust didn’t implement deref coercion, we would have to write the code in\nListing 15-13 instead of the code in Listing 15-12 to call <code>hello</code> with a value\nof type <code>&amp;MyBox&lt;String&gt;</code>.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-13/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch15-smart-pointers/listing-<span class=\"pl-c1\">15</span>-<span class=\"pl-c1\">13</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 15-13: The code we would have to write if Rust\ndidn’t have deref coercion</span></p>\n<p dir=\"auto\">The <code>(*m)</code> dereferences the <code>MyBox&lt;String&gt;</code> into a <code>String</code>. Then the <code>&amp;</code> and\n<code>[..]</code> take a string slice of the <code>String</code> that is equal to the whole string to\nmatch the signature of <code>hello</code>. This code without deref coercions is harder to\nread, write, and understand with all of these symbols involved. Deref coercion\nallows Rust to handle these conversions for us automatically.</p>\n<p dir=\"auto\">When the <code>Deref</code> trait is defined for the types involved, Rust will analyze the\ntypes and use <code>Deref::deref</code> as many times as necessary to get a reference to\nmatch the parameter’s type. The number of times that <code>Deref::deref</code> needs to be\ninserted is resolved at compile time, so there is no runtime penalty for taking\nadvantage of deref coercion!</p>\n<h3 tabindex=\"-1\" id=\"user-content-how-deref-coercion-interacts-with-mutability\" dir=\"auto\"><a class=\"heading-link\" href=\"#how-deref-coercion-interacts-with-mutability\">How Deref Coercion Interacts with Mutability<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">Similar to how you use the <code>Deref</code> trait to override the <code>*</code> operator on\nimmutable references, you can use the <code>DerefMut</code> trait to override the <code>*</code>\noperator on mutable references.</p>\n<p dir=\"auto\">Rust does deref coercion when it finds types and trait implementations in three\ncases:</p>\n<ul dir=\"auto\">\n<li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>\n<li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></li>\n<li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>\n</ul>\n<p dir=\"auto\">The first two cases are the same as each other except that the second\nimplements mutability. The first case states that if you have a <code>&amp;T</code>, and <code>T</code>\nimplements <code>Deref</code> to some type <code>U</code>, you can get a <code>&amp;U</code> transparently. The\nsecond case states that the same deref coercion happens for mutable references.</p>\n<p dir=\"auto\">The third case is trickier: Rust will also coerce a mutable reference to an\nimmutable one. But the reverse is <em>not</em> possible: immutable references will\nnever coerce to mutable references. Because of the borrowing rules, if you have\na mutable reference, that mutable reference must be the only reference to that\ndata (otherwise, the program wouldn’t compile). Converting one mutable\nreference to one immutable reference will never break the borrowing rules.\nConverting an immutable reference to a mutable reference would require that the\ninitial immutable reference is the only immutable reference to that data, but\nthe borrowing rules don’t guarantee that. Therefore, Rust can’t make the\nassumption that converting an immutable reference to a mutable reference is\npossible.</p>\n</article>","renderedFileInfo":null,"shortPath":null,"tabSize":8,"topBannersInfo":{"overridingGlobalFundingFile":false,"globalPreferredFundingPath":null,"repoOwner":"rust-lang","repoName":"book","showInvalidCitationWarning":false,"citationHelpUrl":"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/about-citation-files","showDependabotConfigurationBanner":false,"actionsOnboardingTip":null},"truncated":false,"viewable":true,"workflowRedirectUrl":null,"symbols":{"timedOut":false,"notAnalyzed":true,"symbols":[]}},"copilotInfo":null,"csrf_tokens":{"/rust-lang/book/branches":{"post":"1xImLicnLHzqn2SRCoGhfpMVf5Qfk_dcsZoNwFimvUxxIrkuX_sZAs267vQFHcLo0n8GfOsyXhsFQshV9wmw-Q"},"/repos/preferences":{"post":"HpVR1o_PR0Hypk7n7_uq4N_AonwUNryI_mCIxpC-dQvS6fl2yaknnuNbFrhKxGzQxMcRG1jeHgZFprGBh8YxFg"}}},"title":"book/src/ch15-02-deref.md at main · rust-lang/book"}
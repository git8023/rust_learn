{"payload":{"allShortcutsEnabled":false,"fileTree":{"src":{"items":[{"name":"img","path":"src/img","contentType":"directory"},{"name":"SUMMARY.md","path":"src/SUMMARY.md","contentType":"file"},{"name":"appendix-00.md","path":"src/appendix-00.md","contentType":"file"},{"name":"appendix-01-keywords.md","path":"src/appendix-01-keywords.md","contentType":"file"},{"name":"appendix-02-operators.md","path":"src/appendix-02-operators.md","contentType":"file"},{"name":"appendix-03-derivable-traits.md","path":"src/appendix-03-derivable-traits.md","contentType":"file"},{"name":"appendix-04-useful-development-tools.md","path":"src/appendix-04-useful-development-tools.md","contentType":"file"},{"name":"appendix-05-editions.md","path":"src/appendix-05-editions.md","contentType":"file"},{"name":"appendix-06-translation.md","path":"src/appendix-06-translation.md","contentType":"file"},{"name":"appendix-07-nightly-rust.md","path":"src/appendix-07-nightly-rust.md","contentType":"file"},{"name":"ch00-00-introduction.md","path":"src/ch00-00-introduction.md","contentType":"file"},{"name":"ch01-00-getting-started.md","path":"src/ch01-00-getting-started.md","contentType":"file"},{"name":"ch01-01-installation.md","path":"src/ch01-01-installation.md","contentType":"file"},{"name":"ch01-02-hello-world.md","path":"src/ch01-02-hello-world.md","contentType":"file"},{"name":"ch01-03-hello-cargo.md","path":"src/ch01-03-hello-cargo.md","contentType":"file"},{"name":"ch02-00-guessing-game-tutorial.md","path":"src/ch02-00-guessing-game-tutorial.md","contentType":"file"},{"name":"ch03-00-common-programming-concepts.md","path":"src/ch03-00-common-programming-concepts.md","contentType":"file"},{"name":"ch03-01-variables-and-mutability.md","path":"src/ch03-01-variables-and-mutability.md","contentType":"file"},{"name":"ch03-02-data-types.md","path":"src/ch03-02-data-types.md","contentType":"file"},{"name":"ch03-03-how-functions-work.md","path":"src/ch03-03-how-functions-work.md","contentType":"file"},{"name":"ch03-04-comments.md","path":"src/ch03-04-comments.md","contentType":"file"},{"name":"ch03-05-control-flow.md","path":"src/ch03-05-control-flow.md","contentType":"file"},{"name":"ch04-00-understanding-ownership.md","path":"src/ch04-00-understanding-ownership.md","contentType":"file"},{"name":"ch04-01-what-is-ownership.md","path":"src/ch04-01-what-is-ownership.md","contentType":"file"},{"name":"ch04-02-references-and-borrowing.md","path":"src/ch04-02-references-and-borrowing.md","contentType":"file"},{"name":"ch04-03-slices.md","path":"src/ch04-03-slices.md","contentType":"file"},{"name":"ch05-00-structs.md","path":"src/ch05-00-structs.md","contentType":"file"},{"name":"ch05-01-defining-structs.md","path":"src/ch05-01-defining-structs.md","contentType":"file"},{"name":"ch05-02-example-structs.md","path":"src/ch05-02-example-structs.md","contentType":"file"},{"name":"ch05-03-method-syntax.md","path":"src/ch05-03-method-syntax.md","contentType":"file"},{"name":"ch06-00-enums.md","path":"src/ch06-00-enums.md","contentType":"file"},{"name":"ch06-01-defining-an-enum.md","path":"src/ch06-01-defining-an-enum.md","contentType":"file"},{"name":"ch06-02-match.md","path":"src/ch06-02-match.md","contentType":"file"},{"name":"ch06-03-if-let.md","path":"src/ch06-03-if-let.md","contentType":"file"},{"name":"ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","path":"src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","contentType":"file"},{"name":"ch07-01-packages-and-crates.md","path":"src/ch07-01-packages-and-crates.md","contentType":"file"},{"name":"ch07-02-defining-modules-to-control-scope-and-privacy.md","path":"src/ch07-02-defining-modules-to-control-scope-and-privacy.md","contentType":"file"},{"name":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","path":"src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","contentType":"file"},{"name":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","path":"src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","contentType":"file"},{"name":"ch07-05-separating-modules-into-different-files.md","path":"src/ch07-05-separating-modules-into-different-files.md","contentType":"file"},{"name":"ch08-00-common-collections.md","path":"src/ch08-00-common-collections.md","contentType":"file"},{"name":"ch08-01-vectors.md","path":"src/ch08-01-vectors.md","contentType":"file"},{"name":"ch08-02-strings.md","path":"src/ch08-02-strings.md","contentType":"file"},{"name":"ch08-03-hash-maps.md","path":"src/ch08-03-hash-maps.md","contentType":"file"},{"name":"ch09-00-error-handling.md","path":"src/ch09-00-error-handling.md","contentType":"file"},{"name":"ch09-01-unrecoverable-errors-with-panic.md","path":"src/ch09-01-unrecoverable-errors-with-panic.md","contentType":"file"},{"name":"ch09-02-recoverable-errors-with-result.md","path":"src/ch09-02-recoverable-errors-with-result.md","contentType":"file"},{"name":"ch09-03-to-panic-or-not-to-panic.md","path":"src/ch09-03-to-panic-or-not-to-panic.md","contentType":"file"},{"name":"ch10-00-generics.md","path":"src/ch10-00-generics.md","contentType":"file"},{"name":"ch10-01-syntax.md","path":"src/ch10-01-syntax.md","contentType":"file"},{"name":"ch10-02-traits.md","path":"src/ch10-02-traits.md","contentType":"file"},{"name":"ch10-03-lifetime-syntax.md","path":"src/ch10-03-lifetime-syntax.md","contentType":"file"},{"name":"ch11-00-testing.md","path":"src/ch11-00-testing.md","contentType":"file"},{"name":"ch11-01-writing-tests.md","path":"src/ch11-01-writing-tests.md","contentType":"file"},{"name":"ch11-02-running-tests.md","path":"src/ch11-02-running-tests.md","contentType":"file"},{"name":"ch11-03-test-organization.md","path":"src/ch11-03-test-organization.md","contentType":"file"},{"name":"ch12-00-an-io-project.md","path":"src/ch12-00-an-io-project.md","contentType":"file"},{"name":"ch12-01-accepting-command-line-arguments.md","path":"src/ch12-01-accepting-command-line-arguments.md","contentType":"file"},{"name":"ch12-02-reading-a-file.md","path":"src/ch12-02-reading-a-file.md","contentType":"file"},{"name":"ch12-03-improving-error-handling-and-modularity.md","path":"src/ch12-03-improving-error-handling-and-modularity.md","contentType":"file"},{"name":"ch12-04-testing-the-librarys-functionality.md","path":"src/ch12-04-testing-the-librarys-functionality.md","contentType":"file"},{"name":"ch12-05-working-with-environment-variables.md","path":"src/ch12-05-working-with-environment-variables.md","contentType":"file"},{"name":"ch12-06-writing-to-stderr-instead-of-stdout.md","path":"src/ch12-06-writing-to-stderr-instead-of-stdout.md","contentType":"file"},{"name":"ch13-00-functional-features.md","path":"src/ch13-00-functional-features.md","contentType":"file"},{"name":"ch13-01-closures.md","path":"src/ch13-01-closures.md","contentType":"file"},{"name":"ch13-02-iterators.md","path":"src/ch13-02-iterators.md","contentType":"file"},{"name":"ch13-03-improving-our-io-project.md","path":"src/ch13-03-improving-our-io-project.md","contentType":"file"},{"name":"ch13-04-performance.md","path":"src/ch13-04-performance.md","contentType":"file"},{"name":"ch14-00-more-about-cargo.md","path":"src/ch14-00-more-about-cargo.md","contentType":"file"},{"name":"ch14-01-release-profiles.md","path":"src/ch14-01-release-profiles.md","contentType":"file"},{"name":"ch14-02-publishing-to-crates-io.md","path":"src/ch14-02-publishing-to-crates-io.md","contentType":"file"},{"name":"ch14-03-cargo-workspaces.md","path":"src/ch14-03-cargo-workspaces.md","contentType":"file"},{"name":"ch14-04-installing-binaries.md","path":"src/ch14-04-installing-binaries.md","contentType":"file"},{"name":"ch14-05-extending-cargo.md","path":"src/ch14-05-extending-cargo.md","contentType":"file"},{"name":"ch15-00-smart-pointers.md","path":"src/ch15-00-smart-pointers.md","contentType":"file"},{"name":"ch15-01-box.md","path":"src/ch15-01-box.md","contentType":"file"},{"name":"ch15-02-deref.md","path":"src/ch15-02-deref.md","contentType":"file"},{"name":"ch15-03-drop.md","path":"src/ch15-03-drop.md","contentType":"file"},{"name":"ch15-04-rc.md","path":"src/ch15-04-rc.md","contentType":"file"},{"name":"ch15-05-interior-mutability.md","path":"src/ch15-05-interior-mutability.md","contentType":"file"},{"name":"ch15-06-reference-cycles.md","path":"src/ch15-06-reference-cycles.md","contentType":"file"},{"name":"ch16-00-concurrency.md","path":"src/ch16-00-concurrency.md","contentType":"file"},{"name":"ch16-01-threads.md","path":"src/ch16-01-threads.md","contentType":"file"},{"name":"ch16-02-message-passing.md","path":"src/ch16-02-message-passing.md","contentType":"file"},{"name":"ch16-03-shared-state.md","path":"src/ch16-03-shared-state.md","contentType":"file"},{"name":"ch16-04-extensible-concurrency-sync-and-send.md","path":"src/ch16-04-extensible-concurrency-sync-and-send.md","contentType":"file"},{"name":"ch17-00-oop.md","path":"src/ch17-00-oop.md","contentType":"file"},{"name":"ch17-01-what-is-oo.md","path":"src/ch17-01-what-is-oo.md","contentType":"file"},{"name":"ch17-02-trait-objects.md","path":"src/ch17-02-trait-objects.md","contentType":"file"},{"name":"ch17-03-oo-design-patterns.md","path":"src/ch17-03-oo-design-patterns.md","contentType":"file"},{"name":"ch18-00-patterns.md","path":"src/ch18-00-patterns.md","contentType":"file"},{"name":"ch18-01-all-the-places-for-patterns.md","path":"src/ch18-01-all-the-places-for-patterns.md","contentType":"file"},{"name":"ch18-02-refutability.md","path":"src/ch18-02-refutability.md","contentType":"file"},{"name":"ch18-03-pattern-syntax.md","path":"src/ch18-03-pattern-syntax.md","contentType":"file"},{"name":"ch19-00-advanced-features.md","path":"src/ch19-00-advanced-features.md","contentType":"file"},{"name":"ch19-01-unsafe-rust.md","path":"src/ch19-01-unsafe-rust.md","contentType":"file"},{"name":"ch19-03-advanced-traits.md","path":"src/ch19-03-advanced-traits.md","contentType":"file"},{"name":"ch19-04-advanced-types.md","path":"src/ch19-04-advanced-types.md","contentType":"file"},{"name":"ch19-05-advanced-functions-and-closures.md","path":"src/ch19-05-advanced-functions-and-closures.md","contentType":"file"},{"name":"ch19-06-macros.md","path":"src/ch19-06-macros.md","contentType":"file"},{"name":"ch20-00-final-project-a-web-server.md","path":"src/ch20-00-final-project-a-web-server.md","contentType":"file"},{"name":"ch20-01-single-threaded.md","path":"src/ch20-01-single-threaded.md","contentType":"file"},{"name":"ch20-02-multithreaded.md","path":"src/ch20-02-multithreaded.md","contentType":"file"},{"name":"ch20-03-graceful-shutdown-and-cleanup.md","path":"src/ch20-03-graceful-shutdown-and-cleanup.md","contentType":"file"},{"name":"foreword.md","path":"src/foreword.md","contentType":"file"},{"name":"title-page.md","path":"src/title-page.md","contentType":"file"}],"totalCount":106},"":{"items":[{"name":".cargo","path":".cargo","contentType":"directory"},{"name":".github","path":".github","contentType":"directory"},{"name":"2018-edition","path":"2018-edition","contentType":"directory"},{"name":"ci","path":"ci","contentType":"directory"},{"name":"dot","path":"dot","contentType":"directory"},{"name":"first-edition","path":"first-edition","contentType":"directory"},{"name":"listings","path":"listings","contentType":"directory"},{"name":"nostarch","path":"nostarch","contentType":"directory"},{"name":"redirects","path":"redirects","contentType":"directory"},{"name":"second-edition","path":"second-edition","contentType":"directory"},{"name":"src","path":"src","contentType":"directory"},{"name":"theme","path":"theme","contentType":"directory"},{"name":"tools","path":"tools","contentType":"directory"},{"name":".gitattributes","path":".gitattributes","contentType":"file"},{"name":".gitignore","path":".gitignore","contentType":"file"},{"name":"ADMIN_TASKS.md","path":"ADMIN_TASKS.md","contentType":"file"},{"name":"CONTRIBUTING.md","path":"CONTRIBUTING.md","contentType":"file"},{"name":"COPYRIGHT","path":"COPYRIGHT","contentType":"file"},{"name":"Cargo.lock","path":"Cargo.lock","contentType":"file"},{"name":"Cargo.toml","path":"Cargo.toml","contentType":"file"},{"name":"LICENSE-APACHE","path":"LICENSE-APACHE","contentType":"file"},{"name":"LICENSE-MIT","path":"LICENSE-MIT","contentType":"file"},{"name":"README.md","path":"README.md","contentType":"file"},{"name":"TODO.md","path":"TODO.md","contentType":"file"},{"name":"book.toml","path":"book.toml","contentType":"file"},{"name":"ferris.css","path":"ferris.css","contentType":"file"},{"name":"ferris.js","path":"ferris.js","contentType":"file"},{"name":"rust-toolchain","path":"rust-toolchain","contentType":"file"},{"name":"rustfmt.toml","path":"rustfmt.toml","contentType":"file"},{"name":"style-guide.md","path":"style-guide.md","contentType":"file"}],"totalCount":30}},"fileTreeProcessingTime":13.786068,"foldersToFetch":[],"reducedMotionEnabled":null,"repo":{"id":47854924,"defaultBranch":"main","name":"book","ownerLogin":"rust-lang","currentUserCanPush":false,"isFork":false,"isEmpty":false,"createdAt":"2015-12-11T22:49:49.000Z","ownerAvatar":"https://avatars.githubusercontent.com/u/5430905?v=4","public":true,"private":false,"isOrgOwned":true},"symbolsExpanded":false,"treeExpanded":true,"refInfo":{"name":"main","listCacheKey":"v0:1688046669.0","canEdit":false,"refType":"branch","currentOid":"72187f5cd0beaaa9c6f584156bcd88f921871e83"},"path":"src/ch19-06-macros.md","currentUser":null,"blob":{"rawLines":null,"stylingDirectives":null,"csv":null,"csvError":null,"dependabotInfo":{"showConfigurationBanner":false,"configFilePath":null,"networkDependabotPath":"/rust-lang/book/network/updates","dismissConfigurationNoticePath":"/settings/dismiss-notice/dependabot_configuration_notice","configurationNoticeDismissed":null,"repoAlertsPath":"/rust-lang/book/security/dependabot","repoSecurityAndAnalysisPath":"/rust-lang/book/settings/security_analysis","repoOwnerIsOrg":true,"currentUserCanAdminRepo":false},"displayName":"ch19-06-macros.md","displayUrl":"https://github.com/rust-lang/book/blob/main/src/ch19-06-macros.md?raw=true","headerInfo":{"blobSize":"24 KB","deleteInfo":{"deleteTooltip":"You must be signed in to make or propose changes"},"editInfo":{"editTooltip":"You must be signed in to make or propose changes"},"ghDesktopPath":"https://desktop.github.com","gitLfsPath":null,"onBranch":true,"shortPath":"7731869","siteNavLoginPath":"/login?return_to=https%3A%2F%2Fgithub.com%2Frust-lang%2Fbook%2Fblob%2Fmain%2Fsrc%2Fch19-06-macros.md","isCSV":false,"isRichtext":true,"toc":[{"level":2,"text":"Macros","anchor":"macros","htmlText":"Macros"},{"level":3,"text":"The Difference Between Macros and Functions","anchor":"the-difference-between-macros-and-functions","htmlText":"The Difference Between Macros and Functions"},{"level":3,"text":"Declarative Macros with macro_rules! for General Metaprogramming","anchor":"declarative-macros-with-macro_rules-for-general-metaprogramming","htmlText":"Declarative Macros with macro_rules! for General Metaprogramming"},{"level":3,"text":"Procedural Macros for Generating Code from Attributes","anchor":"procedural-macros-for-generating-code-from-attributes","htmlText":"Procedural Macros for Generating Code from Attributes"},{"level":3,"text":"How to Write a Custom derive Macro","anchor":"how-to-write-a-custom-derive-macro","htmlText":"How to Write a Custom derive Macro"},{"level":3,"text":"Attribute-like macros","anchor":"attribute-like-macros","htmlText":"Attribute-like macros"},{"level":3,"text":"Function-like macros","anchor":"function-like-macros","htmlText":"Function-like macros"},{"level":2,"text":"Summary","anchor":"summary","htmlText":"Summary"}],"lineInfo":{"truncatedLoc":"513","truncatedSloc":"409"},"mode":"file"},"image":false,"isCodeownersFile":null,"isPlain":false,"isValidLegacyIssueTemplate":false,"issueTemplateHelpUrl":"https://docs.github.com/articles/about-issue-and-pull-request-templates","issueTemplate":null,"discussionTemplate":null,"language":"Markdown","languageID":222,"large":false,"loggedIn":false,"newDiscussionPath":"/rust-lang/book/discussions/new","newIssuePath":"/rust-lang/book/issues/new","planSupportInfo":{"repoIsFork":null,"repoOwnedByCurrentUser":null,"requestFullPath":"/rust-lang/book/blob/main/src/ch19-06-macros.md","showFreeOrgGatedFeatureMessage":null,"showPlanSupportBanner":null,"upgradeDataAttributes":null,"upgradePath":null},"publishBannersInfo":{"dismissActionNoticePath":"/settings/dismiss-notice/publish_action_from_dockerfile","dismissStackNoticePath":"/settings/dismiss-notice/publish_stack_from_file","releasePath":"/rust-lang/book/releases/new?marketplace=true","showPublishActionBanner":false,"showPublishStackBanner":false},"renderImageOrRaw":false,"richText":"<article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><h2 tabindex=\"-1\" id=\"user-content-macros\" dir=\"auto\"><a class=\"heading-link\" href=\"#macros\">Macros<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">We’ve used macros like <code>println!</code> throughout this book, but we haven’t fully\nexplored what a macro is and how it works. The term <em>macro</em> refers to a family\nof features in Rust: <em>declarative</em> macros with <code>macro_rules!</code> and three kinds\nof <em>procedural</em> macros:</p>\n<ul dir=\"auto\">\n<li>Custom <code>#[derive]</code> macros that specify code added with the <code>derive</code> attribute\nused on structs and enums</li>\n<li>Attribute-like macros that define custom attributes usable on any item</li>\n<li>Function-like macros that look like function calls but operate on the tokens\nspecified as their argument</li>\n</ul>\n<p dir=\"auto\">We’ll talk about each of these in turn, but first, let’s look at why we even\nneed macros when we already have functions.</p>\n<h3 tabindex=\"-1\" id=\"user-content-the-difference-between-macros-and-functions\" dir=\"auto\"><a class=\"heading-link\" href=\"#the-difference-between-macros-and-functions\">The Difference Between Macros and Functions<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">Fundamentally, macros are a way of writing code that writes other code, which\nis known as <em>metaprogramming</em>. In Appendix C, we discuss the <code>derive</code>\nattribute, which generates an implementation of various traits for you. We’ve\nalso used the <code>println!</code> and <code>vec!</code> macros throughout the book. All of these\nmacros <em>expand</em> to produce more code than the code you’ve written manually.</p>\n<p dir=\"auto\">Metaprogramming is useful for reducing the amount of code you have to write and\nmaintain, which is also one of the roles of functions. However, macros have\nsome additional powers that functions don’t.</p>\n<p dir=\"auto\">A function signature must declare the number and type of parameters the\nfunction has. Macros, on the other hand, can take a variable number of\nparameters: we can call <code>println!(\"hello\")</code> with one argument or\n<code>println!(\"hello {}\", name)</code> with two arguments. Also, macros are expanded\nbefore the compiler interprets the meaning of the code, so a macro can, for\nexample, implement a trait on a given type. A function can’t, because it gets\ncalled at runtime and a trait needs to be implemented at compile time.</p>\n<p dir=\"auto\">The downside to implementing a macro instead of a function is that macro\ndefinitions are more complex than function definitions because you’re writing\nRust code that writes Rust code. Due to this indirection, macro definitions are\ngenerally more difficult to read, understand, and maintain than function\ndefinitions.</p>\n<p dir=\"auto\">Another important difference between macros and functions is that you must\ndefine macros or bring them into scope <em>before</em> you call them in a file, as\nopposed to functions you can define anywhere and call anywhere.</p>\n<h3 tabindex=\"-1\" id=\"user-content-declarative-macros-with-macro_rules-for-general-metaprogramming\" dir=\"auto\"><a class=\"heading-link\" href=\"#declarative-macros-with-macro_rules-for-general-metaprogramming\">Declarative Macros with <code>macro_rules!</code> for General Metaprogramming<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">The most widely used form of macros in Rust is the <em>declarative macro</em>. These\nare also sometimes referred to as “macros by example,” “<code>macro_rules!</code> macros,”\nor just plain “macros.” At their core, declarative macros allow you to write\nsomething similar to a Rust <code>match</code> expression. As discussed in Chapter 6,\n<code>match</code> expressions are control structures that take an expression, compare the\nresulting value of the expression to patterns, and then run the code associated\nwith the matching pattern. Macros also compare a value to patterns that are\nassociated with particular code: in this situation, the value is the literal\nRust source code passed to the macro; the patterns are compared with the\nstructure of that source code; and the code associated with each pattern, when\nmatched, replaces the code passed to the macro. This all happens during\ncompilation.</p>\n<p dir=\"auto\">To define a macro, you use the <code>macro_rules!</code> construct. Let’s explore how to\nuse <code>macro_rules!</code> by looking at how the <code>vec!</code> macro is defined. Chapter 8\ncovered how we can use the <code>vec!</code> macro to create a new vector with particular\nvalues. For example, the following macro creates a new vector containing three\nintegers:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"let v: Vec&lt;u32&gt; = vec![1, 2, 3];\"><pre><span class=\"pl-k\">let</span> v<span class=\"pl-kos\">:</span> <span class=\"pl-smi\">Vec</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">u32</span><span class=\"pl-kos\">&gt;</span> = <span class=\"pl-en\">vec</span><span class=\"pl-en\">!</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">3</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">We could also use the <code>vec!</code> macro to make a vector of two integers or a vector\nof five string slices. We wouldn’t be able to use a function to do the same\nbecause we wouldn’t know the number or type of values up front.</p>\n<p dir=\"auto\">Listing 19-28 shows a slightly simplified definition of the <code>vec!</code> macro.</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-28/src/lib.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">28</span>/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-28: A simplified version of the <code>vec!</code> macro\ndefinition</span></p>\n<blockquote>\n<p dir=\"auto\">Note: The actual definition of the <code>vec!</code> macro in the standard library\nincludes code to preallocate the correct amount of memory up front. That code\nis an optimization that we don’t include here to make the example simpler.</p>\n</blockquote>\n<p dir=\"auto\">The <code>#[macro_export]</code> annotation indicates that this macro should be made\navailable whenever the crate in which the macro is defined is brought into\nscope. Without this annotation, the macro can’t be brought into scope.</p>\n<p dir=\"auto\">We then start the macro definition with <code>macro_rules!</code> and the name of the\nmacro we’re defining <em>without</em> the exclamation mark. The name, in this case\n<code>vec</code>, is followed by curly brackets denoting the body of the macro definition.</p>\n<p dir=\"auto\">The structure in the <code>vec!</code> body is similar to the structure of a <code>match</code>\nexpression. Here we have one arm with the pattern <code>( $( $x:expr ),* )</code>,\nfollowed by <code>=&gt;</code> and the block of code associated with this pattern. If the\npattern matches, the associated block of code will be emitted. Given that this\nis the only pattern in this macro, there is only one valid way to match; any\nother pattern will result in an error. More complex macros will have more than\none arm.</p>\n<p dir=\"auto\">Valid pattern syntax in macro definitions is different than the pattern syntax\ncovered in Chapter 18 because macro patterns are matched against Rust code\nstructure rather than values. Let’s walk through what the pattern pieces in\nListing 19-28 mean; for the full macro pattern syntax, see the <a href=\"/rust-lang/book/blob/main/reference/macros-by-example.html\">Rust\nReference</a>.</p>\n<p dir=\"auto\">First, we use a set of parentheses to encompass the whole pattern. We use a\ndollar sign (<code>$</code>) to declare a variable in the macro system that will contain\nthe Rust code matching the pattern. The dollar sign makes it clear this is a\nmacro variable as opposed to a regular Rust variable. Next comes a set of\nparentheses that captures values that match the pattern within the parentheses\nfor use in the replacement code. Within <code>$()</code> is <code>$x:expr</code>, which matches any\nRust expression and gives the expression the name <code>$x</code>.</p>\n<p dir=\"auto\">The comma following <code>$()</code> indicates that a literal comma separator character\ncould optionally appear after the code that matches the code in <code>$()</code>. The <code>*</code>\nspecifies that the pattern matches zero or more of whatever precedes the <code>*</code>.</p>\n<p dir=\"auto\">When we call this macro with <code>vec![1, 2, 3];</code>, the <code>$x</code> pattern matches three\ntimes with the three expressions <code>1</code>, <code>2</code>, and <code>3</code>.</p>\n<p dir=\"auto\">Now let’s look at the pattern in the body of the code associated with this arm:\n<code>temp_vec.push()</code> within <code>$()*</code> is generated for each part that matches <code>$()</code>\nin the pattern zero or more times depending on how many times the pattern\nmatches. The <code>$x</code> is replaced with each expression matched. When we call this\nmacro with <code>vec![1, 2, 3];</code>, the code generated that replaces this macro call\nwill be the following:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{\n    let mut temp_vec = Vec::new();\n    temp_vec.push(1);\n    temp_vec.push(2);\n    temp_vec.push(3);\n    temp_vec\n}\"><pre><span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">let</span> <span class=\"pl-k\">mut</span> temp_vec = <span class=\"pl-smi\">Vec</span><span class=\"pl-kos\">::</span><span class=\"pl-en\">new</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n    temp_vec<span class=\"pl-kos\">.</span><span class=\"pl-en\">push</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n    temp_vec<span class=\"pl-kos\">.</span><span class=\"pl-en\">push</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">2</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n    temp_vec<span class=\"pl-kos\">.</span><span class=\"pl-en\">push</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">3</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n    temp_vec\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">We’ve defined a macro that can take any number of arguments of any type and can\ngenerate code to create a vector containing the specified elements.</p>\n<p dir=\"auto\">To learn more about how to write macros, consult the online documentation or\nother resources, such as <a href=\"https://veykril.github.io/tlborm/\" rel=\"nofollow\">“The Little Book of Rust Macros”</a> started by\nDaniel Keep and continued by Lukas Wirth.</p>\n<h3 tabindex=\"-1\" id=\"user-content-procedural-macros-for-generating-code-from-attributes\" dir=\"auto\"><a class=\"heading-link\" href=\"#procedural-macros-for-generating-code-from-attributes\">Procedural Macros for Generating Code from Attributes<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">The second form of macros is the <em>procedural macro</em>, which acts more like a\nfunction (and is a type of procedure). Procedural macros accept some code as an\ninput, operate on that code, and produce some code as an output rather than\nmatching against patterns and replacing the code with other code as declarative\nmacros do. The three kinds of procedural macros are custom derive,\nattribute-like, and function-like, and all work in a similar fashion.</p>\n<p dir=\"auto\">When creating procedural macros, the definitions must reside in their own crate\nwith a special crate type. This is for complex technical reasons that we hope\nto eliminate in the future. In Listing 19-29, we show how to define a\nprocedural macro, where <code>some_attribute</code> is a placeholder for using a specific\nmacro variety.</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"use proc_macro;\n\n#[some_attribute]\npub fn some_name(input: TokenStream) -&gt; TokenStream {\n}\"><pre><span class=\"pl-k\">use</span> proc_macro<span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c1\">#<span class=\"pl-kos\">[</span>some_attribute<span class=\"pl-kos\">]</span></span>\n<span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> <span class=\"pl-en\">some_name</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">input</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">TokenStream</span><span class=\"pl-kos\">)</span> -&gt; <span class=\"pl-smi\">TokenStream</span> <span class=\"pl-kos\">{</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-29: An example of defining a procedural\nmacro</span></p>\n<p dir=\"auto\">The function that defines a procedural macro takes a <code>TokenStream</code> as an input\nand produces a <code>TokenStream</code> as an output. The <code>TokenStream</code> type is defined by\nthe <code>proc_macro</code> crate that is included with Rust and represents a sequence of\ntokens. This is the core of the macro: the source code that the macro is\noperating on makes up the input <code>TokenStream</code>, and the code the macro produces\nis the output <code>TokenStream</code>. The function also has an attribute attached to it\nthat specifies which kind of procedural macro we’re creating. We can have\nmultiple kinds of procedural macros in the same crate.</p>\n<p dir=\"auto\">Let’s look at the different kinds of procedural macros. We’ll start with a\ncustom derive macro and then explain the small dissimilarities that make the\nother forms different.</p>\n<h3 tabindex=\"-1\" id=\"user-content-how-to-write-a-custom-derive-macro\" dir=\"auto\"><a class=\"heading-link\" href=\"#how-to-write-a-custom-derive-macro\">How to Write a Custom <code>derive</code> Macro<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">Let’s create a crate named <code>hello_macro</code> that defines a trait named\n<code>HelloMacro</code> with one associated function named <code>hello_macro</code>. Rather than\nmaking our users implement the <code>HelloMacro</code> trait for each of their types,\nwe’ll provide a procedural macro so users can annotate their type with\n<code>#[derive(HelloMacro)]</code> to get a default implementation of the <code>hello_macro</code>\nfunction. The default implementation will print <code>Hello, Macro! My name is TypeName!</code> where <code>TypeName</code> is the name of the type on which this trait has\nbeen defined. In other words, we’ll write a crate that enables another\nprogrammer to write code like Listing 19-30 using our crate.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-30/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">30</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-30: The code a user of our crate will be able\nto write when using our procedural macro</span></p>\n<p dir=\"auto\">This code will print <code>Hello, Macro! My name is Pancakes!</code> when we’re done. The\nfirst step is to make a new library crate, like this:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"$ cargo new hello_macro --lib\"><pre>$ <span class=\"pl-s1\">cargo new hello_macro --lib</span></pre></div>\n<p dir=\"auto\">Next, we’ll define the <code>HelloMacro</code> trait and its associated function:</p>\n<p dir=\"auto\"><span>Filename: src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-20-impl-hellomacro-for-pancakes/hello_macro/src/lib.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/no-listing-<span class=\"pl-c1\">20</span>-impl-hellomacro-<span class=\"pl-k\">for</span>-pancakes/hello_macro/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">We have a trait and its function. At this point, our crate user could implement\nthe trait to achieve the desired functionality, like so:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-20-impl-hellomacro-for-pancakes/pancakes/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/no-listing-<span class=\"pl-c1\">20</span>-impl-hellomacro-<span class=\"pl-k\">for</span>-pancakes/pancakes/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">However, they would need to write the implementation block for each type they\nwanted to use with <code>hello_macro</code>; we want to spare them from having to do this\nwork.</p>\n<p dir=\"auto\">Additionally, we can’t yet provide the <code>hello_macro</code> function with default\nimplementation that will print the name of the type the trait is implemented\non: Rust doesn’t have reflection capabilities, so it can’t look up the type’s\nname at runtime. We need a macro to generate code at compile time.</p>\n<p dir=\"auto\">The next step is to define the procedural macro. At the time of this writing,\nprocedural macros need to be in their own crate. Eventually, this restriction\nmight be lifted. The convention for structuring crates and macro crates is as\nfollows: for a crate named <code>foo</code>, a custom derive procedural macro crate is\ncalled <code>foo_derive</code>. Let’s start a new crate called <code>hello_macro_derive</code> inside\nour <code>hello_macro</code> project:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"$ cargo new hello_macro_derive --lib\"><pre>$ <span class=\"pl-s1\">cargo new hello_macro_derive --lib</span></pre></div>\n<p dir=\"auto\">Our two crates are tightly related, so we create the procedural macro crate\nwithin the directory of our <code>hello_macro</code> crate. If we change the trait\ndefinition in <code>hello_macro</code>, we’ll have to change the implementation of the\nprocedural macro in <code>hello_macro_derive</code> as well. The two crates will need to\nbe published separately, and programmers using these crates will need to add\nboth as dependencies and bring them both into scope. We could instead have the\n<code>hello_macro</code> crate use <code>hello_macro_derive</code> as a dependency and re-export the\nprocedural macro code. However, the way we’ve structured the project makes it\npossible for programmers to use <code>hello_macro</code> even if they don’t want the\n<code>derive</code> functionality.</p>\n<p dir=\"auto\">We need to declare the <code>hello_macro_derive</code> crate as a procedural macro crate.\nWe’ll also need functionality from the <code>syn</code> and <code>quote</code> crates, as you’ll see\nin a moment, so we need to add them as dependencies. Add the following to the\n<em>Cargo.toml</em> file for <code>hello_macro_derive</code>:</p>\n<p dir=\"auto\"><span>Filename: hello_macro_derive/Cargo.toml</span></p>\n<div class=\"highlight highlight-source-toml notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch19-advanced-features/listing-19-31/hello_macro/hello_macro_derive/Cargo.toml:6:12}}\"><pre><span class=\"pl-ii\">{{#include ../listings/ch19-advanced-features/listing-19-31/hello_macro/hello_macro_derive/Cargo.toml:6:12}}</span></pre></div>\n<p dir=\"auto\">To start defining the procedural macro, place the code in Listing 19-31 into\nyour <em>src/lib.rs</em> file for the <code>hello_macro_derive</code> crate. Note that this code\nwon’t compile until we add a definition for the <code>impl_hello_macro</code> function.</p>\n<p dir=\"auto\"><span>Filename: hello_macro_derive/src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-31/hello_macro/hello_macro_derive/src/lib.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">31</span>/hello_macro/hello_macro_derive/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-31: Code that most procedural macro crates\nwill require in order to process Rust code</span></p>\n<p dir=\"auto\">Notice that we’ve split the code into the <code>hello_macro_derive</code> function, which\nis responsible for parsing the <code>TokenStream</code>, and the <code>impl_hello_macro</code>\nfunction, which is responsible for transforming the syntax tree: this makes\nwriting a procedural macro more convenient. The code in the outer function\n(<code>hello_macro_derive</code> in this case) will be the same for almost every\nprocedural macro crate you see or create. The code you specify in the body of\nthe inner function (<code>impl_hello_macro</code> in this case) will be different\ndepending on your procedural macro’s purpose.</p>\n<p dir=\"auto\">We’ve introduced three new crates: <code>proc_macro</code>, <a href=\"https://crates.io/crates/syn\" rel=\"nofollow\"><code>syn</code></a>, and <a href=\"https://crates.io/crates/quote\" rel=\"nofollow\"><code>quote</code></a>. The\n<code>proc_macro</code> crate comes with Rust, so we didn’t need to add that to the\ndependencies in <em>Cargo.toml</em>. The <code>proc_macro</code> crate is the compiler’s API that\nallows us to read and manipulate Rust code from our code.</p>\n<p dir=\"auto\">The <code>syn</code> crate parses Rust code from a string into a data structure that we\ncan perform operations on. The <code>quote</code> crate turns <code>syn</code> data structures back\ninto Rust code. These crates make it much simpler to parse any sort of Rust\ncode we might want to handle: writing a full parser for Rust code is no simple\ntask.</p>\n<p dir=\"auto\">The <code>hello_macro_derive</code> function will be called when a user of our library\nspecifies <code>#[derive(HelloMacro)]</code> on a type. This is possible because we’ve\nannotated the <code>hello_macro_derive</code> function here with <code>proc_macro_derive</code> and\nspecified the name <code>HelloMacro</code>, which matches our trait name; this is the\nconvention most procedural macros follow.</p>\n<p dir=\"auto\">The <code>hello_macro_derive</code> function first converts the <code>input</code> from a\n<code>TokenStream</code> to a data structure that we can then interpret and perform\noperations on. This is where <code>syn</code> comes into play. The <code>parse</code> function in\n<code>syn</code> takes a <code>TokenStream</code> and returns a <code>DeriveInput</code> struct representing the\nparsed Rust code. Listing 19-32 shows the relevant parts of the <code>DeriveInput</code>\nstruct we get from parsing the <code>struct Pancakes;</code> string:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"DeriveInput {\n    // --snip--\n\n    ident: Ident {\n        ident: &quot;Pancakes&quot;,\n        span: #0 bytes(95..103)\n    },\n    data: Struct(\n        DataStruct {\n            struct_token: Struct,\n            fields: Unit,\n            semi_token: Some(\n                Semi\n            )\n        }\n    )\n}\"><pre><span class=\"pl-smi\">DeriveInput</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c\">// --snip--</span>\n\n    <span class=\"pl-c1\">ident</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">Ident</span> <span class=\"pl-kos\">{</span>\n        <span class=\"pl-c1\">ident</span><span class=\"pl-kos\">:</span> <span class=\"pl-s\">\"Pancakes\"</span><span class=\"pl-kos\">,</span>\n        <span class=\"pl-c1\">span</span><span class=\"pl-kos\">:</span> #<span class=\"pl-c1\">0</span> <span class=\"pl-en\">bytes</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">95</span>..<span class=\"pl-c1\">103</span><span class=\"pl-kos\">)</span>\n    <span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-c1\">data</span><span class=\"pl-kos\">:</span> <span class=\"pl-v\">Struct</span><span class=\"pl-kos\">(</span>\n        <span class=\"pl-smi\">DataStruct</span> <span class=\"pl-kos\">{</span>\n            <span class=\"pl-c1\">struct_token</span><span class=\"pl-kos\">:</span> <span class=\"pl-v\">Struct</span><span class=\"pl-kos\">,</span>\n            <span class=\"pl-c1\">fields</span><span class=\"pl-kos\">:</span> <span class=\"pl-v\">Unit</span><span class=\"pl-kos\">,</span>\n            <span class=\"pl-c1\">semi_token</span><span class=\"pl-kos\">:</span> <span class=\"pl-v\">Some</span><span class=\"pl-kos\">(</span>\n                <span class=\"pl-v\">Semi</span>\n            <span class=\"pl-kos\">)</span>\n        <span class=\"pl-kos\">}</span>\n    <span class=\"pl-kos\">)</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\"></span></pre></div>\n<p dir=\"auto\"><span>Listing 19-32: The <code>DeriveInput</code> instance we get when\nparsing the code that has the macro’s attribute in Listing 19-30</span></p>\n<p dir=\"auto\">The fields of this struct show that the Rust code we’ve parsed is a unit struct\nwith the <code>ident</code> (identifier, meaning the name) of <code>Pancakes</code>. There are more\nfields on this struct for describing all sorts of Rust code; check the <a href=\"https://docs.rs/syn/1.0/syn/struct.DeriveInput.html\" rel=\"nofollow\"><code>syn</code>\ndocumentation for <code>DeriveInput</code></a> for more information.</p>\n<p dir=\"auto\">Soon we’ll define the <code>impl_hello_macro</code> function, which is where we’ll build\nthe new Rust code we want to include. But before we do, note that the output\nfor our derive macro is also a <code>TokenStream</code>. The returned <code>TokenStream</code> is\nadded to the code that our crate users write, so when they compile their crate,\nthey’ll get the extra functionality that we provide in the modified\n<code>TokenStream</code>.</p>\n<p dir=\"auto\">You might have noticed that we’re calling <code>unwrap</code> to cause the\n<code>hello_macro_derive</code> function to panic if the call to the <code>syn::parse</code> function\nfails here. It’s necessary for our procedural macro to panic on errors because\n<code>proc_macro_derive</code> functions must return <code>TokenStream</code> rather than <code>Result</code> to\nconform to the procedural macro API. We’ve simplified this example by using\n<code>unwrap</code>; in production code, you should provide more specific error messages\nabout what went wrong by using <code>panic!</code> or <code>expect</code>.</p>\n<p dir=\"auto\">Now that we have the code to turn the annotated Rust code from a <code>TokenStream</code>\ninto a <code>DeriveInput</code> instance, let’s generate the code that implements the\n<code>HelloMacro</code> trait on the annotated type, as shown in Listing 19-33.</p>\n<p dir=\"auto\"><span>Filename: hello_macro_derive/src/lib.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-33/hello_macro/hello_macro_derive/src/lib.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">33</span>/hello_macro/hello_macro_derive/src/lib<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-33: Implementing the <code>HelloMacro</code> trait using\nthe parsed Rust code</span></p>\n<p dir=\"auto\">We get an <code>Ident</code> struct instance containing the name (identifier) of the\nannotated type using <code>ast.ident</code>. The struct in Listing 19-32 shows that when\nwe run the <code>impl_hello_macro</code> function on the code in Listing 19-30, the\n<code>ident</code> we get will have the <code>ident</code> field with a value of <code>\"Pancakes\"</code>. Thus,\nthe <code>name</code> variable in Listing 19-33 will contain an <code>Ident</code> struct instance\nthat, when printed, will be the string <code>\"Pancakes\"</code>, the name of the struct in\nListing 19-30.</p>\n<p dir=\"auto\">The <code>quote!</code> macro lets us define the Rust code that we want to return. The\ncompiler expects something different to the direct result of the <code>quote!</code>\nmacro’s execution, so we need to convert it to a <code>TokenStream</code>. We do this by\ncalling the <code>into</code> method, which consumes this intermediate representation and\nreturns a value of the required <code>TokenStream</code> type.</p>\n<p dir=\"auto\">The <code>quote!</code> macro also provides some very cool templating mechanics: we can\nenter <code>#name</code>, and <code>quote!</code> will replace it with the value in the variable\n<code>name</code>. You can even do some repetition similar to the way regular macros work.\nCheck out <a href=\"https://docs.rs/quote\" rel=\"nofollow\">the <code>quote</code> crate’s docs</a> for a thorough introduction.</p>\n<p dir=\"auto\">We want our procedural macro to generate an implementation of our <code>HelloMacro</code>\ntrait for the type the user annotated, which we can get by using <code>#name</code>. The\ntrait implementation has the one function <code>hello_macro</code>, whose body contains the\nfunctionality we want to provide: printing <code>Hello, Macro! My name is</code> and then\nthe name of the annotated type.</p>\n<p dir=\"auto\">The <code>stringify!</code> macro used here is built into Rust. It takes a Rust\nexpression, such as <code>1 + 2</code>, and at compile time turns the expression into a\nstring literal, such as <code>\"1 + 2\"</code>. This is different than <code>format!</code> or\n<code>println!</code>, macros which evaluate the expression and then turn the result into\na <code>String</code>. There is a possibility that the <code>#name</code> input might be an\nexpression to print literally, so we use <code>stringify!</code>. Using <code>stringify!</code> also\nsaves an allocation by converting <code>#name</code> to a string literal at compile time.</p>\n<p dir=\"auto\">At this point, <code>cargo build</code> should complete successfully in both <code>hello_macro</code>\nand <code>hello_macro_derive</code>. Let’s hook up these crates to the code in Listing\n19-30 to see the procedural macro in action! Create a new binary project in\nyour <em>projects</em> directory using <code>cargo new pancakes</code>. We need to add\n<code>hello_macro</code> and <code>hello_macro_derive</code> as dependencies in the <code>pancakes</code>\ncrate’s <em>Cargo.toml</em>. If you’re publishing your versions of <code>hello_macro</code> and\n<code>hello_macro_derive</code> to <a href=\"https://crates.io/\" rel=\"nofollow\">crates.io</a>, they would be regular\ndependencies; if not, you can specify them as <code>path</code> dependencies as follows:</p>\n<div class=\"highlight highlight-source-toml notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch19-advanced-features/no-listing-21-pancakes/pancakes/Cargo.toml:7:9}}\"><pre><span class=\"pl-ii\">{{#include ../listings/ch19-advanced-features/no-listing-21-pancakes/pancakes/Cargo.toml:7:9}}</span></pre></div>\n<p dir=\"auto\">Put the code in Listing 19-30 into <em>src/main.rs</em>, and run <code>cargo run</code>: it\nshould print <code>Hello, Macro! My name is Pancakes!</code> The implementation of the\n<code>HelloMacro</code> trait from the procedural macro was included without the\n<code>pancakes</code> crate needing to implement it; the <code>#[derive(HelloMacro)]</code> added the\ntrait implementation.</p>\n<p dir=\"auto\">Next, let’s explore how the other kinds of procedural macros differ from custom\nderive macros.</p>\n<h3 tabindex=\"-1\" id=\"user-content-attribute-like-macros\" dir=\"auto\"><a class=\"heading-link\" href=\"#attribute-like-macros\">Attribute-like macros<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">Attribute-like macros are similar to custom derive macros, but instead of\ngenerating code for the <code>derive</code> attribute, they allow you to create new\nattributes. They’re also more flexible: <code>derive</code> only works for structs and\nenums; attributes can be applied to other items as well, such as functions.\nHere’s an example of using an attribute-like macro: say you have an attribute\nnamed <code>route</code> that annotates functions when using a web application framework:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"#[route(GET, &quot;/&quot;)]\nfn index() {\"><pre><span class=\"pl-c1\">#<span class=\"pl-kos\">[</span>route<span class=\"pl-kos\">(</span><span class=\"pl-v\">GET</span>, <span class=\"pl-s\">\"/\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">]</span></span>\n<span class=\"pl-k\">fn</span> index<span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span></pre></div>\n<p dir=\"auto\">This <code>#[route]</code> attribute would be defined by the framework as a procedural\nmacro. The signature of the macro definition function would look like this:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"#[proc_macro_attribute]\npub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {\"><pre><span class=\"pl-c1\">#<span class=\"pl-kos\">[</span>proc_macro_attribute<span class=\"pl-kos\">]</span></span>\n<span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> route<span class=\"pl-kos\">(</span><span class=\"pl-s1\">attr</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">TokenStream</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">item</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">TokenStream</span><span class=\"pl-kos\">)</span> -&gt; <span class=\"pl-smi\">TokenStream</span> <span class=\"pl-kos\">{</span></pre></div>\n<p dir=\"auto\">Here, we have two parameters of type <code>TokenStream</code>. The first is for the\ncontents of the attribute: the <code>GET, \"/\"</code> part. The second is the body of the\nitem the attribute is attached to: in this case, <code>fn index() {}</code> and the rest\nof the function’s body.</p>\n<p dir=\"auto\">Other than that, attribute-like macros work the same way as custom derive\nmacros: you create a crate with the <code>proc-macro</code> crate type and implement a\nfunction that generates the code you want!</p>\n<h3 tabindex=\"-1\" id=\"user-content-function-like-macros\" dir=\"auto\"><a class=\"heading-link\" href=\"#function-like-macros\">Function-like macros<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">Function-like macros define macros that look like function calls. Similarly to\n<code>macro_rules!</code> macros, they’re more flexible than functions; for example, they\ncan take an unknown number of arguments. However, <code>macro_rules!</code> macros can be\ndefined only using the match-like syntax we discussed in the section\n<a href=\"#declarative-macros-with-macro_rules-for-general-metaprogramming\">“Declarative Macros with <code>macro_rules!</code> for General\nMetaprogramming”</a> earlier. Function-like macros take a\n<code>TokenStream</code> parameter and their definition manipulates that <code>TokenStream</code>\nusing Rust code as the other two types of procedural macros do. An example of a\nfunction-like macro is an <code>sql!</code> macro that might be called like so:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"let sql = sql!(SELECT * FROM posts WHERE id=1);\"><pre><span class=\"pl-k\">let</span> sql = <span class=\"pl-en\">sql</span><span class=\"pl-en\">!</span><span class=\"pl-kos\">(</span><span class=\"pl-v\">SELECT</span> * <span class=\"pl-v\">FROM</span> posts <span class=\"pl-v\">WHERE</span> id=<span class=\"pl-c1\">1</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">This macro would parse the SQL statement inside it and check that it’s\nsyntactically correct, which is much more complex processing than a\n<code>macro_rules!</code> macro can do. The <code>sql!</code> macro would be defined like this:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"#[proc_macro]\npub fn sql(input: TokenStream) -&gt; TokenStream {\"><pre><span class=\"pl-c1\">#<span class=\"pl-kos\">[</span>proc_macro<span class=\"pl-kos\">]</span></span>\n<span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> sql<span class=\"pl-kos\">(</span><span class=\"pl-s1\">input</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">TokenStream</span><span class=\"pl-kos\">)</span> -&gt; <span class=\"pl-smi\">TokenStream</span> <span class=\"pl-kos\">{</span></pre></div>\n<p dir=\"auto\">This definition is similar to the custom derive macro’s signature: we receive\nthe tokens that are inside the parentheses and return the code we wanted to\ngenerate.</p>\n<h2 tabindex=\"-1\" id=\"user-content-summary\" dir=\"auto\"><a class=\"heading-link\" href=\"#summary\">Summary<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">Whew! Now you have some Rust features in your toolbox that you likely won’t use\noften, but you’ll know they’re available in very particular circumstances.\nWe’ve introduced several complex topics so that when you encounter them in\nerror message suggestions or in other peoples’ code, you’ll be able to\nrecognize these concepts and syntax. Use this chapter as a reference to guide\nyou to solutions.</p>\n<p dir=\"auto\">Next, we’ll put everything we’ve discussed throughout the book into practice\nand do one more project!</p>\n</article>","renderedFileInfo":null,"shortPath":null,"tabSize":8,"topBannersInfo":{"overridingGlobalFundingFile":false,"globalPreferredFundingPath":null,"repoOwner":"rust-lang","repoName":"book","showInvalidCitationWarning":false,"citationHelpUrl":"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/about-citation-files","showDependabotConfigurationBanner":false,"actionsOnboardingTip":null},"truncated":false,"viewable":true,"workflowRedirectUrl":null,"symbols":{"timedOut":false,"notAnalyzed":true,"symbols":[]}},"copilotInfo":null,"csrf_tokens":{"/rust-lang/book/branches":{"post":"myMPWQU0JyIYqJq3W8zzwqZBDMUoYfnekivvjBGA4KXH5aiLGMfCtMeElh-6ent7hEEF5tY5BHuPyFiVPjMzvw"},"/repos/preferences":{"post":"iBFQeerspp6J2FFQ4nSgLARKR2tHIdEVxWwSgHGLIvnvDHkEk1QVbGBeA02ok_enZbmJNAoBtFsQZVZNaK8_kw"}}},"title":"book/src/ch19-06-macros.md at main · rust-lang/book"}
{"payload":{"allShortcutsEnabled":false,"fileTree":{"src":{"items":[{"name":"img","path":"src/img","contentType":"directory"},{"name":"SUMMARY.md","path":"src/SUMMARY.md","contentType":"file"},{"name":"appendix-00.md","path":"src/appendix-00.md","contentType":"file"},{"name":"appendix-01-keywords.md","path":"src/appendix-01-keywords.md","contentType":"file"},{"name":"appendix-02-operators.md","path":"src/appendix-02-operators.md","contentType":"file"},{"name":"appendix-03-derivable-traits.md","path":"src/appendix-03-derivable-traits.md","contentType":"file"},{"name":"appendix-04-useful-development-tools.md","path":"src/appendix-04-useful-development-tools.md","contentType":"file"},{"name":"appendix-05-editions.md","path":"src/appendix-05-editions.md","contentType":"file"},{"name":"appendix-06-translation.md","path":"src/appendix-06-translation.md","contentType":"file"},{"name":"appendix-07-nightly-rust.md","path":"src/appendix-07-nightly-rust.md","contentType":"file"},{"name":"ch00-00-introduction.md","path":"src/ch00-00-introduction.md","contentType":"file"},{"name":"ch01-00-getting-started.md","path":"src/ch01-00-getting-started.md","contentType":"file"},{"name":"ch01-01-installation.md","path":"src/ch01-01-installation.md","contentType":"file"},{"name":"ch01-02-hello-world.md","path":"src/ch01-02-hello-world.md","contentType":"file"},{"name":"ch01-03-hello-cargo.md","path":"src/ch01-03-hello-cargo.md","contentType":"file"},{"name":"ch02-00-guessing-game-tutorial.md","path":"src/ch02-00-guessing-game-tutorial.md","contentType":"file"},{"name":"ch03-00-common-programming-concepts.md","path":"src/ch03-00-common-programming-concepts.md","contentType":"file"},{"name":"ch03-01-variables-and-mutability.md","path":"src/ch03-01-variables-and-mutability.md","contentType":"file"},{"name":"ch03-02-data-types.md","path":"src/ch03-02-data-types.md","contentType":"file"},{"name":"ch03-03-how-functions-work.md","path":"src/ch03-03-how-functions-work.md","contentType":"file"},{"name":"ch03-04-comments.md","path":"src/ch03-04-comments.md","contentType":"file"},{"name":"ch03-05-control-flow.md","path":"src/ch03-05-control-flow.md","contentType":"file"},{"name":"ch04-00-understanding-ownership.md","path":"src/ch04-00-understanding-ownership.md","contentType":"file"},{"name":"ch04-01-what-is-ownership.md","path":"src/ch04-01-what-is-ownership.md","contentType":"file"},{"name":"ch04-02-references-and-borrowing.md","path":"src/ch04-02-references-and-borrowing.md","contentType":"file"},{"name":"ch04-03-slices.md","path":"src/ch04-03-slices.md","contentType":"file"},{"name":"ch05-00-structs.md","path":"src/ch05-00-structs.md","contentType":"file"},{"name":"ch05-01-defining-structs.md","path":"src/ch05-01-defining-structs.md","contentType":"file"},{"name":"ch05-02-example-structs.md","path":"src/ch05-02-example-structs.md","contentType":"file"},{"name":"ch05-03-method-syntax.md","path":"src/ch05-03-method-syntax.md","contentType":"file"},{"name":"ch06-00-enums.md","path":"src/ch06-00-enums.md","contentType":"file"},{"name":"ch06-01-defining-an-enum.md","path":"src/ch06-01-defining-an-enum.md","contentType":"file"},{"name":"ch06-02-match.md","path":"src/ch06-02-match.md","contentType":"file"},{"name":"ch06-03-if-let.md","path":"src/ch06-03-if-let.md","contentType":"file"},{"name":"ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","path":"src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","contentType":"file"},{"name":"ch07-01-packages-and-crates.md","path":"src/ch07-01-packages-and-crates.md","contentType":"file"},{"name":"ch07-02-defining-modules-to-control-scope-and-privacy.md","path":"src/ch07-02-defining-modules-to-control-scope-and-privacy.md","contentType":"file"},{"name":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","path":"src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","contentType":"file"},{"name":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","path":"src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","contentType":"file"},{"name":"ch07-05-separating-modules-into-different-files.md","path":"src/ch07-05-separating-modules-into-different-files.md","contentType":"file"},{"name":"ch08-00-common-collections.md","path":"src/ch08-00-common-collections.md","contentType":"file"},{"name":"ch08-01-vectors.md","path":"src/ch08-01-vectors.md","contentType":"file"},{"name":"ch08-02-strings.md","path":"src/ch08-02-strings.md","contentType":"file"},{"name":"ch08-03-hash-maps.md","path":"src/ch08-03-hash-maps.md","contentType":"file"},{"name":"ch09-00-error-handling.md","path":"src/ch09-00-error-handling.md","contentType":"file"},{"name":"ch09-01-unrecoverable-errors-with-panic.md","path":"src/ch09-01-unrecoverable-errors-with-panic.md","contentType":"file"},{"name":"ch09-02-recoverable-errors-with-result.md","path":"src/ch09-02-recoverable-errors-with-result.md","contentType":"file"},{"name":"ch09-03-to-panic-or-not-to-panic.md","path":"src/ch09-03-to-panic-or-not-to-panic.md","contentType":"file"},{"name":"ch10-00-generics.md","path":"src/ch10-00-generics.md","contentType":"file"},{"name":"ch10-01-syntax.md","path":"src/ch10-01-syntax.md","contentType":"file"},{"name":"ch10-02-traits.md","path":"src/ch10-02-traits.md","contentType":"file"},{"name":"ch10-03-lifetime-syntax.md","path":"src/ch10-03-lifetime-syntax.md","contentType":"file"},{"name":"ch11-00-testing.md","path":"src/ch11-00-testing.md","contentType":"file"},{"name":"ch11-01-writing-tests.md","path":"src/ch11-01-writing-tests.md","contentType":"file"},{"name":"ch11-02-running-tests.md","path":"src/ch11-02-running-tests.md","contentType":"file"},{"name":"ch11-03-test-organization.md","path":"src/ch11-03-test-organization.md","contentType":"file"},{"name":"ch12-00-an-io-project.md","path":"src/ch12-00-an-io-project.md","contentType":"file"},{"name":"ch12-01-accepting-command-line-arguments.md","path":"src/ch12-01-accepting-command-line-arguments.md","contentType":"file"},{"name":"ch12-02-reading-a-file.md","path":"src/ch12-02-reading-a-file.md","contentType":"file"},{"name":"ch12-03-improving-error-handling-and-modularity.md","path":"src/ch12-03-improving-error-handling-and-modularity.md","contentType":"file"},{"name":"ch12-04-testing-the-librarys-functionality.md","path":"src/ch12-04-testing-the-librarys-functionality.md","contentType":"file"},{"name":"ch12-05-working-with-environment-variables.md","path":"src/ch12-05-working-with-environment-variables.md","contentType":"file"},{"name":"ch12-06-writing-to-stderr-instead-of-stdout.md","path":"src/ch12-06-writing-to-stderr-instead-of-stdout.md","contentType":"file"},{"name":"ch13-00-functional-features.md","path":"src/ch13-00-functional-features.md","contentType":"file"},{"name":"ch13-01-closures.md","path":"src/ch13-01-closures.md","contentType":"file"},{"name":"ch13-02-iterators.md","path":"src/ch13-02-iterators.md","contentType":"file"},{"name":"ch13-03-improving-our-io-project.md","path":"src/ch13-03-improving-our-io-project.md","contentType":"file"},{"name":"ch13-04-performance.md","path":"src/ch13-04-performance.md","contentType":"file"},{"name":"ch14-00-more-about-cargo.md","path":"src/ch14-00-more-about-cargo.md","contentType":"file"},{"name":"ch14-01-release-profiles.md","path":"src/ch14-01-release-profiles.md","contentType":"file"},{"name":"ch14-02-publishing-to-crates-io.md","path":"src/ch14-02-publishing-to-crates-io.md","contentType":"file"},{"name":"ch14-03-cargo-workspaces.md","path":"src/ch14-03-cargo-workspaces.md","contentType":"file"},{"name":"ch14-04-installing-binaries.md","path":"src/ch14-04-installing-binaries.md","contentType":"file"},{"name":"ch14-05-extending-cargo.md","path":"src/ch14-05-extending-cargo.md","contentType":"file"},{"name":"ch15-00-smart-pointers.md","path":"src/ch15-00-smart-pointers.md","contentType":"file"},{"name":"ch15-01-box.md","path":"src/ch15-01-box.md","contentType":"file"},{"name":"ch15-02-deref.md","path":"src/ch15-02-deref.md","contentType":"file"},{"name":"ch15-03-drop.md","path":"src/ch15-03-drop.md","contentType":"file"},{"name":"ch15-04-rc.md","path":"src/ch15-04-rc.md","contentType":"file"},{"name":"ch15-05-interior-mutability.md","path":"src/ch15-05-interior-mutability.md","contentType":"file"},{"name":"ch15-06-reference-cycles.md","path":"src/ch15-06-reference-cycles.md","contentType":"file"},{"name":"ch16-00-concurrency.md","path":"src/ch16-00-concurrency.md","contentType":"file"},{"name":"ch16-01-threads.md","path":"src/ch16-01-threads.md","contentType":"file"},{"name":"ch16-02-message-passing.md","path":"src/ch16-02-message-passing.md","contentType":"file"},{"name":"ch16-03-shared-state.md","path":"src/ch16-03-shared-state.md","contentType":"file"},{"name":"ch16-04-extensible-concurrency-sync-and-send.md","path":"src/ch16-04-extensible-concurrency-sync-and-send.md","contentType":"file"},{"name":"ch17-00-oop.md","path":"src/ch17-00-oop.md","contentType":"file"},{"name":"ch17-01-what-is-oo.md","path":"src/ch17-01-what-is-oo.md","contentType":"file"},{"name":"ch17-02-trait-objects.md","path":"src/ch17-02-trait-objects.md","contentType":"file"},{"name":"ch17-03-oo-design-patterns.md","path":"src/ch17-03-oo-design-patterns.md","contentType":"file"},{"name":"ch18-00-patterns.md","path":"src/ch18-00-patterns.md","contentType":"file"},{"name":"ch18-01-all-the-places-for-patterns.md","path":"src/ch18-01-all-the-places-for-patterns.md","contentType":"file"},{"name":"ch18-02-refutability.md","path":"src/ch18-02-refutability.md","contentType":"file"},{"name":"ch18-03-pattern-syntax.md","path":"src/ch18-03-pattern-syntax.md","contentType":"file"},{"name":"ch19-00-advanced-features.md","path":"src/ch19-00-advanced-features.md","contentType":"file"},{"name":"ch19-01-unsafe-rust.md","path":"src/ch19-01-unsafe-rust.md","contentType":"file"},{"name":"ch19-03-advanced-traits.md","path":"src/ch19-03-advanced-traits.md","contentType":"file"},{"name":"ch19-04-advanced-types.md","path":"src/ch19-04-advanced-types.md","contentType":"file"},{"name":"ch19-05-advanced-functions-and-closures.md","path":"src/ch19-05-advanced-functions-and-closures.md","contentType":"file"},{"name":"ch19-06-macros.md","path":"src/ch19-06-macros.md","contentType":"file"},{"name":"ch20-00-final-project-a-web-server.md","path":"src/ch20-00-final-project-a-web-server.md","contentType":"file"},{"name":"ch20-01-single-threaded.md","path":"src/ch20-01-single-threaded.md","contentType":"file"},{"name":"ch20-02-multithreaded.md","path":"src/ch20-02-multithreaded.md","contentType":"file"},{"name":"ch20-03-graceful-shutdown-and-cleanup.md","path":"src/ch20-03-graceful-shutdown-and-cleanup.md","contentType":"file"},{"name":"foreword.md","path":"src/foreword.md","contentType":"file"},{"name":"title-page.md","path":"src/title-page.md","contentType":"file"}],"totalCount":106},"":{"items":[{"name":".cargo","path":".cargo","contentType":"directory"},{"name":".github","path":".github","contentType":"directory"},{"name":"2018-edition","path":"2018-edition","contentType":"directory"},{"name":"ci","path":"ci","contentType":"directory"},{"name":"dot","path":"dot","contentType":"directory"},{"name":"first-edition","path":"first-edition","contentType":"directory"},{"name":"listings","path":"listings","contentType":"directory"},{"name":"nostarch","path":"nostarch","contentType":"directory"},{"name":"redirects","path":"redirects","contentType":"directory"},{"name":"second-edition","path":"second-edition","contentType":"directory"},{"name":"src","path":"src","contentType":"directory"},{"name":"theme","path":"theme","contentType":"directory"},{"name":"tools","path":"tools","contentType":"directory"},{"name":".gitattributes","path":".gitattributes","contentType":"file"},{"name":".gitignore","path":".gitignore","contentType":"file"},{"name":"ADMIN_TASKS.md","path":"ADMIN_TASKS.md","contentType":"file"},{"name":"CONTRIBUTING.md","path":"CONTRIBUTING.md","contentType":"file"},{"name":"COPYRIGHT","path":"COPYRIGHT","contentType":"file"},{"name":"Cargo.lock","path":"Cargo.lock","contentType":"file"},{"name":"Cargo.toml","path":"Cargo.toml","contentType":"file"},{"name":"LICENSE-APACHE","path":"LICENSE-APACHE","contentType":"file"},{"name":"LICENSE-MIT","path":"LICENSE-MIT","contentType":"file"},{"name":"README.md","path":"README.md","contentType":"file"},{"name":"TODO.md","path":"TODO.md","contentType":"file"},{"name":"book.toml","path":"book.toml","contentType":"file"},{"name":"ferris.css","path":"ferris.css","contentType":"file"},{"name":"ferris.js","path":"ferris.js","contentType":"file"},{"name":"rust-toolchain","path":"rust-toolchain","contentType":"file"},{"name":"rustfmt.toml","path":"rustfmt.toml","contentType":"file"},{"name":"style-guide.md","path":"style-guide.md","contentType":"file"}],"totalCount":30}},"fileTreeProcessingTime":17.477501999999998,"foldersToFetch":[],"reducedMotionEnabled":null,"repo":{"id":47854924,"defaultBranch":"main","name":"book","ownerLogin":"rust-lang","currentUserCanPush":false,"isFork":false,"isEmpty":false,"createdAt":"2015-12-11T22:49:49.000Z","ownerAvatar":"https://avatars.githubusercontent.com/u/5430905?v=4","public":true,"private":false,"isOrgOwned":true},"symbolsExpanded":false,"treeExpanded":true,"refInfo":{"name":"main","listCacheKey":"v0:1688046669.0","canEdit":false,"refType":"branch","currentOid":"72187f5cd0beaaa9c6f584156bcd88f921871e83"},"path":"src/ch19-01-unsafe-rust.md","currentUser":null,"blob":{"rawLines":null,"stylingDirectives":null,"csv":null,"csvError":null,"dependabotInfo":{"showConfigurationBanner":false,"configFilePath":null,"networkDependabotPath":"/rust-lang/book/network/updates","dismissConfigurationNoticePath":"/settings/dismiss-notice/dependabot_configuration_notice","configurationNoticeDismissed":null,"repoAlertsPath":"/rust-lang/book/security/dependabot","repoSecurityAndAnalysisPath":"/rust-lang/book/settings/security_analysis","repoOwnerIsOrg":true,"currentUserCanAdminRepo":false},"displayName":"ch19-01-unsafe-rust.md","displayUrl":"https://github.com/rust-lang/book/blob/main/src/ch19-01-unsafe-rust.md?raw=true","headerInfo":{"blobSize":"22 KB","deleteInfo":{"deleteTooltip":"You must be signed in to make or propose changes"},"editInfo":{"editTooltip":"You must be signed in to make or propose changes"},"ghDesktopPath":"https://desktop.github.com","gitLfsPath":null,"onBranch":true,"shortPath":"6ff229d","siteNavLoginPath":"/login?return_to=https%3A%2F%2Fgithub.com%2Frust-lang%2Fbook%2Fblob%2Fmain%2Fsrc%2Fch19-01-unsafe-rust.md","isCSV":false,"isRichtext":true,"toc":[{"level":2,"text":"Unsafe Rust","anchor":"unsafe-rust","htmlText":"Unsafe Rust"},{"level":3,"text":"Unsafe Superpowers","anchor":"unsafe-superpowers","htmlText":"Unsafe Superpowers"},{"level":3,"text":"Dereferencing a Raw Pointer","anchor":"dereferencing-a-raw-pointer","htmlText":"Dereferencing a Raw Pointer"},{"level":3,"text":"Calling an Unsafe Function or Method","anchor":"calling-an-unsafe-function-or-method","htmlText":"Calling an Unsafe Function or Method"},{"level":4,"text":"Creating a Safe Abstraction over Unsafe Code","anchor":"creating-a-safe-abstraction-over-unsafe-code","htmlText":"Creating a Safe Abstraction over Unsafe Code"},{"level":4,"text":"Using extern Functions to Call External Code","anchor":"using-extern-functions-to-call-external-code","htmlText":"Using extern Functions to Call External Code"},{"level":4,"text":"Calling Rust Functions from Other Languages","anchor":"calling-rust-functions-from-other-languages","htmlText":"Calling Rust Functions from Other Languages"},{"level":3,"text":"Accessing or Modifying a Mutable Static Variable","anchor":"accessing-or-modifying-a-mutable-static-variable","htmlText":"Accessing or Modifying a Mutable Static Variable"},{"level":3,"text":"Implementing an Unsafe Trait","anchor":"implementing-an-unsafe-trait","htmlText":"Implementing an Unsafe Trait"},{"level":3,"text":"Accessing Fields of a Union","anchor":"accessing-fields-of-a-union","htmlText":"Accessing Fields of a Union"},{"level":3,"text":"When to Use Unsafe Code","anchor":"when-to-use-unsafe-code","htmlText":"When to Use Unsafe Code"}],"lineInfo":{"truncatedLoc":"460","truncatedSloc":"367"},"mode":"file"},"image":false,"isCodeownersFile":null,"isPlain":false,"isValidLegacyIssueTemplate":false,"issueTemplateHelpUrl":"https://docs.github.com/articles/about-issue-and-pull-request-templates","issueTemplate":null,"discussionTemplate":null,"language":"Markdown","languageID":222,"large":false,"loggedIn":false,"newDiscussionPath":"/rust-lang/book/discussions/new","newIssuePath":"/rust-lang/book/issues/new","planSupportInfo":{"repoIsFork":null,"repoOwnedByCurrentUser":null,"requestFullPath":"/rust-lang/book/blob/main/src/ch19-01-unsafe-rust.md","showFreeOrgGatedFeatureMessage":null,"showPlanSupportBanner":null,"upgradeDataAttributes":null,"upgradePath":null},"publishBannersInfo":{"dismissActionNoticePath":"/settings/dismiss-notice/publish_action_from_dockerfile","dismissStackNoticePath":"/settings/dismiss-notice/publish_stack_from_file","releasePath":"/rust-lang/book/releases/new?marketplace=true","showPublishActionBanner":false,"showPublishStackBanner":false},"renderImageOrRaw":false,"richText":"<article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><h2 tabindex=\"-1\" id=\"user-content-unsafe-rust\" dir=\"auto\"><a class=\"heading-link\" href=\"#unsafe-rust\">Unsafe Rust<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">All the code we’ve discussed so far has had Rust’s memory safety guarantees\nenforced at compile time. However, Rust has a second language hidden inside it\nthat doesn’t enforce these memory safety guarantees: it’s called <em>unsafe Rust</em>\nand works just like regular Rust, but gives us extra superpowers.</p>\n<p dir=\"auto\">Unsafe Rust exists because, by nature, static analysis is conservative. When\nthe compiler tries to determine whether or not code upholds the guarantees,\nit’s better for it to reject some valid programs than to accept some invalid\nprograms. Although the code <em>might</em> be okay, if the Rust compiler doesn’t have\nenough information to be confident, it will reject the code. In these cases,\nyou can use unsafe code to tell the compiler, “Trust me, I know what I’m\ndoing.” Be warned, however, that you use unsafe Rust at your own risk: if you\nuse unsafe code incorrectly, problems can occur due to memory unsafety, such as\nnull pointer dereferencing.</p>\n<p dir=\"auto\">Another reason Rust has an unsafe alter ego is that the underlying computer\nhardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you\ncouldn’t do certain tasks. Rust needs to allow you to do low-level systems\nprogramming, such as directly interacting with the operating system or even\nwriting your own operating system. Working with low-level systems programming\nis one of the goals of the language. Let’s explore what we can do with unsafe\nRust and how to do it.</p>\n<h3 tabindex=\"-1\" id=\"user-content-unsafe-superpowers\" dir=\"auto\"><a class=\"heading-link\" href=\"#unsafe-superpowers\">Unsafe Superpowers<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">To switch to unsafe Rust, use the <code>unsafe</code> keyword and then start a new block\nthat holds the unsafe code. You can take five actions in unsafe Rust that you\ncan’t in safe Rust, which we call <em>unsafe superpowers</em>. Those superpowers\ninclude the ability to:</p>\n<ul dir=\"auto\">\n<li>Dereference a raw pointer</li>\n<li>Call an unsafe function or method</li>\n<li>Access or modify a mutable static variable</li>\n<li>Implement an unsafe trait</li>\n<li>Access fields of <code>union</code>s</li>\n</ul>\n<p dir=\"auto\">It’s important to understand that <code>unsafe</code> doesn’t turn off the borrow checker\nor disable any other of Rust’s safety checks: if you use a reference in unsafe\ncode, it will still be checked. The <code>unsafe</code> keyword only gives you access to\nthese five features that are then not checked by the compiler for memory\nsafety. You’ll still get some degree of safety inside of an unsafe block.</p>\n<p dir=\"auto\">In addition, <code>unsafe</code> does not mean the code inside the block is necessarily\ndangerous or that it will definitely have memory safety problems: the intent is\nthat as the programmer, you’ll ensure the code inside an <code>unsafe</code> block will\naccess memory in a valid way.</p>\n<p dir=\"auto\">People are fallible, and mistakes will happen, but by requiring these five\nunsafe operations to be inside blocks annotated with <code>unsafe</code> you’ll know that\nany errors related to memory safety must be within an <code>unsafe</code> block. Keep\n<code>unsafe</code> blocks small; you’ll be thankful later when you investigate memory\nbugs.</p>\n<p dir=\"auto\">To isolate unsafe code as much as possible, it’s best to enclose unsafe code\nwithin a safe abstraction and provide a safe API, which we’ll discuss later in\nthe chapter when we examine unsafe functions and methods. Parts of the standard\nlibrary are implemented as safe abstractions over unsafe code that has been\naudited. Wrapping unsafe code in a safe abstraction prevents uses of <code>unsafe</code>\nfrom leaking out into all the places that you or your users might want to use\nthe functionality implemented with <code>unsafe</code> code, because using a safe\nabstraction is safe.</p>\n<p dir=\"auto\">Let’s look at each of the five unsafe superpowers in turn. We’ll also look at\nsome abstractions that provide a safe interface to unsafe code.</p>\n<h3 tabindex=\"-1\" id=\"user-content-dereferencing-a-raw-pointer\" dir=\"auto\"><a class=\"heading-link\" href=\"#dereferencing-a-raw-pointer\">Dereferencing a Raw Pointer<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">In Chapter 4, in the <a href=\"/rust-lang/book/blob/main/src/ch04-02-references-and-borrowing.html#dangling-references\">“Dangling References”</a> section, we mentioned that the compiler ensures references are always\nvalid. Unsafe Rust has two new types called <em>raw pointers</em> that are similar to\nreferences. As with references, raw pointers can be immutable or mutable and\nare written as <code>*const T</code> and <code>*mut T</code>, respectively. The asterisk isn’t the\ndereference operator; it’s part of the type name. In the context of raw\npointers, <em>immutable</em> means that the pointer can’t be directly assigned to\nafter being dereferenced.</p>\n<p dir=\"auto\">Different from references and smart pointers, raw pointers:</p>\n<ul dir=\"auto\">\n<li>Are allowed to ignore the borrowing rules by having both immutable and\nmutable pointers or multiple mutable pointers to the same location</li>\n<li>Aren’t guaranteed to point to valid memory</li>\n<li>Are allowed to be null</li>\n<li>Don’t implement any automatic cleanup</li>\n</ul>\n<p dir=\"auto\">By opting out of having Rust enforce these guarantees, you can give up\nguaranteed safety in exchange for greater performance or the ability to\ninterface with another language or hardware where Rust’s guarantees don’t apply.</p>\n<p dir=\"auto\">Listing 19-1 shows how to create an immutable and a mutable raw pointer from\nreferences.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-01/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">01</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-1: Creating raw pointers from references</span></p>\n<p dir=\"auto\">Notice that we don’t include the <code>unsafe</code> keyword in this code. We can create\nraw pointers in safe code; we just can’t dereference raw pointers outside an\nunsafe block, as you’ll see in a bit.</p>\n<p dir=\"auto\">We’ve created raw pointers by using <code>as</code> to cast an immutable and a mutable\nreference into their corresponding raw pointer types. Because we created them\ndirectly from references guaranteed to be valid, we know these particular raw\npointers are valid, but we can’t make that assumption about just any raw\npointer.</p>\n<p dir=\"auto\">To demonstrate this, next we’ll create a raw pointer whose validity we can’t be\nso certain of. Listing 19-2 shows how to create a raw pointer to an arbitrary\nlocation in memory. Trying to use arbitrary memory is undefined: there might be\ndata at that address or there might not, the compiler might optimize the code\nso there is no memory access, or the program might error with a segmentation\nfault. Usually, there is no good reason to write code like this, but it is\npossible.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-02/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">02</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-2: Creating a raw pointer to an arbitrary\nmemory address</span></p>\n<p dir=\"auto\">Recall that we can create raw pointers in safe code, but we can’t <em>dereference</em>\nraw pointers and read the data being pointed to. In Listing 19-3, we use the\ndereference operator <code>*</code> on a raw pointer that requires an <code>unsafe</code> block.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-03/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">03</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-3: Dereferencing raw pointers within an\n<code>unsafe</code> block</span></p>\n<p dir=\"auto\">Creating a pointer does no harm; it’s only when we try to access the value that\nit points at that we might end up dealing with an invalid value.</p>\n<p dir=\"auto\">Note also that in Listing 19-1 and 19-3, we created <code>*const i32</code> and <code>*mut i32</code>\nraw pointers that both pointed to the same memory location, where <code>num</code> is\nstored. If we instead tried to create an immutable and a mutable reference to\n<code>num</code>, the code would not have compiled because Rust’s ownership rules don’t\nallow a mutable reference at the same time as any immutable references. With\nraw pointers, we can create a mutable pointer and an immutable pointer to the\nsame location and change data through the mutable pointer, potentially creating\na data race. Be careful!</p>\n<p dir=\"auto\">With all of these dangers, why would you ever use raw pointers? One major use\ncase is when interfacing with C code, as you’ll see in the next section,\n<a href=\"#calling-an-unsafe-function-or-method\">“Calling an Unsafe Function or\nMethod.”</a> Another case is\nwhen building up safe abstractions that the borrow checker doesn’t understand.\nWe’ll introduce unsafe functions and then look at an example of a safe\nabstraction that uses unsafe code.</p>\n<h3 tabindex=\"-1\" id=\"user-content-calling-an-unsafe-function-or-method\" dir=\"auto\"><a class=\"heading-link\" href=\"#calling-an-unsafe-function-or-method\">Calling an Unsafe Function or Method<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">The second type of operation you can perform in an unsafe block is calling\nunsafe functions. Unsafe functions and methods look exactly like regular\nfunctions and methods, but they have an extra <code>unsafe</code> before the rest of the\ndefinition. The <code>unsafe</code> keyword in this context indicates the function has\nrequirements we need to uphold when we call this function, because Rust can’t\nguarantee we’ve met these requirements. By calling an unsafe function within an\n<code>unsafe</code> block, we’re saying that we’ve read this function’s documentation and\ntake responsibility for upholding the function’s contracts.</p>\n<p dir=\"auto\">Here is an unsafe function named <code>dangerous</code> that doesn’t do anything in its\nbody:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-01-unsafe-fn/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/no-listing-<span class=\"pl-c1\">01</span>-<span class=\"pl-k\">unsafe</span>-fn/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">We must call the <code>dangerous</code> function within a separate <code>unsafe</code> block. If we\ntry to call <code>dangerous</code> without the <code>unsafe</code> block, we’ll get an error:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch19-advanced-features/output-only-01-missing-unsafe/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch19-advanced-features/output-only-01-missing-unsafe/output.txt}}</span></pre></div>\n<p dir=\"auto\">With the <code>unsafe</code> block, we’re asserting to Rust that we’ve read the function’s\ndocumentation, we understand how to use it properly, and we’ve verified that\nwe’re fulfilling the contract of the function.</p>\n<p dir=\"auto\">Bodies of unsafe functions are effectively <code>unsafe</code> blocks, so to perform other\nunsafe operations within an unsafe function, we don’t need to add another\n<code>unsafe</code> block.</p>\n<h4 tabindex=\"-1\" id=\"user-content-creating-a-safe-abstraction-over-unsafe-code\" dir=\"auto\"><a class=\"heading-link\" href=\"#creating-a-safe-abstraction-over-unsafe-code\">Creating a Safe Abstraction over Unsafe Code<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">Just because a function contains unsafe code doesn’t mean we need to mark the\nentire function as unsafe. In fact, wrapping unsafe code in a safe function is\na common abstraction. As an example, let’s study the <code>split_at_mut</code> function\nfrom the standard library, which requires some unsafe code. We’ll explore how\nwe might implement it. This safe method is defined on mutable slices: it takes\none slice and makes it two by splitting the slice at the index given as an\nargument. Listing 19-4 shows how to use <code>split_at_mut</code>.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-04/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">04</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-4: Using the safe <code>split_at_mut</code>\nfunction</span></p>\n<p dir=\"auto\">We can’t implement this function using only safe Rust. An attempt might look\nsomething like Listing 19-5, which won’t compile. For simplicity, we’ll\nimplement <code>split_at_mut</code> as a function rather than a method and only for slices\nof <code>i32</code> values rather than for a generic type <code>T</code>.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-05/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">05</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-5: An attempted implementation of\n<code>split_at_mut</code> using only safe Rust</span></p>\n<p dir=\"auto\">This function first gets the total length of the slice. Then it asserts that\nthe index given as a parameter is within the slice by checking whether it’s\nless than or equal to the length. The assertion means that if we pass an index\nthat is greater than the length to split the slice at, the function will panic\nbefore it attempts to use that index.</p>\n<p dir=\"auto\">Then we return two mutable slices in a tuple: one from the start of the\noriginal slice to the <code>mid</code> index and another from <code>mid</code> to the end of the\nslice.</p>\n<p dir=\"auto\">When we try to compile the code in Listing 19-5, we’ll get an error.</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch19-advanced-features/listing-19-05/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch19-advanced-features/listing-19-05/output.txt}}</span></pre></div>\n<p dir=\"auto\">Rust’s borrow checker can’t understand that we’re borrowing different parts of\nthe slice; it only knows that we’re borrowing from the same slice twice.\nBorrowing different parts of a slice is fundamentally okay because the two\nslices aren’t overlapping, but Rust isn’t smart enough to know this. When we\nknow code is okay, but Rust doesn’t, it’s time to reach for unsafe code.</p>\n<p dir=\"auto\">Listing 19-6 shows how to use an <code>unsafe</code> block, a raw pointer, and some calls\nto unsafe functions to make the implementation of <code>split_at_mut</code> work.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-06/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">06</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-6: Using unsafe code in the implementation of\nthe <code>split_at_mut</code> function</span></p>\n<p dir=\"auto\">Recall from <a href=\"/rust-lang/book/blob/main/src/ch04-03-slices.html#the-slice-type\">“The Slice Type”</a> section in\nChapter 4 that slices are a pointer to some data and the length of the slice.\nWe use the <code>len</code> method to get the length of a slice and the <code>as_mut_ptr</code>\nmethod to access the raw pointer of a slice. In this case, because we have a\nmutable slice to <code>i32</code> values, <code>as_mut_ptr</code> returns a raw pointer with the type\n<code>*mut i32</code>, which we’ve stored in the variable <code>ptr</code>.</p>\n<p dir=\"auto\">We keep the assertion that the <code>mid</code> index is within the slice. Then we get to\nthe unsafe code: the <code>slice::from_raw_parts_mut</code> function takes a raw pointer\nand a length, and it creates a slice. We use this function to create a slice\nthat starts from <code>ptr</code> and is <code>mid</code> items long. Then we call the <code>add</code>\nmethod on <code>ptr</code> with <code>mid</code> as an argument to get a raw pointer that starts at\n<code>mid</code>, and we create a slice using that pointer and the remaining number of\nitems after <code>mid</code> as the length.</p>\n<p dir=\"auto\">The function <code>slice::from_raw_parts_mut</code> is unsafe because it takes a raw\npointer and must trust that this pointer is valid. The <code>add</code> method on raw\npointers is also unsafe, because it must trust that the offset location is also\na valid pointer. Therefore, we had to put an <code>unsafe</code> block around our calls to\n<code>slice::from_raw_parts_mut</code> and <code>add</code> so we could call them. By looking at\nthe code and by adding the assertion that <code>mid</code> must be less than or equal to\n<code>len</code>, we can tell that all the raw pointers used within the <code>unsafe</code> block\nwill be valid pointers to data within the slice. This is an acceptable and\nappropriate use of <code>unsafe</code>.</p>\n<p dir=\"auto\">Note that we don’t need to mark the resulting <code>split_at_mut</code> function as\n<code>unsafe</code>, and we can call this function from safe Rust. We’ve created a safe\nabstraction to the unsafe code with an implementation of the function that uses\n<code>unsafe</code> code in a safe way, because it creates only valid pointers from the\ndata this function has access to.</p>\n<p dir=\"auto\">In contrast, the use of <code>slice::from_raw_parts_mut</code> in Listing 19-7 would\nlikely crash when the slice is used. This code takes an arbitrary memory\nlocation and creates a slice 10,000 items long.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-07/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">07</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-7: Creating a slice from an arbitrary memory\nlocation</span></p>\n<p dir=\"auto\">We don’t own the memory at this arbitrary location, and there is no guarantee\nthat the slice this code creates contains valid <code>i32</code> values. Attempting to use\n<code>values</code> as though it’s a valid slice results in undefined behavior.</p>\n<h4 tabindex=\"-1\" id=\"user-content-using-extern-functions-to-call-external-code\" dir=\"auto\"><a class=\"heading-link\" href=\"#using-extern-functions-to-call-external-code\">Using <code>extern</code> Functions to Call External Code<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">Sometimes, your Rust code might need to interact with code written in another\nlanguage. For this, Rust has the keyword <code>extern</code> that facilitates the creation\nand use of a <em>Foreign Function Interface (FFI)</em>. An FFI is a way for a\nprogramming language to define functions and enable a different (foreign)\nprogramming language to call those functions.</p>\n<p dir=\"auto\">Listing 19-8 demonstrates how to set up an integration with the <code>abs</code> function\nfrom the C standard library. Functions declared within <code>extern</code> blocks are\nalways unsafe to call from Rust code. The reason is that other languages don’t\nenforce Rust’s rules and guarantees, and Rust can’t check them, so\nresponsibility falls on the programmer to ensure safety.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-08/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">08</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-8: Declaring and calling an <code>extern</code> function\ndefined in another language</span></p>\n<p dir=\"auto\">Within the <code>extern \"C\"</code> block, we list the names and signatures of external\nfunctions from another language we want to call. The <code>\"C\"</code> part defines which\n<em>application binary interface (ABI)</em> the external function uses: the ABI\ndefines how to call the function at the assembly level. The <code>\"C\"</code> ABI is the\nmost common and follows the C programming language’s ABI.</p>\n<blockquote>\n<h4 tabindex=\"-1\" id=\"user-content-calling-rust-functions-from-other-languages\" dir=\"auto\"><a class=\"heading-link\" href=\"#calling-rust-functions-from-other-languages\">Calling Rust Functions from Other Languages<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">We can also use <code>extern</code> to create an interface that allows other languages\nto call Rust functions. Instead of creating a whole <code>extern</code> block, we add\nthe <code>extern</code> keyword and specify the ABI to use just before the <code>fn</code> keyword\nfor the relevant function. We also need to add a <code>#[no_mangle]</code> annotation to\ntell the Rust compiler not to mangle the name of this function. <em>Mangling</em> is\nwhen a compiler changes the name we’ve given a function to a different name\nthat contains more information for other parts of the compilation process to\nconsume but is less human readable. Every programming language compiler\nmangles names slightly differently, so for a Rust function to be nameable by\nother languages, we must disable the Rust compiler’s name mangling.</p>\n<p dir=\"auto\">In the following example, we make the <code>call_from_c</code> function accessible from\nC code, after it’s compiled to a shared library and linked from C:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"#[no_mangle]\npub extern &quot;C&quot; fn call_from_c() {\n    println!(&quot;Just called a Rust function from C!&quot;);\n}\"><pre><span class=\"pl-c1\">#<span class=\"pl-kos\">[</span>no_mangle<span class=\"pl-kos\">]</span></span>\n<span class=\"pl-k\">pub</span> <span class=\"pl-k\">extern</span> <span class=\"pl-s\">\"C\"</span> <span class=\"pl-k\">fn</span> <span class=\"pl-en\">call_from_c</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-en\">println</span><span class=\"pl-en\">!</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"Just called a Rust function from C!\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">This usage of <code>extern</code> does not require <code>unsafe</code>.</p>\n</blockquote>\n<h3 tabindex=\"-1\" id=\"user-content-accessing-or-modifying-a-mutable-static-variable\" dir=\"auto\"><a class=\"heading-link\" href=\"#accessing-or-modifying-a-mutable-static-variable\">Accessing or Modifying a Mutable Static Variable<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">In this book, we’ve not yet talked about <em>global variables</em>, which Rust does\nsupport but can be problematic with Rust’s ownership rules. If two threads are\naccessing the same mutable global variable, it can cause a data race.</p>\n<p dir=\"auto\">In Rust, global variables are called <em>static</em> variables. Listing 19-9 shows an\nexample declaration and use of a static variable with a string slice as a\nvalue.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-09/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">09</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-9: Defining and using an immutable static\nvariable</span></p>\n<p dir=\"auto\">Static variables are similar to constants, which we discussed in the\n<a href=\"/rust-lang/book/blob/main/src/ch03-01-variables-and-mutability.html#constants\">“Differences Between Variables and\nConstants”</a> section\nin Chapter 3. The names of static variables are in <code>SCREAMING_SNAKE_CASE</code> by\nconvention. Static variables can only store references with the <code>'static</code>\nlifetime, which means the Rust compiler can figure out the lifetime and we\naren’t required to annotate it explicitly. Accessing an immutable static\nvariable is safe.</p>\n<p dir=\"auto\">A subtle difference between constants and immutable static variables is that\nvalues in a static variable have a fixed address in memory. Using the value\nwill always access the same data. Constants, on the other hand, are allowed to\nduplicate their data whenever they’re used. Another difference is that static\nvariables can be mutable. Accessing and modifying mutable static variables is\n<em>unsafe</em>. Listing 19-10 shows how to declare, access, and modify a mutable\nstatic variable named <code>COUNTER</code>.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-10/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">10</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-10: Reading from or writing to a mutable\nstatic variable is unsafe</span></p>\n<p dir=\"auto\">As with regular variables, we specify mutability using the <code>mut</code> keyword. Any\ncode that reads or writes from <code>COUNTER</code> must be within an <code>unsafe</code> block. This\ncode compiles and prints <code>COUNTER: 3</code> as we would expect because it’s single\nthreaded. Having multiple threads access <code>COUNTER</code> would likely result in data\nraces.</p>\n<p dir=\"auto\">With mutable data that is globally accessible, it’s difficult to ensure there\nare no data races, which is why Rust considers mutable static variables to be\nunsafe. Where possible, it’s preferable to use the concurrency techniques and\nthread-safe smart pointers we discussed in Chapter 16 so the compiler checks\nthat data accessed from different threads is done safely.</p>\n<h3 tabindex=\"-1\" id=\"user-content-implementing-an-unsafe-trait\" dir=\"auto\"><a class=\"heading-link\" href=\"#implementing-an-unsafe-trait\">Implementing an Unsafe Trait<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">We can use <code>unsafe</code> to implement an unsafe trait. A trait is unsafe when at\nleast one of its methods has some invariant that the compiler can’t verify. We\ndeclare that a trait is <code>unsafe</code> by adding the <code>unsafe</code> keyword before <code>trait</code>\nand marking the implementation of the trait as <code>unsafe</code> too, as shown in\nListing 19-11.</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-11/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch19-advanced-features/listing-<span class=\"pl-c1\">19</span>-<span class=\"pl-c1\">11</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 19-11: Defining and implementing an unsafe\ntrait</span></p>\n<p dir=\"auto\">By using <code>unsafe impl</code>, we’re promising that we’ll uphold the invariants that\nthe compiler can’t verify.</p>\n<p dir=\"auto\">As an example, recall the <code>Sync</code> and <code>Send</code> marker traits we discussed in the\n<a href=\"/rust-lang/book/blob/main/src/ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits\">“Extensible Concurrency with the <code>Sync</code> and <code>Send</code>\nTraits”</a>\nsection in Chapter 16: the compiler implements these traits automatically if\nour types are composed entirely of <code>Send</code> and <code>Sync</code> types. If we implement a\ntype that contains a type that is not <code>Send</code> or <code>Sync</code>, such as raw pointers,\nand we want to mark that type as <code>Send</code> or <code>Sync</code>, we must use <code>unsafe</code>. Rust\ncan’t verify that our type upholds the guarantees that it can be safely sent\nacross threads or accessed from multiple threads; therefore, we need to do\nthose checks manually and indicate as such with <code>unsafe</code>.</p>\n<h3 tabindex=\"-1\" id=\"user-content-accessing-fields-of-a-union\" dir=\"auto\"><a class=\"heading-link\" href=\"#accessing-fields-of-a-union\">Accessing Fields of a Union<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">The final action that works only with <code>unsafe</code> is accessing fields of a\n<em>union</em>. A <code>union</code> is similar to a <code>struct</code>, but only one declared field is\nused in a particular instance at one time. Unions are primarily used to\ninterface with unions in C code. Accessing union fields is unsafe because Rust\ncan’t guarantee the type of the data currently being stored in the union\ninstance. You can learn more about unions in <a href=\"/rust-lang/book/blob/main/reference/items/unions.html\">the Rust Reference</a>.</p>\n<h3 tabindex=\"-1\" id=\"user-content-when-to-use-unsafe-code\" dir=\"auto\"><a class=\"heading-link\" href=\"#when-to-use-unsafe-code\">When to Use Unsafe Code<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">Using <code>unsafe</code> to take one of the five actions (superpowers) just discussed\nisn’t wrong or even frowned upon. But it is trickier to get <code>unsafe</code> code\ncorrect because the compiler can’t help uphold memory safety. When you have a\nreason to use <code>unsafe</code> code, you can do so, and having the explicit <code>unsafe</code>\nannotation makes it easier to track down the source of problems when they occur.</p>\n</article>","renderedFileInfo":null,"shortPath":null,"tabSize":8,"topBannersInfo":{"overridingGlobalFundingFile":false,"globalPreferredFundingPath":null,"repoOwner":"rust-lang","repoName":"book","showInvalidCitationWarning":false,"citationHelpUrl":"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/about-citation-files","showDependabotConfigurationBanner":false,"actionsOnboardingTip":null},"truncated":false,"viewable":true,"workflowRedirectUrl":null,"symbols":{"timedOut":false,"notAnalyzed":true,"symbols":[]}},"copilotInfo":null,"csrf_tokens":{"/rust-lang/book/branches":{"post":"dUuVQv-X8OZtreENX5Og2Q-ReVBlXko49YICBTkUljy1iiv_2t3FuUhUSyXls6SrNRsajnvpydR62jbdJpwW8A"},"/repos/preferences":{"post":"jw2j0WLOSl4wK80IRqjWstDlF7pk_m2s5I0J-X8R6I2pAUgKfVhDmEHfDYhfBn_tXedfKGxedhtbaAB-CtvLnQ"}}},"title":"book/src/ch19-01-unsafe-rust.md at main · rust-lang/book"}
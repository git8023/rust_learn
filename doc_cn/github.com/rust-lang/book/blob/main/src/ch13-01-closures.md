{"payload":{"allShortcutsEnabled":false,"fileTree":{"src":{"items":[{"name":"img","path":"src/img","contentType":"directory"},{"name":"SUMMARY.md","path":"src/SUMMARY.md","contentType":"file"},{"name":"appendix-00.md","path":"src/appendix-00.md","contentType":"file"},{"name":"appendix-01-keywords.md","path":"src/appendix-01-keywords.md","contentType":"file"},{"name":"appendix-02-operators.md","path":"src/appendix-02-operators.md","contentType":"file"},{"name":"appendix-03-derivable-traits.md","path":"src/appendix-03-derivable-traits.md","contentType":"file"},{"name":"appendix-04-useful-development-tools.md","path":"src/appendix-04-useful-development-tools.md","contentType":"file"},{"name":"appendix-05-editions.md","path":"src/appendix-05-editions.md","contentType":"file"},{"name":"appendix-06-translation.md","path":"src/appendix-06-translation.md","contentType":"file"},{"name":"appendix-07-nightly-rust.md","path":"src/appendix-07-nightly-rust.md","contentType":"file"},{"name":"ch00-00-introduction.md","path":"src/ch00-00-introduction.md","contentType":"file"},{"name":"ch01-00-getting-started.md","path":"src/ch01-00-getting-started.md","contentType":"file"},{"name":"ch01-01-installation.md","path":"src/ch01-01-installation.md","contentType":"file"},{"name":"ch01-02-hello-world.md","path":"src/ch01-02-hello-world.md","contentType":"file"},{"name":"ch01-03-hello-cargo.md","path":"src/ch01-03-hello-cargo.md","contentType":"file"},{"name":"ch02-00-guessing-game-tutorial.md","path":"src/ch02-00-guessing-game-tutorial.md","contentType":"file"},{"name":"ch03-00-common-programming-concepts.md","path":"src/ch03-00-common-programming-concepts.md","contentType":"file"},{"name":"ch03-01-variables-and-mutability.md","path":"src/ch03-01-variables-and-mutability.md","contentType":"file"},{"name":"ch03-02-data-types.md","path":"src/ch03-02-data-types.md","contentType":"file"},{"name":"ch03-03-how-functions-work.md","path":"src/ch03-03-how-functions-work.md","contentType":"file"},{"name":"ch03-04-comments.md","path":"src/ch03-04-comments.md","contentType":"file"},{"name":"ch03-05-control-flow.md","path":"src/ch03-05-control-flow.md","contentType":"file"},{"name":"ch04-00-understanding-ownership.md","path":"src/ch04-00-understanding-ownership.md","contentType":"file"},{"name":"ch04-01-what-is-ownership.md","path":"src/ch04-01-what-is-ownership.md","contentType":"file"},{"name":"ch04-02-references-and-borrowing.md","path":"src/ch04-02-references-and-borrowing.md","contentType":"file"},{"name":"ch04-03-slices.md","path":"src/ch04-03-slices.md","contentType":"file"},{"name":"ch05-00-structs.md","path":"src/ch05-00-structs.md","contentType":"file"},{"name":"ch05-01-defining-structs.md","path":"src/ch05-01-defining-structs.md","contentType":"file"},{"name":"ch05-02-example-structs.md","path":"src/ch05-02-example-structs.md","contentType":"file"},{"name":"ch05-03-method-syntax.md","path":"src/ch05-03-method-syntax.md","contentType":"file"},{"name":"ch06-00-enums.md","path":"src/ch06-00-enums.md","contentType":"file"},{"name":"ch06-01-defining-an-enum.md","path":"src/ch06-01-defining-an-enum.md","contentType":"file"},{"name":"ch06-02-match.md","path":"src/ch06-02-match.md","contentType":"file"},{"name":"ch06-03-if-let.md","path":"src/ch06-03-if-let.md","contentType":"file"},{"name":"ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","path":"src/ch07-00-managing-growing-projects-with-packages-crates-and-modules.md","contentType":"file"},{"name":"ch07-01-packages-and-crates.md","path":"src/ch07-01-packages-and-crates.md","contentType":"file"},{"name":"ch07-02-defining-modules-to-control-scope-and-privacy.md","path":"src/ch07-02-defining-modules-to-control-scope-and-privacy.md","contentType":"file"},{"name":"ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","path":"src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md","contentType":"file"},{"name":"ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","path":"src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md","contentType":"file"},{"name":"ch07-05-separating-modules-into-different-files.md","path":"src/ch07-05-separating-modules-into-different-files.md","contentType":"file"},{"name":"ch08-00-common-collections.md","path":"src/ch08-00-common-collections.md","contentType":"file"},{"name":"ch08-01-vectors.md","path":"src/ch08-01-vectors.md","contentType":"file"},{"name":"ch08-02-strings.md","path":"src/ch08-02-strings.md","contentType":"file"},{"name":"ch08-03-hash-maps.md","path":"src/ch08-03-hash-maps.md","contentType":"file"},{"name":"ch09-00-error-handling.md","path":"src/ch09-00-error-handling.md","contentType":"file"},{"name":"ch09-01-unrecoverable-errors-with-panic.md","path":"src/ch09-01-unrecoverable-errors-with-panic.md","contentType":"file"},{"name":"ch09-02-recoverable-errors-with-result.md","path":"src/ch09-02-recoverable-errors-with-result.md","contentType":"file"},{"name":"ch09-03-to-panic-or-not-to-panic.md","path":"src/ch09-03-to-panic-or-not-to-panic.md","contentType":"file"},{"name":"ch10-00-generics.md","path":"src/ch10-00-generics.md","contentType":"file"},{"name":"ch10-01-syntax.md","path":"src/ch10-01-syntax.md","contentType":"file"},{"name":"ch10-02-traits.md","path":"src/ch10-02-traits.md","contentType":"file"},{"name":"ch10-03-lifetime-syntax.md","path":"src/ch10-03-lifetime-syntax.md","contentType":"file"},{"name":"ch11-00-testing.md","path":"src/ch11-00-testing.md","contentType":"file"},{"name":"ch11-01-writing-tests.md","path":"src/ch11-01-writing-tests.md","contentType":"file"},{"name":"ch11-02-running-tests.md","path":"src/ch11-02-running-tests.md","contentType":"file"},{"name":"ch11-03-test-organization.md","path":"src/ch11-03-test-organization.md","contentType":"file"},{"name":"ch12-00-an-io-project.md","path":"src/ch12-00-an-io-project.md","contentType":"file"},{"name":"ch12-01-accepting-command-line-arguments.md","path":"src/ch12-01-accepting-command-line-arguments.md","contentType":"file"},{"name":"ch12-02-reading-a-file.md","path":"src/ch12-02-reading-a-file.md","contentType":"file"},{"name":"ch12-03-improving-error-handling-and-modularity.md","path":"src/ch12-03-improving-error-handling-and-modularity.md","contentType":"file"},{"name":"ch12-04-testing-the-librarys-functionality.md","path":"src/ch12-04-testing-the-librarys-functionality.md","contentType":"file"},{"name":"ch12-05-working-with-environment-variables.md","path":"src/ch12-05-working-with-environment-variables.md","contentType":"file"},{"name":"ch12-06-writing-to-stderr-instead-of-stdout.md","path":"src/ch12-06-writing-to-stderr-instead-of-stdout.md","contentType":"file"},{"name":"ch13-00-functional-features.md","path":"src/ch13-00-functional-features.md","contentType":"file"},{"name":"ch13-01-closures.md","path":"src/ch13-01-closures.md","contentType":"file"},{"name":"ch13-02-iterators.md","path":"src/ch13-02-iterators.md","contentType":"file"},{"name":"ch13-03-improving-our-io-project.md","path":"src/ch13-03-improving-our-io-project.md","contentType":"file"},{"name":"ch13-04-performance.md","path":"src/ch13-04-performance.md","contentType":"file"},{"name":"ch14-00-more-about-cargo.md","path":"src/ch14-00-more-about-cargo.md","contentType":"file"},{"name":"ch14-01-release-profiles.md","path":"src/ch14-01-release-profiles.md","contentType":"file"},{"name":"ch14-02-publishing-to-crates-io.md","path":"src/ch14-02-publishing-to-crates-io.md","contentType":"file"},{"name":"ch14-03-cargo-workspaces.md","path":"src/ch14-03-cargo-workspaces.md","contentType":"file"},{"name":"ch14-04-installing-binaries.md","path":"src/ch14-04-installing-binaries.md","contentType":"file"},{"name":"ch14-05-extending-cargo.md","path":"src/ch14-05-extending-cargo.md","contentType":"file"},{"name":"ch15-00-smart-pointers.md","path":"src/ch15-00-smart-pointers.md","contentType":"file"},{"name":"ch15-01-box.md","path":"src/ch15-01-box.md","contentType":"file"},{"name":"ch15-02-deref.md","path":"src/ch15-02-deref.md","contentType":"file"},{"name":"ch15-03-drop.md","path":"src/ch15-03-drop.md","contentType":"file"},{"name":"ch15-04-rc.md","path":"src/ch15-04-rc.md","contentType":"file"},{"name":"ch15-05-interior-mutability.md","path":"src/ch15-05-interior-mutability.md","contentType":"file"},{"name":"ch15-06-reference-cycles.md","path":"src/ch15-06-reference-cycles.md","contentType":"file"},{"name":"ch16-00-concurrency.md","path":"src/ch16-00-concurrency.md","contentType":"file"},{"name":"ch16-01-threads.md","path":"src/ch16-01-threads.md","contentType":"file"},{"name":"ch16-02-message-passing.md","path":"src/ch16-02-message-passing.md","contentType":"file"},{"name":"ch16-03-shared-state.md","path":"src/ch16-03-shared-state.md","contentType":"file"},{"name":"ch16-04-extensible-concurrency-sync-and-send.md","path":"src/ch16-04-extensible-concurrency-sync-and-send.md","contentType":"file"},{"name":"ch17-00-oop.md","path":"src/ch17-00-oop.md","contentType":"file"},{"name":"ch17-01-what-is-oo.md","path":"src/ch17-01-what-is-oo.md","contentType":"file"},{"name":"ch17-02-trait-objects.md","path":"src/ch17-02-trait-objects.md","contentType":"file"},{"name":"ch17-03-oo-design-patterns.md","path":"src/ch17-03-oo-design-patterns.md","contentType":"file"},{"name":"ch18-00-patterns.md","path":"src/ch18-00-patterns.md","contentType":"file"},{"name":"ch18-01-all-the-places-for-patterns.md","path":"src/ch18-01-all-the-places-for-patterns.md","contentType":"file"},{"name":"ch18-02-refutability.md","path":"src/ch18-02-refutability.md","contentType":"file"},{"name":"ch18-03-pattern-syntax.md","path":"src/ch18-03-pattern-syntax.md","contentType":"file"},{"name":"ch19-00-advanced-features.md","path":"src/ch19-00-advanced-features.md","contentType":"file"},{"name":"ch19-01-unsafe-rust.md","path":"src/ch19-01-unsafe-rust.md","contentType":"file"},{"name":"ch19-03-advanced-traits.md","path":"src/ch19-03-advanced-traits.md","contentType":"file"},{"name":"ch19-04-advanced-types.md","path":"src/ch19-04-advanced-types.md","contentType":"file"},{"name":"ch19-05-advanced-functions-and-closures.md","path":"src/ch19-05-advanced-functions-and-closures.md","contentType":"file"},{"name":"ch19-06-macros.md","path":"src/ch19-06-macros.md","contentType":"file"},{"name":"ch20-00-final-project-a-web-server.md","path":"src/ch20-00-final-project-a-web-server.md","contentType":"file"},{"name":"ch20-01-single-threaded.md","path":"src/ch20-01-single-threaded.md","contentType":"file"},{"name":"ch20-02-multithreaded.md","path":"src/ch20-02-multithreaded.md","contentType":"file"},{"name":"ch20-03-graceful-shutdown-and-cleanup.md","path":"src/ch20-03-graceful-shutdown-and-cleanup.md","contentType":"file"},{"name":"foreword.md","path":"src/foreword.md","contentType":"file"},{"name":"title-page.md","path":"src/title-page.md","contentType":"file"}],"totalCount":106},"":{"items":[{"name":".cargo","path":".cargo","contentType":"directory"},{"name":".github","path":".github","contentType":"directory"},{"name":"2018-edition","path":"2018-edition","contentType":"directory"},{"name":"ci","path":"ci","contentType":"directory"},{"name":"dot","path":"dot","contentType":"directory"},{"name":"first-edition","path":"first-edition","contentType":"directory"},{"name":"listings","path":"listings","contentType":"directory"},{"name":"nostarch","path":"nostarch","contentType":"directory"},{"name":"redirects","path":"redirects","contentType":"directory"},{"name":"second-edition","path":"second-edition","contentType":"directory"},{"name":"src","path":"src","contentType":"directory"},{"name":"theme","path":"theme","contentType":"directory"},{"name":"tools","path":"tools","contentType":"directory"},{"name":".gitattributes","path":".gitattributes","contentType":"file"},{"name":".gitignore","path":".gitignore","contentType":"file"},{"name":"ADMIN_TASKS.md","path":"ADMIN_TASKS.md","contentType":"file"},{"name":"CONTRIBUTING.md","path":"CONTRIBUTING.md","contentType":"file"},{"name":"COPYRIGHT","path":"COPYRIGHT","contentType":"file"},{"name":"Cargo.lock","path":"Cargo.lock","contentType":"file"},{"name":"Cargo.toml","path":"Cargo.toml","contentType":"file"},{"name":"LICENSE-APACHE","path":"LICENSE-APACHE","contentType":"file"},{"name":"LICENSE-MIT","path":"LICENSE-MIT","contentType":"file"},{"name":"README.md","path":"README.md","contentType":"file"},{"name":"TODO.md","path":"TODO.md","contentType":"file"},{"name":"book.toml","path":"book.toml","contentType":"file"},{"name":"ferris.css","path":"ferris.css","contentType":"file"},{"name":"ferris.js","path":"ferris.js","contentType":"file"},{"name":"rust-toolchain","path":"rust-toolchain","contentType":"file"},{"name":"rustfmt.toml","path":"rustfmt.toml","contentType":"file"},{"name":"style-guide.md","path":"style-guide.md","contentType":"file"}],"totalCount":30}},"fileTreeProcessingTime":13.582975000000001,"foldersToFetch":[],"reducedMotionEnabled":null,"repo":{"id":47854924,"defaultBranch":"main","name":"book","ownerLogin":"rust-lang","currentUserCanPush":false,"isFork":false,"isEmpty":false,"createdAt":"2015-12-11T22:49:49.000Z","ownerAvatar":"https://avatars.githubusercontent.com/u/5430905?v=4","public":true,"private":false,"isOrgOwned":true},"symbolsExpanded":false,"treeExpanded":true,"refInfo":{"name":"main","listCacheKey":"v0:1688046669.0","canEdit":false,"refType":"branch","currentOid":"72187f5cd0beaaa9c6f584156bcd88f921871e83"},"path":"src/ch13-01-closures.md","currentUser":null,"blob":{"rawLines":null,"stylingDirectives":null,"csv":null,"csvError":null,"dependabotInfo":{"showConfigurationBanner":false,"configFilePath":null,"networkDependabotPath":"/rust-lang/book/network/updates","dismissConfigurationNoticePath":"/settings/dismiss-notice/dependabot_configuration_notice","configurationNoticeDismissed":null,"repoAlertsPath":"/rust-lang/book/security/dependabot","repoSecurityAndAnalysisPath":"/rust-lang/book/settings/security_analysis","repoOwnerIsOrg":true,"currentUserCanAdminRepo":false},"displayName":"ch13-01-closures.md","displayUrl":"https://github.com/rust-lang/book/blob/main/src/ch13-01-closures.md?raw=true","headerInfo":{"blobSize":"20.3 KB","deleteInfo":{"deleteTooltip":"You must be signed in to make or propose changes"},"editInfo":{"editTooltip":"You must be signed in to make or propose changes"},"ghDesktopPath":"https://desktop.github.com","gitLfsPath":null,"onBranch":true,"shortPath":"f1ae324","siteNavLoginPath":"/login?return_to=https%3A%2F%2Fgithub.com%2Frust-lang%2Fbook%2Fblob%2Fmain%2Fsrc%2Fch13-01-closures.md","isCSV":false,"isRichtext":true,"toc":[{"level":2,"text":"Closures: Anonymous Functions that Capture Their Environment","anchor":"closures-anonymous-functions-that-capture-their-environment","htmlText":"Closures: Anonymous Functions that Capture Their Environment"},{"level":3,"text":"Capturing the Environment with Closures","anchor":"capturing-the-environment-with-closures","htmlText":"Capturing the Environment with Closures"},{"level":3,"text":"Closure Type Inference and Annotation","anchor":"closure-type-inference-and-annotation","htmlText":"Closure Type Inference and Annotation"},{"level":3,"text":"Capturing References or Moving Ownership","anchor":"capturing-references-or-moving-ownership","htmlText":"Capturing References or Moving Ownership"},{"level":3,"text":"Moving Captured Values Out of Closures and the Fn Traits","anchor":"moving-captured-values-out-of-closures-and-the-fn-traits","htmlText":"Moving Captured Values Out of Closures and the Fn Traits"}],"lineInfo":{"truncatedLoc":"423","truncatedSloc":"339"},"mode":"file"},"image":false,"isCodeownersFile":null,"isPlain":false,"isValidLegacyIssueTemplate":false,"issueTemplateHelpUrl":"https://docs.github.com/articles/about-issue-and-pull-request-templates","issueTemplate":null,"discussionTemplate":null,"language":"Markdown","languageID":222,"large":false,"loggedIn":false,"newDiscussionPath":"/rust-lang/book/discussions/new","newIssuePath":"/rust-lang/book/issues/new","planSupportInfo":{"repoIsFork":null,"repoOwnedByCurrentUser":null,"requestFullPath":"/rust-lang/book/blob/main/src/ch13-01-closures.md","showFreeOrgGatedFeatureMessage":null,"showPlanSupportBanner":null,"upgradeDataAttributes":null,"upgradePath":null},"publishBannersInfo":{"dismissActionNoticePath":"/settings/dismiss-notice/publish_action_from_dockerfile","dismissStackNoticePath":"/settings/dismiss-notice/publish_stack_from_file","releasePath":"/rust-lang/book/releases/new?marketplace=true","showPublishActionBanner":false,"showPublishStackBanner":false},"renderImageOrRaw":false,"richText":"<article class=\"markdown-body entry-content container-lg\" itemprop=\"text\">\n<p dir=\"auto\"><a id=\"user-content-closures-anonymous-functions-that-can-capture-their-environment\"></a></p>\n<h2 tabindex=\"-1\" id=\"user-content-closures-anonymous-functions-that-capture-their-environment\" dir=\"auto\"><a class=\"heading-link\" href=\"#closures-anonymous-functions-that-capture-their-environment\">Closures: Anonymous Functions that Capture Their Environment<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">Rust’s closures are anonymous functions you can save in a variable or pass as\narguments to other functions. You can create the closure in one place and then\ncall the closure elsewhere to evaluate it in a different context. Unlike\nfunctions, closures can capture values from the scope in which they’re defined.\nWe’ll demonstrate how these closure features allow for code reuse and behavior\ncustomization.</p>\n\n<p dir=\"auto\"><a id=\"user-content-creating-an-abstraction-of-behavior-with-closures\"></a>\n<a id=\"user-content-refactoring-using-functions\"></a>\n<a id=\"user-content-refactoring-with-closures-to-store-code\"></a></p>\n<h3 tabindex=\"-1\" id=\"user-content-capturing-the-environment-with-closures\" dir=\"auto\"><a class=\"heading-link\" href=\"#capturing-the-environment-with-closures\">Capturing the Environment with Closures<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">We’ll first examine how we can use closures to capture values from the\nenvironment they’re defined in for later use. Here’s the scenario: Every so\noften, our t-shirt company gives away an exclusive, limited-edition shirt to\nsomeone on our mailing list as a promotion. People on the mailing list can\noptionally add their favorite color to their profile. If the person chosen for\na free shirt has their favorite color set, they get that color shirt. If the\nperson hasn’t specified a favorite color, they get whatever color the company\ncurrently has the most of.</p>\n<p dir=\"auto\">There are many ways to implement this. For this example, we’re going to use an\nenum called <code>ShirtColor</code> that has the variants <code>Red</code> and <code>Blue</code> (limiting the\nnumber of colors available for simplicity). We represent the company’s\ninventory with an <code>Inventory</code> struct that has a field named <code>shirts</code> that\ncontains a <code>Vec&lt;ShirtColor&gt;</code> representing the shirt colors currently in stock.\nThe method <code>giveaway</code> defined on <code>Inventory</code> gets the optional shirt\ncolor preference of the free shirt winner, and returns the shirt color the\nperson will get. This setup is shown in Listing 13-1:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch13-functional-features/listing-13-01/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch13-functional-features/listing-<span class=\"pl-c1\">13</span>-<span class=\"pl-c1\">01</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 13-1: Shirt company giveaway situation</span></p>\n<p dir=\"auto\">The <code>store</code> defined in <code>main</code> has two blue shirts and one red shirt remaining\nto distribute for this limited-edition promotion. We call the <code>giveaway</code> method\nfor a user with a preference for a red shirt and a user without any preference.</p>\n<p dir=\"auto\">Again, this code could be implemented in many ways, and here, to focus on\nclosures, we’ve stuck to concepts you’ve already learned except for the body of\nthe <code>giveaway</code> method that uses a closure. In the <code>giveaway</code> method, we get the\nuser preference as a parameter of type <code>Option&lt;ShirtColor&gt;</code> and call the\n<code>unwrap_or_else</code> method on <code>user_preference</code>. The <a href=\"/rust-lang/book/blob/main/std/option/enum.Option.html#method.unwrap_or_else\"><code>unwrap_or_else</code> method on\n<code>Option&lt;T&gt;</code></a> is defined by the standard library.\nIt takes one argument: a closure without any arguments that returns a value <code>T</code>\n(the same type stored in the <code>Some</code> variant of the <code>Option&lt;T&gt;</code>, in this case\n<code>ShirtColor</code>). If the <code>Option&lt;T&gt;</code> is the <code>Some</code> variant, <code>unwrap_or_else</code>\nreturns the value from within the <code>Some</code>. If the <code>Option&lt;T&gt;</code> is the <code>None</code>\nvariant, <code>unwrap_or_else</code> calls the closure and returns the value returned by\nthe closure.</p>\n<p dir=\"auto\">We specify the closure expression <code>|| self.most_stocked()</code> as the argument to\n<code>unwrap_or_else</code>. This is a closure that takes no parameters itself (if the\nclosure had parameters, they would appear between the two vertical bars). The\nbody of the closure calls <code>self.most_stocked()</code>. We’re defining the closure\nhere, and the implementation of <code>unwrap_or_else</code> will evaluate the closure\nlater if the result is needed.</p>\n<p dir=\"auto\">Running this code prints:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch13-functional-features/listing-13-01/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch13-functional-features/listing-13-01/output.txt}}</span></pre></div>\n<p dir=\"auto\">One interesting aspect here is that we’ve passed a closure that calls\n<code>self.most_stocked()</code> on the current <code>Inventory</code> instance. The standard library\ndidn’t need to know anything about the <code>Inventory</code> or <code>ShirtColor</code> types we\ndefined, or the logic we want to use in this scenario. The closure captures an\nimmutable reference to the <code>self</code> <code>Inventory</code> instance and passes it with the\ncode we specify to the <code>unwrap_or_else</code> method. Functions, on the other hand,\nare not able to capture their environment in this way.</p>\n<h3 tabindex=\"-1\" id=\"user-content-closure-type-inference-and-annotation\" dir=\"auto\"><a class=\"heading-link\" href=\"#closure-type-inference-and-annotation\">Closure Type Inference and Annotation<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">There are more differences between functions and closures. Closures don’t\nusually require you to annotate the types of the parameters or the return value\nlike <code>fn</code> functions do. Type annotations are required on functions because the\ntypes are part of an explicit interface exposed to your users. Defining this\ninterface rigidly is important for ensuring that everyone agrees on what types\nof values a function uses and returns. Closures, on the other hand, aren’t used\nin an exposed interface like this: they’re stored in variables and used without\nnaming them and exposing them to users of our library.</p>\n<p dir=\"auto\">Closures are typically short and relevant only within a narrow context rather\nthan in any arbitrary scenario. Within these limited contexts, the compiler can\ninfer the types of the parameters and the return type, similar to how it’s able\nto infer the types of most variables (there are rare cases where the compiler\nneeds closure type annotations too).</p>\n<p dir=\"auto\">As with variables, we can add type annotations if we want to increase\nexplicitness and clarity at the cost of being more verbose than is strictly\nnecessary. Annotating the types for a closure would look like the definition\nshown in Listing 13-2. In this example, we’re defining a closure and storing it\nin a variable rather than defining the closure in the spot we pass it as an\nargument as we did in Listing 13-1.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch13-functional-features/listing-13-02/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch13-functional-features/listing-<span class=\"pl-c1\">13</span>-<span class=\"pl-c1\">02</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 13-2: Adding optional type annotations of the\nparameter and return value types in the closure</span></p>\n<p dir=\"auto\">With type annotations added, the syntax of closures looks more similar to the\nsyntax of functions. Here we define a function that adds 1 to its parameter and\na closure that has the same behavior, for comparison. We’ve added some spaces\nto line up the relevant parts. This illustrates how closure syntax is similar\nto function syntax except for the use of pipes and the amount of syntax that is\noptional:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }\nlet add_one_v2 = |x: u32| -&gt; u32 { x + 1 };\nlet add_one_v3 = |x|             { x + 1 };\nlet add_one_v4 = |x|               x + 1  ;\"><pre><span class=\"pl-k\">fn</span>  <span class=\"pl-en\">add_one_v1</span>   <span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">u32</span><span class=\"pl-kos\">)</span> -&gt; <span class=\"pl-smi\">u32</span> <span class=\"pl-kos\">{</span> x + <span class=\"pl-c1\">1</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">let</span> add_one_v2 = |<span class=\"pl-s1\">x</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">u32</span>| -&gt; <span class=\"pl-smi\">u32</span> <span class=\"pl-kos\">{</span> x + <span class=\"pl-c1\">1</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> add_one_v3 = |x|             <span class=\"pl-kos\">{</span> x + <span class=\"pl-c1\">1</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> add_one_v4 = |x|               x + <span class=\"pl-c1\">1</span>  <span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">The first line shows a function definition, and the second line shows a fully\nannotated closure definition. In the third line, we remove the type annotations\nfrom the closure definition. In the fourth line, we remove the brackets, which\nare optional because the closure body has only one expression. These are all\nvalid definitions that will produce the same behavior when they’re called. The\n<code>add_one_v3</code> and <code>add_one_v4</code> lines require the closures to be evaluated to be\nable to compile because the types will be inferred from their usage. This is\nsimilar to <code>let v = Vec::new();</code> needing either type annotations or values of\nsome type to be inserted into the <code>Vec</code> for Rust to be able to infer the type.</p>\n<p dir=\"auto\">For closure definitions, the compiler will infer one concrete type for each of\ntheir parameters and for their return value. For instance, Listing 13-3 shows\nthe definition of a short closure that just returns the value it receives as a\nparameter. This closure isn’t very useful except for the purposes of this\nexample. Note that we haven’t added any type annotations to the definition.\nBecause there are no type annotations, we can call the closure with any type,\nwhich we’ve done here with <code>String</code> the first time. If we then try to call\n<code>example_closure</code> with an integer, we’ll get an error.</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch13-functional-features/listing-13-03/src/main.rs:here}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch13-functional-features/listing-<span class=\"pl-c1\">13</span>-<span class=\"pl-c1\">03</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">:</span>here<span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 13-3: Attempting to call a closure whose types\nare inferred with two different types</span></p>\n<p dir=\"auto\">The compiler gives us this error:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch13-functional-features/listing-13-03/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch13-functional-features/listing-13-03/output.txt}}</span></pre></div>\n<p dir=\"auto\">The first time we call <code>example_closure</code> with the <code>String</code> value, the compiler\ninfers the type of <code>x</code> and the return type of the closure to be <code>String</code>. Those\ntypes are then locked into the closure in <code>example_closure</code>, and we get a type\nerror when we next try to use a different type with the same closure.</p>\n<h3 tabindex=\"-1\" id=\"user-content-capturing-references-or-moving-ownership\" dir=\"auto\"><a class=\"heading-link\" href=\"#capturing-references-or-moving-ownership\">Capturing References or Moving Ownership<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">Closures can capture values from their environment in three ways, which\ndirectly map to the three ways a function can take a parameter: borrowing\nimmutably, borrowing mutably, and taking ownership. The closure will decide\nwhich of these to use based on what the body of the function does with the\ncaptured values.</p>\n<p dir=\"auto\">In Listing 13-4, we define a closure that captures an immutable reference to\nthe vector named <code>list</code> because it only needs an immutable reference to print\nthe value:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch13-functional-features/listing-13-04/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch13-functional-features/listing-<span class=\"pl-c1\">13</span>-<span class=\"pl-c1\">04</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 13-4: Defining and calling a closure that\ncaptures an immutable reference</span></p>\n<p dir=\"auto\">This example also illustrates that a variable can bind to a closure definition,\nand we can later call the closure by using the variable name and parentheses as\nif the variable name were a function name.</p>\n<p dir=\"auto\">Because we can have multiple immutable references to <code>list</code> at the same time,\n<code>list</code> is still accessible from the code before the closure definition, after\nthe closure definition but before the closure is called, and after the closure\nis called. This code compiles, runs, and prints:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch13-functional-features/listing-13-04/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch13-functional-features/listing-13-04/output.txt}}</span></pre></div>\n<p dir=\"auto\">Next, in Listing 13-5, we change the closure body so that it adds an element to\nthe <code>list</code> vector. The closure now captures a mutable reference:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch13-functional-features/listing-13-05/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch13-functional-features/listing-<span class=\"pl-c1\">13</span>-<span class=\"pl-c1\">05</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 13-5: Defining and calling a closure that\ncaptures a mutable reference</span></p>\n<p dir=\"auto\">This code compiles, runs, and prints:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch13-functional-features/listing-13-05/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch13-functional-features/listing-13-05/output.txt}}</span></pre></div>\n<p dir=\"auto\">Note that there’s no longer a <code>println!</code> between the definition and the call of\nthe <code>borrows_mutably</code> closure: when <code>borrows_mutably</code> is defined, it captures a\nmutable reference to <code>list</code>. We don’t use the closure again after the closure\nis called, so the mutable borrow ends. Between the closure definition and the\nclosure call, an immutable borrow to print isn’t allowed because no other\nborrows are allowed when there’s a mutable borrow. Try adding a <code>println!</code>\nthere to see what error message you get!</p>\n<p dir=\"auto\">If you want to force the closure to take ownership of the values it uses in the\nenvironment even though the body of the closure doesn’t strictly need\nownership, you can use the <code>move</code> keyword before the parameter list.</p>\n<p dir=\"auto\">This technique is mostly useful when passing a closure to a new thread to move\nthe data so that it’s owned by the new thread. We’ll discuss threads and why\nyou would want to use them in detail in Chapter 16 when we talk about\nconcurrency, but for now, let’s briefly explore spawning a new thread using a\nclosure that needs the <code>move</code> keyword. Listing 13-6 shows Listing 13-4 modified\nto print the vector in a new thread rather than in the main thread:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch13-functional-features/listing-13-06/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch13-functional-features/listing-<span class=\"pl-c1\">13</span>-<span class=\"pl-c1\">06</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 13-6: Using <code>move</code> to force the closure for the\nthread to take ownership of <code>list</code></span></p>\n<p dir=\"auto\">We spawn a new thread, giving the thread a closure to run as an argument. The\nclosure body prints out the list. In Listing 13-4, the closure only captured\n<code>list</code> using an immutable reference because that's the least amount of access\nto <code>list</code> needed to print it. In this example, even though the closure body\nstill only needs an immutable reference, we need to specify that <code>list</code> should\nbe moved into the closure by putting the <code>move</code> keyword at the beginning of the\nclosure definition. The new thread might finish before the rest of the main\nthread finishes, or the main thread might finish first. If the main thread\nmaintained ownership of <code>list</code> but ended before the new thread did and dropped\n<code>list</code>, the immutable reference in the thread would be invalid. Therefore, the\ncompiler requires that <code>list</code> be moved into the closure given to the new thread\nso the reference will be valid. Try removing the <code>move</code> keyword or using <code>list</code>\nin the main thread after the closure is defined to see what compiler errors you\nget!</p>\n\n<p dir=\"auto\"><a id=\"user-content-storing-closures-using-generic-parameters-and-the-fn-traits\"></a>\n<a id=\"user-content-limitations-of-the-cacher-implementation\"></a>\n<a id=\"user-content-moving-captured-values-out-of-the-closure-and-the-fn-traits\"></a></p>\n<h3 tabindex=\"-1\" id=\"user-content-moving-captured-values-out-of-closures-and-the-fn-traits\" dir=\"auto\"><a class=\"heading-link\" href=\"#moving-captured-values-out-of-closures-and-the-fn-traits\">Moving Captured Values Out of Closures and the <code>Fn</code> Traits<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">Once a closure has captured a reference or captured ownership of a value from\nthe environment where the closure is defined (thus affecting what, if anything,\nis moved <em>into</em> the closure), the code in the body of the closure defines what\nhappens to the references or values when the closure is evaluated later (thus\naffecting what, if anything, is moved <em>out of</em> the closure). A closure body can\ndo any of the following: move a captured value out of the closure, mutate the\ncaptured value, neither move nor mutate the value, or capture nothing from the\nenvironment to begin with.</p>\n<p dir=\"auto\">The way a closure captures and handles values from the environment affects\nwhich traits the closure implements, and traits are how functions and structs\ncan specify what kinds of closures they can use. Closures will automatically\nimplement one, two, or all three of these <code>Fn</code> traits, in an additive fashion,\ndepending on how the closure’s body handles the values:</p>\n<ol dir=\"auto\">\n<li><code>FnOnce</code> applies to closures that can be called once. All closures implement\nat least this trait, because all closures can be called. A closure that\nmoves captured values out of its body will only implement <code>FnOnce</code> and none\nof the other <code>Fn</code> traits, because it can only be called once.</li>\n<li><code>FnMut</code> applies to closures that don’t move captured values out of their\nbody, but that might mutate the captured values. These closures can be\ncalled more than once.</li>\n<li><code>Fn</code> applies to closures that don’t move captured values out of their body\nand that don’t mutate captured values, as well as closures that capture\nnothing from their environment. These closures can be called more than once\nwithout mutating their environment, which is important in cases such as\ncalling a closure multiple times concurrently.</li>\n</ol>\n<p dir=\"auto\">Let’s look at the definition of the <code>unwrap_or_else</code> method on <code>Option&lt;T&gt;</code> that\nwe used in Listing 13-1:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"impl&lt;T&gt; Option&lt;T&gt; {\n    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T\n    where\n        F: FnOnce() -&gt; T\n    {\n        match self {\n            Some(x) =&gt; x,\n            None =&gt; f(),\n        }\n    }\n}\"><pre><span class=\"pl-k\">impl</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-smi\">Option</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">pub</span> <span class=\"pl-k\">fn</span> <span class=\"pl-en\">unwrap_or_else</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">F</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">self</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">f</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">F</span><span class=\"pl-kos\">)</span> -&gt; <span class=\"pl-smi\">T</span>\n    <span class=\"pl-k\">where</span>\n        <span class=\"pl-smi\">F</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">FnOnce</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> -&gt; <span class=\"pl-smi\">T</span>\n    <span class=\"pl-kos\">{</span>\n        <span class=\"pl-k\">match</span> <span class=\"pl-smi\">self</span> <span class=\"pl-kos\">{</span>\n            <span class=\"pl-v\">Some</span><span class=\"pl-kos\">(</span>x<span class=\"pl-kos\">)</span> =&gt; x<span class=\"pl-kos\">,</span>\n            <span class=\"pl-v\">None</span> =&gt; <span class=\"pl-en\">f</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">,</span>\n        <span class=\"pl-kos\">}</span>\n    <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">Recall that <code>T</code> is the generic type representing the type of the value in the\n<code>Some</code> variant of an <code>Option</code>. That type <code>T</code> is also the return type of the\n<code>unwrap_or_else</code> function: code that calls <code>unwrap_or_else</code> on an\n<code>Option&lt;String&gt;</code>, for example, will get a <code>String</code>.</p>\n<p dir=\"auto\">Next, notice that the <code>unwrap_or_else</code> function has the additional generic type\nparameter <code>F</code>. The <code>F</code> type is the type of the parameter named <code>f</code>, which is\nthe closure we provide when calling <code>unwrap_or_else</code>.</p>\n<p dir=\"auto\">The trait bound specified on the generic type <code>F</code> is <code>FnOnce() -&gt; T</code>, which\nmeans <code>F</code> must be able to be called once, take no arguments, and return a <code>T</code>.\nUsing <code>FnOnce</code> in the trait bound expresses the constraint that\n<code>unwrap_or_else</code> is only going to call <code>f</code> at most one time. In the body of\n<code>unwrap_or_else</code>, we can see that if the <code>Option</code> is <code>Some</code>, <code>f</code> won’t be\ncalled. If the <code>Option</code> is <code>None</code>, <code>f</code> will be called once. Because all\nclosures implement <code>FnOnce</code>, <code>unwrap_or_else</code> accepts the most different kinds\nof closures and is as flexible as it can be.</p>\n<blockquote>\n<p dir=\"auto\">Note: Functions can implement all three of the <code>Fn</code> traits too. If what we\nwant to do doesn’t require capturing a value from the environment, we can use\nthe name of a function rather than a closure where we need something that\nimplements one of the <code>Fn</code> traits. For example, on an <code>Option&lt;Vec&lt;T&gt;&gt;</code> value,\nwe could call <code>unwrap_or_else(Vec::new)</code> to get a new, empty vector if the\nvalue is <code>None</code>.</p>\n</blockquote>\n<p dir=\"auto\">Now let’s look at the standard library method <code>sort_by_key</code> defined on slices,\nto see how that differs from <code>unwrap_or_else</code> and why <code>sort_by_key</code> uses\n<code>FnMut</code> instead of <code>FnOnce</code> for the trait bound. The closure gets one argument\nin the form of a reference to the current item in the slice being considered,\nand returns a value of type <code>K</code> that can be ordered. This function is useful\nwhen you want to sort a slice by a particular attribute of each item. In\nListing 13-7, we have a list of <code>Rectangle</code> instances and we use <code>sort_by_key</code>\nto order them by their <code>width</code> attribute from low to high:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch13-functional-features/listing-13-07/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch13-functional-features/listing-<span class=\"pl-c1\">13</span>-<span class=\"pl-c1\">07</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 13-7: Using <code>sort_by_key</code> to order rectangles by\nwidth</span></p>\n<p dir=\"auto\">This code prints:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch13-functional-features/listing-13-07/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch13-functional-features/listing-13-07/output.txt}}</span></pre></div>\n<p dir=\"auto\">The reason <code>sort_by_key</code> is defined to take an <code>FnMut</code> closure is that it calls\nthe closure multiple times: once for each item in the slice. The closure <code>|r| r.width</code> doesn’t capture, mutate, or move out anything from its environment, so\nit meets the trait bound requirements.</p>\n<p dir=\"auto\">In contrast, Listing 13-8 shows an example of a closure that implements just\nthe <code>FnOnce</code> trait, because it moves a value out of the environment. The\ncompiler won’t let us use this closure with <code>sort_by_key</code>:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch13-functional-features/listing-13-08/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch13-functional-features/listing-<span class=\"pl-c1\">13</span>-<span class=\"pl-c1\">08</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 13-8: Attempting to use an <code>FnOnce</code> closure with\n<code>sort_by_key</code></span></p>\n<p dir=\"auto\">This is a contrived, convoluted way (that doesn’t work) to try and count the\nnumber of times <code>sort_by_key</code> gets called when sorting <code>list</code>. This code\nattempts to do this counting by pushing <code>value</code>—a <code>String</code> from the closure’s\nenvironment—into the <code>sort_operations</code> vector. The closure captures <code>value</code>\nthen moves <code>value</code> out of the closure by transferring ownership of <code>value</code> to\nthe <code>sort_operations</code> vector. This closure can be called once; trying to call\nit a second time wouldn’t work because <code>value</code> would no longer be in the\nenvironment to be pushed into <code>sort_operations</code> again! Therefore, this closure\nonly implements <code>FnOnce</code>. When we try to compile this code, we get this error\nthat <code>value</code> can’t be moved out of the closure because the closure must\nimplement <code>FnMut</code>:</p>\n<div class=\"highlight highlight-text-shell-session notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#include ../listings/ch13-functional-features/listing-13-08/output.txt}}\"><pre><span class=\"pl-c1\">{{#include ../listings/ch13-functional-features/listing-13-08/output.txt}}</span></pre></div>\n<p dir=\"auto\">The error points to the line in the closure body that moves <code>value</code> out of the\nenvironment. To fix this, we need to change the closure body so that it doesn’t\nmove values out of the environment. To count the number of times <code>sort_by_key</code>\nis called, keeping a counter in the environment and incrementing its value in\nthe closure body is a more straightforward way to calculate that. The closure\nin Listing 13-9 works with <code>sort_by_key</code> because it is only capturing a mutable\nreference to the <code>num_sort_operations</code> counter and can therefore be called more\nthan once:</p>\n<p dir=\"auto\"><span>Filename: src/main.rs</span></p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"{{#rustdoc_include ../listings/ch13-functional-features/listing-13-09/src/main.rs}}\"><pre><span class=\"pl-kos\">{</span><span class=\"pl-kos\">{</span>#rustdoc_include ../listings/ch13-functional-features/listing-<span class=\"pl-c1\">13</span>-<span class=\"pl-c1\">09</span>/src/main<span class=\"pl-kos\">.</span><span class=\"pl-c1\">rs</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><span>Listing 13-9: Using an <code>FnMut</code> closure with <code>sort_by_key</code>\nis allowed</span></p>\n<p dir=\"auto\">The <code>Fn</code> traits are important when defining or using functions or types that\nmake use of closures. In the next section, we’ll discuss iterators. Many\niterator methods take closure arguments, so keep these closure details in mind\nas we continue!</p>\n</article>","renderedFileInfo":null,"shortPath":null,"tabSize":8,"topBannersInfo":{"overridingGlobalFundingFile":false,"globalPreferredFundingPath":null,"repoOwner":"rust-lang","repoName":"book","showInvalidCitationWarning":false,"citationHelpUrl":"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/about-citation-files","showDependabotConfigurationBanner":false,"actionsOnboardingTip":null},"truncated":false,"viewable":true,"workflowRedirectUrl":null,"symbols":{"timedOut":false,"notAnalyzed":true,"symbols":[]}},"copilotInfo":null,"csrf_tokens":{"/rust-lang/book/branches":{"post":"T5B38HGhlG1Ewrc8s0TLx0sBVxU8fbNkvvZbVUcybEBlwZh5p-4mLwkFXIfJI7YAHqTDBLHcjv8EODybQn8XuQ"},"/repos/preferences":{"post":"VA8sEI6FS2n5swHkLGwLWTRdBevvXDqbhVIHOi8Cz_dVFiG0WQd0cEWWQTVJv5PEQV7SbfQK67samdtk3Q9O2w"}}},"title":"book/src/ch13-01-closures.md at main · rust-lang/book"}